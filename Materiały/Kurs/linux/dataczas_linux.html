<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks: Data i czas </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm">
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm">

<link rel="alternate" type="text/html" href="dataczas_linux_en.html"
	hreflang="en" lang="en" title="English version">

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Pobieranie i ustawiadnie daty oraz godziny w jêzyku asembler pod Linuksem">
<META NAME="Keywords" CONTENT="assembler, asm, asembler, linux, linuks, data, czas, timestamp,
	date, time, GMT, UTC">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Tue, Jan 18 2011 17:59:57 CEST">
</HEAD><BODY>

<h1 class="nag">Pobieranie i ustawianie daty oraz godziny pod Linuksem</h1>
<P>
Bie¿±ca data i godzina w systemie Linux jest przechowywana w postaci tzw. znacznika czasu.
 Jest to liczba oznaczaj±ca liczbê sekund, które up³ynê³y od pierwszego dnia stycznia roku 1970, od
 pó³nocy czasu <acronym title="Universal Time Coordinated" lang="en">UTC</acronym>
  (<acronym title="Greenwich Mean Time" lang="en">GMT</acronym>). Znacznik czasu pobierany
  jest funkcj± <span class="b">sys_time</span> (numer 13), a nowy czas mo¿na ustawiæ za pomoc±
  funkcji <span class="b">sys_stime</span> (numer 25).<br>
 Je¶li nie chcemy korzystaæ z ¿adnych bibliotek, to ta forma jest do¶æ niewygodna w u¿yciu.
 Dlatego przedstawiê tu sposoby przerabiania znacznika czasu na formê tradycyjn± i odwrotnie.</P>
<P>
Artyku³ ten opracowa³em na podstawie kodu ¼ród³owego linuksowej biblioteki jêzyka C (glibc),
 konkretnie - na podstawie pliku glibc/time/offtime.c.</P>





<br>
<hr>
<h2 class="nag">Zmiana znacznika czasu na formê tradycyjn±</h2>
	<BR><a href="#dataczas_tr2ts" class="bezdruk" tabindex="1">(przeskocz do konwersji w drug± stronê)</a>

<ol>
 <li>dzielimy znacznik przez liczbê sekund przypadaj±c± na dzieñ (60*60*24), zachowujemy iloraz
 	jako liczbê dni oraz resztê z tego dzielenia</li>
 <li>do reszty dodajemy przesuniêcie naszego czasu od GMT, w sekundach (60*60 w czasie zimowym,
 	2*60*60 w czasie letnim)</li>
 <li>je¶li reszta jest mniejsza od zera, to dodajemy do niej liczbê sekund przypadaj±cych na dzieñ,
 	a¿ stanie siê wiêksza od zera, za ka¿dym razem zmniejszaj±c liczbê dni z pierwszego kroku</li>
 <li>je¶li reszta jest wiêksza od liczby sekund dnia, to odejmujemy do niej liczbê sekund przypadaj±cych na dzieñ,
 	a¿ stanie siê mniejsza od tej liczby, za ka¿dym razem zwiêkszaj±c liczbê dni z pierwszego kroku</li>
 <li>dzielimy resztê przez liczbê sekund przypadaj±c± na godzinê. Iloraz zachowujemy jako obliczon±
 	godzinê, resztê zapisujemy do zmiennej, któr± dalej nazywamy <q>reszt±</q></li>
 <li>resztê z poprzedniego kroku dzielimy przez liczbê sekund w minucie. Iloraz zachowujemy jako liczbê
 	minut bie¿±cego czasu, resztê - jako liczbê sekund</li>
 <li>do liczby dni dodajemy 4 (jako ¿e pierwszy stycznia 1970 by³ czwartkiem), a wynik dzielimy przez 7.
 	Resztê (je¶li jest ujemna, dodajemy 7) z tego dzielenia zachowujemy jako
 	dzieñ tygodnia (0 oznacza niedzielê)</li>
 <li>do zmiennej Y wstawiamy 1970</li>
 <li>w pêtli wykonuj dzia³ania:
  <ol class="alfa">
   <li>sprawd¼, czy liczba dni jest mniejsza od zera lub wiêksza od liczby dni w roku Y. Je¶li nie
   	zachodzi ani to, ani to, wyjd¼ z pêtli.<br>
   	W tym kroku nale¿y sprawdziæ, czy Y jest przestêpny. Ka¿dy rok, który dzieli siê przez 4, lecz nie dzieli siê
   	przez 100 jest przestêpny. Dodatkowo, ka¿dy rok, który dzieli siê przez 400, jest przestêpny.</li>
   <li>do nowej zmiennej YG wstaw sumê Y oraz ilorazu z dzielenia liczby dni przez 365. Je¶li reszta z dzielenia
   	liczby dni przez 365 by³a ujemna, od YG odejmij jeden.</li>
   <li>od liczby dni odejmij ró¿nicê miêdzy YG a Y pomno¿on± przez 365</li>
   <li>od liczby dni odejmij wynik procedury DODATEK (omówiona pó¼niej), wykonanej na liczbie YG-1</li>
   <li>do liczby dni dodaj wynik procedury DODATEK (omówiona pó¼niej), wykonanej na liczbie Y-1</li>
   <li>do Y wstaw YG</li>
  </ol></li>
 <li>do numeru dnia w roku wstaw bie¿±c± warto¶æ liczby dni</li>
 <li>sprawd¼, w którym miesi±cu znajduje siê dzieñ o tym numerze i zapisz ten miesi±c. Od liczby
 	dni odejmij sumaryczn± liczbê dni we wszystkich poprzednich miesi±cach.</li>
 <li>do dnia miesi±ca wstaw bie¿±c± liczbê dni powiêkszon± o 1</li>
</ol>
<P>Procedura DODATEK sk³ada siê z kroków:</P>
<ol>
 <li>podziel podany rok przez 4 i zachowaj wynik. Je¶li reszta wysz³a mniejsza od zera, od wyniku
 	odejmij 1</li>
 <li>podziel podany rok przez 100 i zachowaj wynik. Je¶li reszta wysz³a mniejsza od zera, od wyniku
 	odejmij 1</li>
 <li>podziel podany rok przez 400 i zachowaj wynik. Je¶li reszta wysz³a mniejsza od zera, od wyniku
 	odejmij 1</li>
 <li>od pierwszego wyniku odejmij drugi, po czym dodaj trzeci, a ca³o¶æ zwróæ jako wynik procedury</li>
</ol>

<P>
Ca³y ten skomplikowany algorytm jest ukazany w tym oto programie (sk³adnia FASM):</P>
	<BR><a href="#dataczas_tr2ts" class="bezdruk">(przeskocz program)</a>
<pre title="Program konwertuj±cy znacznik czasu na datê">
; Program wyliczaj±cy bie¿±c± datê i godzin± na podstawie bie¿±cego
;	znacznika czasu. Program NIC NIE WY¦WIETLA.
;
; Autor: Bogdan D., bogdandr (at) op.pl
;
; kompilacja:
;   fasm dataczas.fasm

format ELF executable
segment executable
entry main

SEK_NA_GODZ	= (60 * 60)		; liczba sekund w godzinie
SEK_NA_DZIEN	= (SEK_NA_GODZ * 24)	; liczba sekund w dobie
LETNI		= 1			; 0, gdy zimowy, 1 gdy letni
PRZES_GMT	= 1*SEK_NA_GODZ + LETNI*SEK_NA_GODZ  ; przesuniêcie od GMT

main:
	mov	eax, 13
	xor	ebx, ebx
	int	80h	; pobierz aktualny czas w sekundach
	mov	[czas], eax

	mov	ebx, SEK_NA_DZIEN
	xor	edx, edx
	idiv	ebx	; liczba sekund / liczba sekund w dniu = liczba dni

	add	edx, PRZES_GMT	; dodaj strefê czasow±

	; je¶li reszta sekund &lt; 0, dodajemy do niej liczbê sekund dnia,
	; ale równocze¶nie zmniejszamy liczbê dni (EAX)
spr_reszte:
	cmp	edx, 0
	jge	reszta_ok

	add	edx, SEK_NA_DZIEN
	sub	eax, 1

	jmp	spr_reszte

reszta_ok:

	; je¶li reszta sekund &gt; liczba sekund w dniu, odejmujemy od niej
	; liczbê sekund dnia, ale równocze¶nie zwiêkszamy liczbê dni (EAX)
spr_reszte2:
	cmp	edx, SEK_NA_DZIEN
	jl	reszta_ok2

	sub	edx, SEK_NA_DZIEN
	add	eax, 1

	jmp	spr_reszte2

reszta_ok2:

	mov	[l_dni], eax
	mov	[reszta], edx

	mov	eax, edx	; EAX = reszta
	mov	ebx, SEK_NA_GODZ
	xor	edx, edx
	idiv	ebx	; EAX = numer godziny, reszta - minuty+sekundy

	mov	[godz], al	; zachowujemy godzinê
	mov	[reszta], edx	; i now± resztê

	mov	eax, edx
	mov	ecx, 60
	xor	edx, edx
	idiv	ecx		; now± resztê dzielimy przez 60

	mov	[min], al	; iloraz to liczba minut
	mov	[sek], dl	; a reszta - liczba sekund

	; znajdujemy dzieñ tygodnia
	mov	eax, [l_dni]
	add	eax, 4	; 1970-1-1 to czwartek
	mov	ebx, 7
	xor	edx, edx
	idiv	ebx	; EAX = dzieñ tygodnia

	cmp	dl, 0
	jge	dzient_ok
	add	dl, 7	; dodajemy 7, je¶li by³ mniejszy od zera
dzient_ok:
	mov	[dzient], dl


	; pocz±tek pêtli z punktu 9
spr_dni:
	mov	eax, [y]
	call	czy_przest	; ECX = 0, gdy Y jest przestêpny.

	cmp	dword [l_dni], 0
	jl	zmien_dni	; sprawdzamy, czy liczba dni &lt; 0

	mov	esi, 365
	test	ecx, ecx
	jnz	.przest_ok
	add	esi, 1		; dodajemy 1 dzieñ w roku przestêpnym
.przest_ok:

	cmp	[l_dni], esi
	jl	koniec_spr_dni	; sprawdzamy, czy liczba dni &gt;= 365/366

zmien_dni:

	mov	esi, 365
	mov	eax, [l_dni]
	xor	edx, edx
	idiv	esi		; EAX = liczba dni/365
	mov	ecx, eax	; zachowujemy do ECX
	cmp	edx, 0
	jge	.edx_ok1
	sub	ecx, 1		; je¶li reszta &lt; 0, to odejmujemy 1
.edx_ok1:
	add	ecx, [y]	; ECX = liczba dni/365 + Y +1 lub +0
	mov	[yg], ecx	; zachowaj do YG

	sub	ecx, [y]
	imul	ecx, ecx, 365	; ECX = (YG-Y)*365

	push	ecx
	mov	eax, [yg]
	sub	eax, 1
	call	dodatek		; wylicz DODATEK na YG-1 i zapisz w [przest]
	pop	ecx
	add	ecx, [przest]	; ECX = (YG-Y)*365+DODATEK(YG-1)

	push	ecx
	mov	eax, [y]
	sub	eax, 1
	call	dodatek		; wylicz DODATEK na Y-1 i zapisz w [przest]
	pop	ecx
	sub	ecx, [przest]	; ECX=(YG-Y)*365+DODATEK(YG-1)-DODATEK(Y-1)

	sub	[l_dni], ecx	; odejmij ca³o¶æ na raz od liczby dni

	mov	eax, [yg]
	mov	[y], eax	; do Y wstaw YG

	jmp	spr_dni		; i na pocz±tek pêtli

koniec_spr_dni:
	mov	eax, [y]
	;sub	eax, 1900
	mov	[rok], ax	; zapisz wyliczony rok
	call	czy_przest	; ECX = 0, gdy przestêpny

	mov	eax, [l_dni]
	mov	[dzienr], ax	; zapisz numer dnia w roku

	; sprawdzimy, do którego miesi±ca nale¿y wyliczony numer dnia
	xor	esi, esi	; zak³adamy rok nieprzestêpny
	mov	ebx, 2		; zaczynamy od pierwszego miesi±ca
	test	ecx, ecx
	jnz	.nie_przest
	add	esi, 13*2	;je¶li przestêpny,bierzemy drug± grupê liczb
.nie_przest:
	; szukamy miesi±ca. EAX = numer dnia w roku
	cmp	ax, [dni1+esi+ebx]  ; porównujemy numer dnia z sum± dni a¿
				; do NASTÊPNEGO miesi±ca
	jbe	mies_juz	; je¶li ju¿ mniejszy, przerywamy
	add	ebx, 2		; sprawdzamy kolejny miesi±c
	jmp	.nie_przest

mies_juz:
		; aby dostaæ numer dnia w miesi±cu, odejmujemy od numeru dnia
		;sumê liczb dni we wszystkich POPRZEDNICH miesi±cach, st±d -2
	sub	ax, [dni1+esi+ebx-2]
	inc	al	; i dodajemy jeden, ¿eby nie liczyæ od zera
	mov	[dzien], al	; zapisujemy dzieñ miesi±ca

	shr	ebx, 1	; numer znalezionego miesi±ca dzielimy przez 2, bo
			; s± 2 bajty na miesi±c
	mov	[mies], bl	; i zachowujemy

	mov	eax, 1
	xor	ebx, ebx
	int	80h	; koniec programu


dodatek:
; oblicza DODATEK dla roku podanego w EAX
	push	eax
	push	ebx
	push	ecx
	push	edx
	push	esi
	push	edi

	mov	esi, 4
	mov	edi, 100
	mov	ebx, 400
	and	eax, 0ffffh

	push	eax
	xor	edx, edx
	idiv	esi		; dziel EAX przez 4
	mov	ecx, eax	; zachowaj wynik
	cmp	edx, 0		; sprawd¼ resztê
	jge	.edx_ok1
	sub	ecx, 1		; je¶li reszta &lt; 0, od wyniku odejmij 1
.edx_ok1:

	pop	eax
	push	eax
	xor	edx, edx
	idiv	edi		; dziel EAX przez 100
	sub	ecx, eax	; odejmij od bie¿±cego wyniku
	cmp	edx, 0		; sprawd¼ resztê
	jge	.edx_ok2
	add	ecx, 1		; je¶li reszta &lt; 0, od wyniku odejmij 1
.edx_ok2:

	pop	eax
	xor	edx, edx
	idiv	ebx		; dziel EAX przez 400
	add	ecx, eax	; dodaj do bie¿±cego wyniku
	cmp	edx, 0		; sprawd¼ resztê
	jge	.edx_ok3
	sub	ecx, 1		; je¶li reszta &lt; 0, od wyniku odejmij 1
.edx_ok3:

	mov	[przest], ecx	; zachowaj wynik

	pop	edi
	pop	esi
	pop	edx
	pop	ecx
	pop	ebx
	pop	eax
	ret

; zwraca 0 w ECX, gdy rok podany w EAX jest przestêpny, 1 - gdy nie jest
czy_przest:
	push	eax
	push	ebx
	push	edx

	xor	ecx, ecx

	push	eax
	xor	edx, edx
	mov	ebx, 4
	idiv	ebx		; dziel EAX przez 4
	pop	eax
	test	edx, edx
	jnz	.nie_jest	; reszta ró¿na od zera oznacza, ¿e siê nie
				; dzieli, czyli nie mo¿e byæ przestêpny

	; bêd±c tu wiemy, ¿e rok dzieli siê przez 4
	push	eax
	xor	edx, edx
	mov	ebx, 100
	idiv	ebx		; dziel EAX przez 100
	pop	eax
	test	edx, edx
	jnz	.jest		; reszta ró¿na od zera oznacza, ¿e siê nie
				; dzieli przez 100, a dzieli³ siê przez 4,
				; czyli jest przestêpny


	; bêd±c tu wiemy, ¿e rok dzieli siê przez 4 i przez 100
	push	eax
	xor	edx, edx
	mov	ebx, 400
	idiv	ebx		; dziel EAX przez 400
	pop	eax
	test	edx, edx
	jz	.jest		; reszta równa zero oznacza, ¿e siê dzieli
				; przez 400, czyli jest przestêpny

.nie_jest:
	mov	ecx, 1

.jest:
	pop	edx
	pop	ebx
	pop	eax
	ret


segment readable writeable

l_dni	dd	0	; wyliczona liczba dni
reszta	dd	0	; reszta z dzieleñ
y	dd	1970	; pocz±tkowa warto¶æ Y
yg	dd	0	; zmienna YG
przest	dd	0	; dodatek
czas	dd	0	; znacznik czasu

rok	dw	0	; bie¿±cy rok
mies	db	0	; bie¿±cy miesi±c
dzien	db	0	; bie¿±cy dzieñ miesi±ca
dzient	db	0	; bie¿±cy dzieñ tygodnia
dzienr	dw	0	; bie¿±cy dzieñ roku

godz	db	0	; bie¿±ca godzina
min	db	0	; bie¿±ca minuta
sek	db	0	; bie¿±ca sekunda

; liczby dni poprzedzaj±cych ka¿dy miesi±c w roku zwyk³ym i przestêpnym
dni1	dw	0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
	dw	0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366</pre>



<br>
<hr>
<h2 class="nag"><a name="dataczas_tr2ts" id="dataczas_tr2ts">Zmiana formy
	tradycyjnej na znacznik czasu</a></h2>
<P>
Ten algorytm jest o wiele prostszy. Mianowicie:<br>
Znacznik czasu = SEKUNDY + MINUTY*60 + GODZINY*60*60 + DZIEÑ_ROKU*60*60*24 + LATA_OD_1970*60*60*24*365
	+ LATA_PRZESTÊPNE_OD_1970*60*60*24</P>
<P>Wystarczy jedynie obliczyæ, którym dniem w roku jest bie¿±cy dzieñ (znaj±c dzieñ miesi±ca, korzystamy
 z tablicy w powy¿szym programie i do okre¶lonej liczby dodajemy bie¿±cy numer dnia) oraz ile
 by³o lat przestêpnych od roku 1970 do bie¿±cego (wed³ug znanych regu³, wystarczy w pêtli dla ka¿dego
 roku uruchomiæ procedurê czy_przest z poprzedniego programu).</P>
<P>Zauwa¿cie, ¿e tyle, ile by³o lat przestêpnych, tyle dodajemy <span class="b">dni</span>, nie
 ca³ych lat.</P>


<br>
<div class="bezdruk">
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>


</BODY></HTML>
