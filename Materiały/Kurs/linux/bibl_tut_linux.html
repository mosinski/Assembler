<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks: W³asne biblioteki </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Tworzenie w³asnych bibliotek pod Linuksem">
<META NAME="Keywords" CONTENT="biblioteka, lib, asm, linux, linuks, assembler, asembler">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">

<meta http-equiv="Last-Modified" content="Tue, Jan 18 2011 17:59:56 CEST">
</HEAD><BODY>

<h1 class="nag">Pisanie w³asnych bibliotek w jêzyku asembler pod Linuksem</h1>


<P>Pewnie zdarzy³o siê ju¿ wam us³yszeæ o kim¶ innym:<BR>
<q>Ale¿ on(a) jest ¶wietnym(±) programist±(k±)! Nawet pisze w³asne biblioteki!</q><BR>
Poka¿ê teraz, ¿e nie jest to trudne, nie wa¿ne jak przera¿aj±cym siê to mo¿e wydawaæ.
Osoby, które przeczytaj± ten artyku³ i zdobêd± troszkê wprawy bêd± mog³y mówiæ:<BR>
<q>Phi, a co to za filozofia pisaæ w³asne biblioteki!</q></P>

<P>Zacznijmy wiêc od pytania: co powinno siê znale¼æ w takiej bibliotece?<BR>
Mog± to byæ:</P>
<UL>
 <LI> Funkcje wej¶cia i wyj¶cia, podobnie jak na przyk³ad w jêzyku C<BR><BR></LI>
 <LI> Funkcje, które ju¿ przepisywali¶my ze 20 razy w ró¿nych programach<BR><BR></LI>
 <LI> Sprawdzone funkcje, napisane przez kogo¶ innego, których nie umieliby¶my sami
      napisaæ, lub które po prostu mog± siê przydaæ<BR><BR></LI>
</UL>

<P>Co to za¶ jest to owa biblioteka?<BR>
Jest to plik na który sk³ada siê skompilowany kod, a wiêc na przyk³ad pliki .o.
Sama biblioteka najczê¶ciej ma rozszerzenie .a (gdy zawiera statyczny kod) lub .so.*
 (dla bibliotek wspó³dzielonych).
Biblioteka eksportuje na zewn±trz nazwy
procedur w niej zawartych, aby linker wiedzia³, jaki adres podaæ programowi, który chce
skorzystaæ z takiej procedury.</P>
<P>
Bêdê w tym artykule u¿ywa³ sk³adni i linii poleceñ  NASMa (<span lang="en">Netwide Assembler</span>)
 z linkerem LD i archiwizatorem AR.</P>
<P>Napiszmy wiêc jaki¶ prosty kod ¼ród³owy. Oto on:</P>
	<BR><a href="#bibl_tut_linux01" tabindex="1" class="bezdruk">(przeskocz przyk³adowy modu³ biblioteki)</a>
<PRE title="przyk³adowy modu³ biblioteki">
;  Biblioteka Standardowa
;  Emisja d¼wiêku przez g³o¶niczek
;  Autor: Bogdan Drozdowski, 09.2002
;  kontakt: bogdandr MA£PKA op.pl
;  Wersja Linux: 05.02.2004
;  Ostatnia modyfikacja: 29.08.2004

%include &quot;../incl/linuxbsd/nasm/n_system.inc&quot;

global  _graj_dzwiek

KIOCSOUND       equ     0x4B2F

section .data

konsola		db	&quot;/dev/console&quot;, 0

struc timespec
        .tv_sec:	resd 1
        .tv_nsec:	resd 1
endstruc

t1 istruc timespec
t2 istruc timespec

segment biblioteka_dzwiek


_graj_dzwiek:

;  graj

;  wej¶cie:	BX = ¿±dana czêstotliwo¶æ d¼wiêku w Hz, co najmniej 19
;		CX:DX = czas trwania d¼wiêku w mikrosekundach
;
;  wyj¶cie:	CF = 0 - wykonane bez b³êdów
;		CF = 1 - b³±d:	 BX za ma³y

	pushfd
	push    eax
	push    ebx
	push    ecx
	push    edx
	push	esi

	cmp     bx, 19		;najni¿sza mo¿liwa czêstotliwo¶æ to ok. 18Hz
	jb      ._graj_blad

	push	ecx
	push	edx
	push	ebx

	mov     eax, sys_open	; otwieramy konsolê do zapisu
	mov     ebx, konsola
	mov     ecx, O_WRONLY
	mov     edx, 600q
	int     80h

        cmp     eax, 0
        jg      .otw_ok

        mov     eax, 1  	; jak nie otworzyli¶my konsoli,
        			; piszemy na standardowe wyj¶cie
.otw_ok:
        mov     ebx, eax	; EBX = uchwyt do pliku
	mov	esi, eax	; ESI = uchwyt do pliku

	mov     eax, sys_ioctl	; sys_ioctl = 54
	mov     ecx, KIOCSOUND
	xor     edx, edx	; wy³±czenie ewentualnych d¼wiêków
	int     80h

	pop	ebx		; BX = czêstotliwo¶æ
	mov	eax, 1234ddh
	xor	edx, edx
	div	ebx		; EAX=1234DD/EBX - ta liczba idzie do ioctl

	mov     edx, eax
	mov	ebx, esi	; EBX = uchwyt do konsoli lub stdout
	mov     eax, sys_ioctl
	int     80h

	pop	edx
	pop	ecx

				; pauza o d³ugo¶ci CX:DX mikrosekund:
	mov	eax, ecx
	shl	eax, 16
	mov	ebx, 1000000
	mov	ax, dx		; EAX = CX:DX
	xor	edx, edx
	div     ebx
	mov     [t1+timespec.tv_sec], eax ;  EAX = liczba sekund

	mov     ebx, 1000
	mov     eax, edx
	mul     ebx
	mov     [t1+timespec.tv_nsec], eax ;  EAX = liczba nanosekund

	mov     eax, sys_nanosleep
	mov     ebx, t1
	mov     ecx, t2
	int     80h		; robimy przerwê...


	mov	eax, sys_ioctl
	mov	ebx, esi	; EBX = uchwyt do konsoli/stdout
	mov	ecx, KIOCSOUND
	xor	edx, edx	; wy³±czamy d¼wiêk
	int	80h

	cmp	ebx, 2		; nie zamykamy stdout
	jbe	._graj_koniec

        mov	eax, sys_close  ; sys_close = 6
        int	80h


._graj_koniec:
	pop	esi
	pop	edx
	pop	ecx
	pop	ebx
	pop	eax
	popfd
	clc			;  zwróæ brak b³êdu

	ret


._graj_blad:
	pop	esi
	pop	edx
	pop	ecx
	pop	ebx
	pop	eax

	popfd
	stc			;  zwróæ b³±d

	ret

</PRE>
<P><a name="bibl_tut_linux01" id="bibl_tut_linux01">Jest to moja procedura</a> wytwarzaj±ca d¼wiêk
w g³o¶niczku (patrz mój <a href="spkr_tut_linux.html" hreflang="pl">artyku³ o programowaniu g³o¶niczka</a>).
Trochê tego jest, co? Ale jest tu du¿o spraw, które mo¿na omówiæ.</P>

<P>Zacznijmy wiêc po kolei:</P>
<OL>
 <LI> <CODE>global...</CODE>
      <P>Funkcje, które maj± byæ widoczne na zewn±trz tego pliku, a wiêc mo¿liwe do u¿ycia przez
      inne programy, musz± byæ zadeklarowane jako <q lang="en">public</q> (w NASMie: global).
       Tutaj jest to na wszelki wypadek.
      Niektóre kompilatory domy¶lnie traktuj± wszystkie symbole jako publiczne, inne nie.
      Je¶li w programie bêdziemy chcieli korzystaæ z takiej funkcji, nale¿y j± zadeklarowaæ
      jako <q>extrn</q> (FASM) lub <q>extern</q> (NASM).
	</P></LI>
 <LI> Deklaracja segmentu
      <P>¯aden przyzwoity kompilator nie pozwoli na pisanie kodu poza jakimkolwiek segmentem
      (no chyba, ¿e domy¶lnie zak³ada segment kodu, jak NASM).
      Normalnie, w zwyk³ych programach, rolê tê pe³ni dyrektywa <q lang="en">section .text</q>.
	</P></LI>
 <LI> Gwiazdki lub inne elementy oddzielaj±ce (tu usuniête)
      <P>Mog± siê wydawaæ ¶mieszne lub niepotrzebne, ale gdy liczba procedur w pliku zaczyna
      siêgaæ 10-20, to NAPRAWDÊ zwiêkszaj± czytelno¶æ kodu, oddzielaj±c procedury, dane itd.
	</P></LI>
 <LI> Deklaracja procedury (wcze¶niej zadeklarowanej jako global)
      <P>Znak podkre¶lenia z przodu jest tylko po to, by w razie czego nie by³ identyczny z jak±¶
      etykiet± w programie korzystaj±cym z biblioteki.
	</P></LI>
 <LI> To, czego procedura oczekuje i to, co zwraca.
      <P>Jedn± procedurê ³atwo zapamiêtaæ. Ale co zrobiæ, gdy jest ich ju¿ 100? Analizowaæ kod ka¿dej,
      aby sprawdziæ, co robi, bo akurat szukamy takiej jednej....? No przecie¿ nie.
	</P></LI>
 <LI> <P>Dobr± technik± programowania jest deklaracja sta³ych w stylu EQU
 	(lub #<span lang="en">define</span> w C).
      Zamiast nic nie znacz±cej liczby mo¿na u¿yæ wiele znacz±cego zwrotu, co przyda siê dalej
      w kodzie. I nie kosztuje to ani jednego bajtu. Oczywi¶cie, ukrywa to czê¶æ kodu (tutaj:
      numery portów), ale w razie potrzeby zmienia siê tê wielko¶æ tylko w 1 miejscu, a nie
      w 20.
	</P></LI>
 <LI> Zachowywanie zmienianych rejestrów (<span lang="en">push</span>)
      <P>Poza warto¶ciami zwracanymi nic nie mo¿e byæ zmienione! Nieprzyjemnym uczuciem by³oby
      spêdzenie kilku godzin przy odpluskwianiu (debugowaniu) programu tylko dlatego, ¿e kto¶
      zapomnia³ zachowaæ jakiego¶ rejestru, prawda?
	</P></LI>
 <LI> <P>Sprawdzanie warunków wej¶cia, czy s± prawid³owe. Zawsze nale¿y wszystko przewidzieæ.
	</P></LI>
 <LI> <P>Kod procedury. Z punktu widzenia tego artyku³u jego tre¶æ jest dla nas nieistotna.
	</P></LI>
 <LI> Punkt(y) wyj¶cia
      <P>Procedura mo¿e mieæ dowolnie wiele punktów wyj¶cia. Tutaj zastosowano
      dwa, dla dwóch ró¿nych sytuacji:</P>
      <OL>
       <LI> parametr by³ dobry, procedura zakoñczy³a siê bez b³êdów<BR><BR></LI>
       <LI> parametr by³ z³y, zwróæ informacjê o b³êdzie<BR><BR></LI>
      </OL></LI>
</OL>

<P>Mamy wiêc ju¿ plik ¼ród³owy. Co z nim zrobiæ? Skompilowaæ, oczywi¶cie!</P>
<PRE>nasm -f elf naszplik.asm</PRE>
<P>(-f - okre¶l format pliku wyj¶ciowego: <span lang="en">Executable-Linkable</span> Format,
 typowy dla Linuksa)
</P>
<P>
Mamy ju¿ plik naszplik.o. W pewnym sensie on ju¿ jest bibliotek±! I mo¿na go u¿ywaæ w innych
programach, na przyk³ad w pliku program2.asm mamy (FASM):</P>
<PRE>
	...
	extrn _graj_dzwiek		; NASM: extern _graj_dzwiek

	...
	...
	mov bx,440
	mov cx,0fh
	mov dx,4240h
	call _graj_dzwiek
	...</PRE>

<P>I mo¿emy teraz zrobiæ:</P>
<PRE>
	nasm -f elf program2.asm
	ld -s -o program2 program2.o naszplik.o</PRE>

<P>a linker zajmie siê wszystkim za nas - utworzy plik program2, zawieraj±cy tak¿e
naszplik.o. Jaka z tego korzy¶æ? Plik program2.asm mo¿e bêdzie zmieniany w przysz³o¶ci
wiele razy, ale naszplik.asm/.o bêdzie ci±gle taki sam. A w razie chêci zmiany procedury
_graj_dzwiek wystarczy j± zmieniæ w jednym pliku i tylko jego ponownie skompilowaæ, bez potrzeby
wprowadzania tej samej zmiany w kilkunastu innych programach. Te programy wystarczy
tylko ponownie skompilowaæ z now± <q>bibliotek±</q>, bez jakichkolwiek zmian kodu.
</P>
<P>
No dobra, ale co z plikami .a?<BR>
Otó¿ s± one odpowiednio po³±czonymi plikami .o. I wszystko dzia³a tak samo.</P>
<P>No ale jak to zrobiæ?<BR>
S³u¿± do tego specjalne programy, w DOSie nazywane <q lang="en">librarian</q> (bibliotekarz).
 My tutaj u¿yjemy
archiwizatora AR. Pliki .o, które chcemy po³±czyæ w bibliotekê podajemy na linii poleceñ:</P>
<PRE>	ar -r libasm.a plik1.o plik2.o</PRE>

<P>I otrzymujemy plik libasm.a, który mo¿na do³±czaæ linkerem do programów:</P>
<PRE>	ld -s -o naszprog naszprog.o -L/¶cie¿ka_do_pliku.a -lasm</PRE>
<P>lub:</P>
<PRE>	ld -s -o naszprog naszprog.o /¶cie¿ka_do_pliku.a/libasm.a</PRE>
<BR>





<HR>
<h2 class="nag">Biblioteki wspó³dzielone .so</h2>

<P>
Prawie wszystkie programy w Linuksie u¿ywaj± podstawowej biblioteki systemu - biblioteki
 jêzyka C. Wyobra¿acie sobie, ile miejsca w pamiêci zajê³yby wszystkie u¿ywane kopie tej biblioteki?
 Na pewno niema³o. A poradzono sobie z tym, tworz±c specjalny rodzaj plików - bibliotekê
 wspó³dzielon±, ³adowan± i ³±czon± z programem dynamicznie (w chwili uruchomienia). Pliki
 te (o rozszerzeniu .so) s± odpowiednikami plików DLL znanych z systemów Windows. Teraz
 poka¿ê, jak pisaæ i kompilowaæ takie pliki. Wszystko to znajdziecie te¿ w dokumentacji
 kompilatora NASM.</P>
<P>
Regu³y s± takie:</P>
<OL>
 <LI><P>Dalej trzymajcie siê wszystkich powy¿szych uwag do kodu (komentarze itp.).</P></LI>

 <LI><span class="b">NIE</span> mo¿emy ju¿ siê odwo³ywaæ normalnie do swoich w³asnych zmiennych!
  <P>Dlaczego?
 Przyczyna jest prosta: biblioteki wspó³dzielone s± pisane jako kod niezale¿ny od pozycji
  (<span lang="en">Position-Independent Code</span>, PIC) i po prostu nie wiedz±,
   pod jakim adresem zostan± za³adowane przez system. Adres
 mo¿e za ka¿dym razem byæ inny. Do swoich zmiennych musimy siê wiêc odwo³ywaæ trochê inaczej, ni¿ to
 by³o do tej pory. Do biblioteki wspó³dzielonej linker do³±cza strukturê Globalnej Tablicy Offsetów
 (<span lang="en">Global Offset Table</span>, GOT). Biblioteka deklaruje j±
  jako zewnêtrzn± i korzysta z niej do ustalenia
 adresu swojego kodu. Wystarczy wykonaæ <code>call zaraz / zaraz: pop ebx</code>
  i ju¿ adres etykiety <q>zaraz</q>
 znajduje siê w EBX. Dodajemy do niego adres GOT od pocz±tku sekcji
 (<span lang="en">_GLOBAL_OFFSET_TABLE_</span> wrt ..gotpc) i adres pocz±tku sekcji, otrzymuj±c realny adres tablicy GOT +
 adres etykiety <q>zaraz</q>. Potem ju¿ tylko wystarczy odj±æ adres etykiety <q>zaraz</q> i ju¿ EBX
 zawiera adres GOT. Do zmiennych mo¿emy siê teraz odnosiæ poprzez <code>[ebx+nazwa_zmiennej]</code>.
 	</P></LI>

 <LI>Kompilacja i ³±czenie.
  <P>O ile kompilacja NASMem jest taka, jak zawsze, to ³±czenie programu jest zdecydowanie inne.
   Popatrzcie na opcje LD:</P>
 <UL>
  <LI><code lang="en">-shared</code>
  	<P>Mówi o tym, ¿e LD ma zbudowaæ bibliotekê wspó³dzielon±, zamiast zwyczajnego pliku wykonywalnego.
  	LD zadba o wszystko, co trzeba (GOT itd).</P></LI>
  <LI><code>-soname biblso.so.1</code>
  	<P>Nazwa biblioteki. Ale uwaga - NIE jest to nazwa pliku, tylko wewnêtrzna nazwa samej biblioteki.
  	Jak bêdziecie dodawaæ kolejne wersje, to nie zmieniajcie nazwy wewnêtrznej, tylko nazwê pliku .so,
  	a zróbcie dowi±zanie symboliczne do tego pliku, z nazw± tak± jak wewnêtrzna nazwa biblioteki, na przyk³ad
  	waszabibl.so.1 jako link do waszabibl.so.1.1.5.</P></LI>
 </UL></LI>

 <LI>Deklaracje zmiennych i funkcji globalnych.
 	<P>Ka¿da funkcja, któr± chcemy zrobiæ globaln± (widoczn± dla programów korzystaj±cych z biblioteki),
 	musi byæ zadeklarowana nie tylko jako extern, ale musimy podaæ te¿, ¿e jest to funkcja. Pe³na
 	dyrektywa wygl±da teraz:</P>
 	<PRE>		global nazwaFunkcji:function</PRE>
 	<P>Przy eksportowaniu danych dodajemy s³owo <q>data</q> i rozmiar danych, na przyk³ad dla tablic:</P>
	<PRE>

	global tablica1:data tablica1_dlugosc

	tablica1:		resb	100
	tablica1_dlugosc	equ	$ - tablica1</PRE></LI>

 <LI>Uruchamianie funkcji zewnêtrznych (na przyk³ad z biblioteki C)
 	<P>Sprawa jest ju¿ du¿o prostsza ni¿ w przypadku danych. Funkcjê zewnêtrzn± deklarujemy oczywi¶cie
 	s³owem <q>extern</q>, a zamiast <q>call nazwaFunkcji</q> piszemy</P>
 	<PRE>		call nazwaFunkcji wrt ..plt</PRE>
 	<P>PLT oznacza <span lang="en">Procedure Linkage Table</span>,
 	czyli tablicê linkowania procedur (funkcji). Zawiera ona skoki do
 	odpowiednich miejsc, gdzie znajduje siê dana funkcja.</P></LI>

</OL>
<P>A oto gotowy przyk³ad. Biblioteka eksportuje jedn± funkcjê, która po prostu wy¶wietla napis.</P>
	<BR><a href="#bibl_tut_linux02" class="bezdruk">(przeskocz przyk³adow± bibliotekê wspó³dzielon±)</a>
<PRE title="przyk³adowa biblioteka wspó³dzielona">
; Przyk³ad linuksowej biblioteki wspó³dzielonej .so
;
; Autor: Bogdan D., bogdandr (at) op.pl
;
; kompilacja:
;   nasm -f elf -o biblso.o biblso.asm
;   ld -shared -soname biblso.so.1 -o biblso.so.1 biblso.o


section	.text
extern	_GLOBAL_OFFSET_TABLE_	; zewnêtrzny, uzupe³niony przez linker
global	info:function		; eksportowana funkcja
;extern	printf			; funkcja zewnêtrzna

; makro do pobierania adresu GOT; wynik w EBX.
%imacro	wez_GOT	0

	call	%%zaraz
	%%zaraz:
	pop	ebx
	add	ebx, _GLOBAL_OFFSET_TABLE_ + $$ - %%zaraz wrt ..gotpc
%endmacro

info:
				; zachowanie zmienianych rejestrów
	push	eax
	push	ebx
	push	ecx
	push	edx

	wez_GOT			; pobieramy adres GOT
	push	ebx		; zachowujemy EBX

	mov	eax, 4		; funkcja pisania do pliku
			; do ECX za³aduj ADRES napisu (stad LEA a nie MOV)
	lea	ecx, [ebx + napis wrt ..gotoff]
	mov	ebx, 1		; plik = 1 = standardowe wyj¶cie (ekran)
	mov	edx, napis_dl	; d³ugo¶æ napisu
	int	80h		; wy¶wietl

; a tak uruchamiamy funkcje zewnêtrzne:
	pop	ebx		; przywracamy EBX
	lea	ecx, [ebx + napis wrt ..gotoff]	; ECX = adres napisu
	push	ecx		; adres na stos (jak dla funkcji z C)
;	call	printf wrt ..plt	; uruchomienie funkcji
	add	esp, 4		; usuniêcie argumentów ze stosu

				; przywracanie rejestrów
	pop	edx
	pop	ecx
	pop	ebx
	pop	eax

	xor	eax, eax	; funkcja zwraca 0 jako brak b³êdu
	ret

section .data

napis		db	&quot;Jestem biblioteka wspoldzielona!&quot;, 10, 0
napis_dl	equ	$ - napis</PRE>

<P><a name="bibl_tut_linux02" id="bibl_tut_linux02">Program sprawdzaj±cy</a>, czy biblioteka dzia³a
jest wyj±tkowo prosty: jedno uruchomienie funkcji z biblioteki i wyj¶cie. Na uwagê zas³uguje
 jednak ta d³uga linijka z uruchomieniem LD. Przyjrzyjmy siê bli¿ej:</P>
 <UL>
  <LI>-<span lang="en">dynamic</span>-linker /lib/ld-linux.so.2
  	<P>Mówi o nazwie programu, którego trzeba u¿yæ do dynamicznego ³±czenia. Bez tej opcji
  	nasz program nie podzia³a i dostaniemy b³±d
  	<q lang="en">Accessing a corrupted shared library</q></P></LI>

  <LI>-nostdlib
  	<P>Nie do³±cza ¿adnych standardowych bibliotek.</P></LI>

  <LI>-o biblsotest biblsotest.o
  	<P>Nazwy pliku wyj¶ciowego i wej¶ciowego.</P></LI>

  <LI>biblso.so.1
  	<P>Biblioteka, z któr± nale¿y po³±czyæ ten program</P></LI>
 </UL>

	<BR><a href="#bibl_tut_linux03" class="bezdruk">(przeskocz test biblioteki wspó³dzielonej)</a>
<PRE>
; Program testuj±cy linuksow± bibliotekê wspó³dzielon± .so
;
; Autor: Bogdan D., bogdandr (at) op.pl
;
; kompilacja:
; nasm -f elf -o biblsotest.o biblsotest.asm
; ld -dynamic-linker /lib/ld-linux.so.2 -nostdlib \
;	-o biblsotest biblsotest.o biblso.so.1


section	.text
global	_start

extern	info

_start:

	call	info

	mov	eax, 1
	xor	ebx, ebx
	int	80h</PRE>

<P><a name="bibl_tut_linux03" id="bibl_tut_linux03">Je¶li dostajecie b³±d</a>
<q lang="en">/usr/lib/libc.so.1: bad ELF interpreter: No such file or directory</q>,
 to utwórzcie w katalogu /usr/lib (jako root) plik libc.so.1 jako dowi±zanie symboliczne do libc.so
 i upewnijcie siê, ¿e plik /usr/lib/libc.so ma
 prawa <span class="b">wykonywania dla wszystkich</span>.</P>

<P>
Je¶li system nie widzi biblioteki wspó³dzielonej (a nie chcecie jej pakowaæ do globalnych katalogów
 jak /lib czy /usr/lib), nale¿y ustawiæ dodatkow± ¶cie¿kê ich poszukiwania.<br>
Ustawcie sobie zmienn± ¶rodowiskow± LD_LIBRARY_PATH tak, by zawiera³a ¶cie¿ki do Waszych
 bibliotek. Ja u siebie mam ustawion± <code>LD_LIBRARY_PATH=$HOME:.</code>&nbsp;, co oznacza, ¿e
 poza domy¶lnymi katalogami, ma byæ przeszukany tak¿e mój katalog domowy oraz katalog bie¿±cy
 (ta kropka po dwukropku), jakikolwiek by nie by³.</P>



<HR>
<h2 class="nag">£adowanie bibliotek w czasie pracy programu</h2>
<P>
Gdy nasz program jest na sztywno (statycznie lub nie) ³±czony z jak±¶ bibliotek± wspó³dzielon±,
 to w trakcie jego uruchamiania system szuka pliku tej biblioteki, aby móc uruchomiæ nasz program.
 Je¶li system nie znajdzie biblioteki, to nawet nie uruchomi naszego programu. Czasem jednak
 chcemy mieæ mo¿liwo¶æ zareagowania na taki problem. Oczywi¶cie, bez kluczowych bibliotek
 nie ma szans uruchomiæ programu, ale ca³± resztê mo¿na do¶æ ³atwo ³adowaæ w czasie dzia³ania
 programu. Daje to pewne korzy¶ci:</P>
<ol>
 <li>oszczêdza pamiêæ - ³adujemy tylko te biblioteki, których nam naprawdê potrzeba, a tu¿ po
 	zakoñczeniu pracy z bibliotek±, mo¿na zwolniæ pamiêæ przez ni± zajmowan±.</li>
 <li>daje mo¿liwo¶æ reagowania na brak biblioteki - na przyk³ad mo¿na wy¶wietliæ komunikat, ¿e
 	niektóre funkcje programu bêd± niedostêpne. Ale program mo¿e nadal dzia³aæ i
 	wykonaæ swoje zadanie.</li>
</ol>
<P>£adowanie bibliotek w czasie pracy programu polega na wykorzystaniu funkcji z
 biblioteki <span class="b">libdl</span>. Konkretnie, u¿yjemy trzech funkcji:</P>
<ol>
 <li>dlopen - otwiera i ³aduje bibliotekê
 	<P>Przyjmuje ona dwa argumenty. Od lewej (ostatni wk³adany na stos) s± to: nazwa pliku
 	biblioteki wspó³dzielonej (razem ze ¶cie¿k±, je¶li jest w niestandardowej) oraz jedna
 	z liczb: RTLD_LAZY (warto¶æ 1), RTLD_NOW (warto¶æ 2), RTLD_GLOBAL (warto¶æ 100h).
 	Okre¶laj± one sposób dostêpu do funkcji w bibliotece, odpowiednio s± to:</P>
 	<ul>
 	 <li> RTLD_LAZY - znajduj adres funkcji w chwili jej wywo³ania.</li>
 	 <li> RTLD_NOW - znajduj adres funkcji od razu, w czasie ³adowania biblioteki</li>
 	 <li> RTLD_GLOBAL - symbole biblioteki (nazwy funkcji) bêd± od razu widoczne dla programu
 	 	tak, jakby biblioteka by³a w³±czona na sta³e do programu.</li>
 	</ul>
 	<P>Funkcja dlopen zwraca (w EAX) adres za³adowanej biblioteki, którego bêdziemy potem u¿ywaæ.
 	</P></li>

 <li>dlsym - wy³awia z biblioteki adres interesuj±cej nas funkcji
 	<P>Ta funkcja te¿ przyjmuje dwa argumenty. Od lewej (ostatni wk³adany na stos) s± to:
 	adres biblioteki, który otrzymali¶my od funkcji dlopen oraz nazwa funkcji, która nas
 	interesuje <em class="wazne">jako ³añcuch znaków</em>.<br>
 	Funkcja dlsym zwraca nam (w EAX) adres ¿±danej funkcji.
 	</P></li>

 <li>dlclose - zamyka za³adowan± bibliotekê
 	<P>Jedynym argumentem tej funkcji jest adres biblioteki, który otrzymali¶my od funkcji dlopen.
 	</P></li>
</ol>
<P>Jest te¿ funkcja systemowa sys_uselib, ale jej dokumentacja jest skromna. W u¿yciu pewnie by³aby
 trudniejsza ni¿ libdl.</P>
<P>
Pora na przyk³adowy program. Jego zadaniem bêdzie za³adowaæ bibliotekê biblso.so.1, któr±
 utworzyli¶my w poprzednim podrozdziale, oraz uruchomienie jej jedynej funkcji - info. Oto kod
 w sk³adnie NASM:</P>

	<BR><a href="#bibl_tut_linux04" class="bezdruk">(przeskocz program ³aduj±cy bibliotekê)</a>
<pre title="program ³aduj±cy bibliotekê">
; Program korzystaj±cy z biblioteki wspó³dzielonej tak, ¿e
;	nie musi byæ z ni± ³±czony
;
; Autor: Bogdan D., bogdandr (na) op . pl
;
; kompilacja:
;   nasm -f elf -o shartest.o shartest.asm
;   gcc -s -o shartest shartest.o -ldl

section .text

; bêdziemy korzystaæ z biblioteki jêzyka C, wiêc nasza funkcja
;  g³ówna musi siê nazywaæ &nbsp;<q lang="en">main</q>
global main

%define RTLD_LAZY	0x00001	; znajduj adres funkcji w chwili wywo³ania
%define RTLD_NOW	0x00002	; znajduj adres funkcji od razu, w czasie
				; ³adowania biblioteki
%define RTLD_GLOBAL	0x00100	; czy symbole bêd± od razu widoczne

extern dlopen
extern dlsym
extern dlclose

main:

	push	dword RTLD_LAZY	; ³adowanie na ¿±danie
	push	dword bibl	; adres nazwy pliku
	call	dlopen		; otwieramy bibliotekê
	add	esp, 2*4	; zwalniamy argumenty ze stosu

	test	eax, eax	; sprawdzamy, czy nie b³±d (EAX=0)
	jz	.koniec

	mov	[uchwyt], eax	; zachowujemy adres biblioteki

	push	dword funkcja	; adres nazwy ¿±danej funkcji
	push	dword [uchwyt]	; adres biblioteki
	call	dlsym		; szukamy adresu
	add	esp, 2*4

	mov	[adr_fun], eax	; EAX = znaleziony adres
	call	eax		; uruchomienie bezpo¶rednie
	call	[adr_fun]	; uruchomienie po¶rednie

	push	dword [uchwyt]	; adres biblioteki
	call	dlclose		; zwalniamy j± z pamiêci
	add	esp, 1*4

.koniec:
	ret			; zakoñczenie funkcji main

section .data

bibl		db	"biblso.so.1", 0	; nazwa biblioteki
funkcja		db	"info", 0		; nazwa szukanej funkcji
uchwyt		dd	0
adr_fun		dd	0</pre>

<P><a name="bibl_tut_linux04" id="bibl_tut_linux04">Muszê wspomnieæ</a> o dwóch do¶æ wa¿nych rzeczach.<br>
Pierwsz± jest sposób kompilacji. Skoro ³±czymy nasz program z bibliotek± C, to nasza
 funkcja g³ówna musi siê teraz nazywaæ <span lang="en">main</span>, a <em class="wazne">NIE</em> _start
 (gdy¿ funkcja _start ju¿ jest w bibliotece jêzyka C). Kompilacja wygl±da teraz tak, jak
 napisa³em w programie:</P>
<pre>
nasm -f elf -o shartest.o shartest.asm
gcc -s -o shartest shartest.o -ldl</pre>
<P>W tym przypadku kompilator GCC uruchamia za nas linker LD, który do³±czy niezbêdne biblioteki.
</P>
<P>
Drug± rzecz± jest domy¶lna ¶cie¿ka poszukiwania bibliotek wspó³dzielonych. Je¶li nie chcecie
 za¶miecaæ systemu (lub nie macie uprawnieñ), pakuj±c swoje biblioteki do /lib czy /usr/lib,
 ustawcie sobie zmienn± ¶rodowiskow± LD_LIBRARY_PATH tak, by zawiera³a ¶cie¿ki do Waszych
 bibliotek. Ja u siebie mam ustawion± <code>LD_LIBRARY_PATH=$HOME:.</code>&nbsp;, co oznacza, ¿e
 poza domy¶lnymi katalogami, ma byæ przeszukany tak¿e mój katalog domowy oraz katalog bie¿±cy
 (ta kropka po dwukropku), jakikolwiek by nie by³.</P>




<br><br>
<div class="bezdruk">
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

</BODY></HTML>
