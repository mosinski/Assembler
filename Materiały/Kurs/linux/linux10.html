<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks, czê¶æ 10 - Inne jêzyki a asembler </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Prev"     hreflang="pl" lang="en" href="linux09.html" >
<link rel="Next"     hreflang="pl" lang="en" href="linux11.html" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="kurs, asm, asembler, assembler, wstawki asemblerowe, C, Pascal
	Fortran, gcc, linux, linuks">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Tue, Jan 18 2011 17:59:58 CEST">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler pod Linuksem?<BR>
	<h1 class="nag">Czê¶æ 10 - Nie jeste¶my sami, czyli jak ³±czyæ asemblera z innymi jêzykami</h1>
	</div>

<P>
Jak wiemy, w asemblerze mo¿na napisaæ wszystko. Jednak nie zawsze wszystko trzeba pisaæ w
tym jêzyku. W tej czê¶ci poka¿ê, jak asemblera ³±czyæ z innymi jêzykami. S± na to 2 sposoby:</P>
<UL>
 <LI>Wstawki asemblerowe wpisywane bezpo¶rednio w kod programu</LI>
 <LI>Osobne modu³y asemblerowe do³±czane potem do modu³ów napisanych w innych jêzykach</LI>
</UL>
<P>Postaram siê z grubsza omówiæ te dwa sposoby na przyk³adzie jêzyków
 <span lang="en">Pascal</span>, C i Fortran 77.
Uprzedzam jednak, ¿e moja znajomo¶æ jêzyka <span lang="en">Pascal</span> i narzêdzi
 zwi±zanych z tym jêzykiem jest s³aba.</P>





<BR>
<HR>
<h2 class="nag" lang="en">Pascal</h2>

	<BR><a href="#c" tabindex="1" class="bezdruk">(przeskocz <span lang="en">Pascal</span>a)</a>
<P>
Wstawki asemblerowe realizuje siê u¿ywaj±c s³owa <q>asm</q>. Oto przyk³ad:</P>
<PRE title="wstawka asemblerowa w Pascalu">
	{ Linux u¿ywa sk³adni AT&amp;T do asemblera - jak zauwa¿ycie,
	 argumenty instrukcji s± odwrócone. }

	program pas1;

	begin
 	 asm movl $4,%eax
 	 end;
	end.</PRE>

<P>Mo¿na te¿ stosowaæ nieco inny sposób - deklarowanie zmiennej reprezentuj±cej rejestry procesora.
Poni¿szy wycinek kodu prezentuje to w³a¶nie podej¶cie (wywo³uje przerwanie 13h z AH=48h, DL=80h,
 DS:DX wskazuj±cym na obiekt a):</P>
<PRE title="Pascal a rejestry" lang="en">
	uses crt,dos;

	Var
	   regs: Registers;

	BEGIN
	   clrscr();
	   With regs DO
	     Begin
	       Ah:=$48;
	       DL:=$80;
	       DS:=seg(a);
	       DX:=ofs(a);
	     End;

	       Intr($13,regs);</PRE>

<P>Teraz zajmiemy siê bardziej skomplikowan± spraw± - ³±czenie modu³ów napisanych w
<span lang="en">Pascal</span>u i
asemblerze. Pascal dekoruje nazwy zmiennych i procedur, dorabiaj±c znak podkre¶lenia
 z przodu. Jakby tego
by³o ma³o, do nazwy procedury dopisywana jest informacja o jej parametrach. Tak wiêc z kodu</P>
<PRE>
	var
 	 c:integer;
 	 d:char;

	procedure aaa(a:integer;b:char);</PRE>

<P>otrzymujemy symbole: _C, _D oraz _AAA$INTEGER$CHAR.</P>

<P>Oprócz tego, zwykle w <span lang="en">Pascal</span>u
 argumenty na stos sz³y od lewej do prawej, ale z tego co widzê
teraz, to <span lang="en">Free Pascal Compiler</span> dzia³a odwrotnie
 - argumenty id± na stos wspak. W naszym
przyk³adzie najpierw na stos pójdzie zmienna typu <q lang="en">char</q>, a potem typu
 <q lang="en">integer</q> (obie
rozszerzone do rozmiaru DWORDa).</P>
<P>
Jedno jest pewne: je¿eli Twoja procedura jest uruchamiana z programu napisanego w
 <span lang="en">Pascal</span>u, to
Ty <q>sprz±tasz po sobie</q> stos - nale¿y przy wyj¶ciu z procedury wykonaæ &nbsp;
 <code>RET liczba</code>, gdzie
liczba to rozmiar wszystkich parametrów w³o¿onych na stos (wszystkie parametry s± rozmiaru co
najmniej DWORD).<BR>
Je¶li to Ty uruchamiasz procedury napisane w <span lang="en">Pascal</span>u, to nie musisz
 siê martwiæ o zdejmowanie parametrów ze stosu.
</P>
<P>
Samo do³±czanie modu³ów odbywa siê na linii poleceñ, najlepiej w tym celu u¿yæ linkera
(po uprzednim skompilowaniu innych modu³ów na pliki obiektowe).</P>












<HR><BR><BR>
<h2 class="nag"><a name="c" id="c">C i C++</a></h2>
	<BR><a href="#fortran" class="bezdruk">(przeskocz C i C++)</a>
<P>

Wstawki asemblerowe zaczynaj± siê s³owami <q>__asm (</q> a koñcz± nawiasem zamykaj±cym <q>)</q>.
W Linuksie wygl±daj± one nieco dziwnie i to nie tylko ze wzglêdu na <q>odwrotn±</q> sk³adniê</P>
 <span lang="en">AT&amp;T</span>:
<PRE title="wstawka asemblerowa w C">
        __asm (&quot;movl $4,%eax\n&quot;
                &quot;movb $0xff,%bl\n&quot;);</PRE>

<P>Jak widaæ, po ka¿dej instrukcji trzeba daæ znak przej¶cia do nowej linii (w jednej linii mo¿e
byæ tylko 1 instrukcja asemblera). Mo¿na dorzuciæ te¿ znak tabulacji <q>\t</q>.</P>
<P>Wygl±d bloków <q>__asm</q> jest z³o¿ony. Po szczegó³y odsy³am do stron przeznaczonych temu
zagadnieniu. W szczególno¶ci, mo¿ecie poczytaæ <a hreflang="en"
 href="http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/">podrêcznik GCC</a> (sekcje: 5.34 i 5.35),
<A HREF="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html" hreflang="en"
	>strony DJGPP</A> oraz (w jêzyku polskim)
<A HREF="http://www.cs.put.poznan.pl/adanilecki/inline_asm/index.php" hreflang="pl"
	>stronê pana Danileckiego</A>.</P>
<P>U siebie te¿ mam <A HREF="../linux/attintel.html" hreflang="pl">krótkie porównanie</A> tych sk³adni.</P>


<P>
W C i C++ mo¿na, podobnie jak w <span lang="en">Pascal</span>u,
 deklarowaæ zmienne reprezentuj±ce rejestry procesora.
Plik nag³ówkowy BIOS.H (niestety tylko w <span lang="en">Windows</span>)
 oferuje nam kilka mo¿liwo¶ci. Oto przyk³ad:</P>
<PRE>
	#include &lt;bios.h&gt;
	...

	REGS rejestry;
	...
		rejestry.x.ax = 0x13;
		rejestry.h.bl = 0xFF;
		int86 (0x10, rejestry, rejestry);</PRE>

<P>£±czenie modu³ów jest prostsze ni¿ w <span lang="en">Pascal</span>u.
 Jêzyk zwykle C dekoruje nazwy, dodaj±c znak podkre¶lenia z przodu,
ale nie w Linuksie, gdzie po prostu nic nie jest dorabiane.<BR>
W Linuksie deklaracja funkcji zewnêtrznej wygl±da po prostu tak:</P>
<PRE><span lang="en">extern void</span> naszafunkcja (int parametr, <span lang="en">char</span>* parametr2);</PRE>

<P><em class="wazne">UWAGA</em> - w jêzyku C++ sprawy s± trudniejsze nawet ni¿ w
 <span lang="en">Pascal</span>u. Dlatego, je¶li chcemy, aby
nazwa naszej funkcji by³a niezmieniona (poza tym, ¿e ewentualnie dodamy podkre¶lenie z przodu)
i jednocze¶nie dzia³a³a w C++, zawsze przy deklaracji funkcji w pliku nag³ówkowym, nale¿y dodaæ
&nbsp;<CODE>extern &quot;C&quot;</CODE>, na przyk³ad</P>

<PRE title="opakowanie funkcji dla C++">
	#ifdef __cplusplus
	extern &quot;C&quot; {
	#endif

	extern void naszafunkcja (int parametr, char* a);

	#ifdef  __cplusplus
	}
	#endif</PRE>

<P>W systemach 32-bitowych parametry przekazywane s± <em class="wazne">OD PRAWEJ DO LEWEJ</em>, czyli
 pierwszy parametr (u nas powy¿ej: int)
bêdzie w³o¿ony na stos jako ostatni, czyli bêdzie <q>najp³ycej</q>, a ostatni
 (u nas: <span lang="en">char</span>*)
bêdzie <q>najg³êbiej</q>.</P>
<P>
W systemach 64-bitowych sprawa wygl±da trudniej: parametry, w zale¿no¶ci od klasy, s± przekazywane
(od LEWEJ do PRAWEJ):</P>
<ul>
<li>na stosie, je¶li ich rozmiar przekracza 8 bajtów lub zawiera pola niewyrównane co do adresu</li>
<li>kolejno w rejestrach RDI, RSI, RDX, RCX, R8, R9, je¶li jest klasy ca³kowitej (mie¶ci siê w
 rejestrze ogólnego przeznaczenia)</li>
<li>kolejno w rejestrach XMM0 ... XMM7 lub ich górnych czê¶ciach, je¶li jest klasy SSE lub
 SSEUP, odpowiednio</li>
<li>w obszarze pamiêci, je¶li jest klasy zmiennoprzecinkowej/zespolonej</li>
</ul>
<P>W C/C++ to funkcja <em class="wazne">uruchamiaj±ca</em> zdejmuje w³o¿one parametry ze stosu,
 a <em class="wazne">NIE</em> funkcja uruchamiana.</P>
<P>
Na systemach 32-bitowych parametry ca³kowitoliczbowe do 32 bitów zwracane s± w
 rejestrze EAX (lub jego czê¶ciach:
 AL, AX, w zale¿no¶ci od rozmiaru), 64-bitowe w EDX:EAX,
 zmiennoprzecinkowe w ST0. Wska¼niki
 w 32-bitowych kompilatorach s± 32-bitowe i s± zwracane w EAX (w 16-bitowych zapewne w AX).<br>
Struktury s± wk³adane na stos od ostatnich pól, a je¶li funkcja zwraca strukturê przez warto¶æ, na przyk³ad<br>
<code>struct xxx f ( struct xxx a )</code><br>
to tak naprawdê jest traktowana jak taka funkcja:<br>
<code>void f ( struct xxx *tu_bedzie_wynik, struct xxx a )</code><br>
czyli jako ostatni na stos wk³adany jest adres struktury, do której ta funkcja ma w³o¿yæ
strukturê wynikow±.
</P>
<P>
Na systemach 64-bitowych sprawa ponownie wygl±da inaczej. Tu tak¿e klasyfikuje siê
typ zwracanych danych, które s± wtedy przekazywane:</P>
<ul>
<li>w pamiêci, której adres przekazano w RDI (tak, jakby by³ to pierwszy parametr) - tak
 na przyk³ad mo¿na zwracaæ struktury. Po powrocie, RAX bêdzie zawiera³ przekazany adres</li>
<li>w kolejnym wolnym rejestrze z grupy RAX, RDX, je¶li klasa jest ca³kowita</li>
<li>w kolejnym wolnym rejestrze z grupy XMM0, XMM1, je¶li klasa to SSE</li>
<li>w górnej czê¶ci ostatniego u¿ywanego rejestru SSE, je¶li klasa to SSEUP</li>
<li>w ST0, je¶li klasa jest zmiennoprzecinkowa</li>
<li>razem z poprzedni± warto¶ci± w ST0, je¶li klasa to X87UP</li>
<li>czê¶æ rzeczywista w ST0, a czê¶æ urojona w ST1, je¶li klasa jest zespolona</li>
</ul>
<P>Polecam do przeczytania x64 <acronym lang="en" title="Application Binary Interface"
>ABI</acronym> (na przyk³ad dokument x64-abi.pdf, do znalezienia w Internecie).</P>


<P>
Do³±czanie modu³ów (te napisane w asemblerze musz± byæ uprzednio skompilowane)
odbywa siê na linii poleceñ, z tym ¿e tym razem mo¿emy u¿yæ samego
kompilatora (GCC), aby wykona³ za nas ³±czenie (nie musimy uruchamiaæ linkera LD).
</P>
<P>
Teraz krótki 32-bitowy przyk³adzik (u¿yjê NASMa i GCC):</P>
<PRE title="przyk³ad asm+C">
	; NASM - casm1l.asm

	; use32 nie jest potrzebne w Linuksie, ale te¿ nie zaszkodzi
	section .text use32

	global	suma

	suma:

	; po wykonaniu push ebp i mov ebp, esp:
	; w [ebp]    znajduje siê stary EBP
	; w [ebp+4]  znajduje siê adres powrotny z procedury
	; w [ebp+8]  znajduje siê pierwszy parametr,
	; w [ebp+12] znajduje siê drugi parametr
	; itd.

	%idefine	a	[ebp+8]
	%idefine	b	[ebp+12]

		push	ebp
		mov	ebp, esp

		mov	eax, a
		add	eax, b

	; LEAVE = mov esp, ebp / pop ebp
		leave
		ret</PRE>

<P>I jeszcze plik casml.c:</P>
<PRE>
	#include &lt;stdio.h&gt;

	extern int suma (int a, int b);

	int c=1, d=2;

	int main()
	{
		printf(&quot;%d\n&quot;, suma(c,d));
		return 0;
	}</PRE>

<P>Kompilacja wygl±da tak:</P>
<PRE>
	nasm -f elf casm1l.asm
	gcc -o casm casml.c casm1l.o</PRE>

<P>Po uruchomieniu programu na ekranie pojawia siê oczekiwana cyfra 3.</P>

<P>
Mo¿e siê zdarzyæ te¿, ¿e chcemy tylko korzystaæ z funkcji jêzyka C, ale g³ówn± czê¶æ
 programu chcemy napisaæ w asemblerze. Nic trudnego: u¿ywane funkcje deklarujemy jako
 zewnêtrzne, ale
 <em class="wazne">uwaga - swoj± funkcjê g³ówn± musimy nazwaæ <q lang="en">main</q></em>.
 Jest tak dlatego, ¿e teraz punkt startu programu nie jest w naszym kodzie, lecz w
 samej bibliotece jêzyka C. Program zaczyna siê miêdzy innymi ustawieniem tablic
 argumentów listy poleceñ i zmiennych ¶rodowiska. Dopiero po tych operacjach biblioteka
 C uruchamia funkcjê <q lang="en">main</q> instrukcj± <span lang="en">CALL</span>.<br>
</P>
<P>Inn± wa¿n± spraw± jest to, ¿e nasz± funkcjê g³ówn± powinni¶my zakoñczyæ instrukcj± RET
 (zamiast normalnych instrukcji wyj¶cia z programu), która
 pozwoli przekazaæ kontrolê z powrotem do biblioteki C, umo¿liwiaj±c posprz±tanie
 (na przyk³ad wyrzucenie buforów z wy¶wietlonymi informacjami w koñcu na ekran).<br>
Krótki (tak¿e 32-bitowy) przyk³adzik:</P>
<pre>
	section .text

	global main

	extern printf

	main:

		; printf("Liczba jeden to: %d\n", 1);
		push	dword 1		; drugi argument
		push	dword napis	; pierwszy argument
		call	printf		; uruchomienie funkcji
		add	esp, 2*4	; posprz±tanie stosu

		; return 0;
		xor	eax, eax
		ret			; wyj¶cie z programu

	section .data

	napis: db "Liczba jeden to: %d", 10, 0</pre>

<P>Kompilacja powinna odbyæ siê tak:</P>
<PRE>
	nasm -o casm2.o -f elf casm2.asm
	gcc -o casm2 casm2.o</PRE>

<P>Jedna uwaga: funkcje biblioteki C mog± zamazaæ nam zawarto¶æ wszystkich rejestrów
 (poza EBX, EBP, ESI, EDI w systemach 32-bitowych, i RBX, RBP, R12, R13, R14, R15 na
 systemach 64-bitowych), wiêc <em class="wazne">nie wolno nam polegaæ na zawarto¶ci rejestrów</em>
 po uruchomieniu jakiejkolwiek funkcji C.</P>










<HR><BR><BR>
<h2 class="nag"> <a name="fortran" id="fortran">Fortran 77</a></h2>

<P>
W tym jêzyku nie wiem nic o wstawkach asemblerowych, wiêc przejdziemy od razu do ³±czenia
modu³ów.</P>
<P>Fortran dekoruje nazwy, stawiaj±c znak podkre¶lenia <em class="wazne">PO</em>
 nazwie funkcji lub zmiennej (wyj±tkiem jest funkcja
g³ówna - blok PROGRAM - która nazywa siê <CODE>MAIN__</CODE>, z dwoma podkre¶leniami).</P>
<P>
Nie musimy pisaæ externów, ale jest kilka regu³ przekazywania parametrów:</P>
<UL>
 <LI>parametry przekazywane s± od prawej do lewej, czyli tak jak w C.</LI>
 <LI>je¶li to jest tylko mo¿liwe, wszystkie parametry przekazywane s± przez referencjê, czyli
	przez wska¼nik. Gdy to jest niemo¿liwe, przekazywane s± przez warto¶æ.</LI>
 <LI>je¶li na li¶cie parametrów pojawia siê ³añcuch znakowy (lub inna tablica), to na stosie przed innymi
	parametrami umieszczana jest jego d³ugo¶æ (lub wymiary podawane wspak -
	od ostatniego do pierwszego - w przypadku tablic wielowymiarowych).</LI>
 <LI>wyniki s± zwracane w tych samych miejscach, co w jêzyku C.</LI>
</UL>
<P>Na przyk³ad, nastêpuj±cy kod:</P>
<PRE title="przyk³adowy kod Fortrana">
        REAL FUNCTION aaa (a, b, c, i)

                CHARACTER a*(*)
                CHARACTER b*(*)
                REAL c
                INTEGER i

                aaa = c
        END

[...]
                CHARACTER x*8
                CHARACTER y*5
                REAL z,t
                INTEGER u

                t=aaa (x, y, z, u)
[...]</PRE>

<P>bêdzie przet³umaczony na asemblera tak (samo uruchomienie funkcji):</P>
<PRE title="powy¿szy kod w asemblerze">
	push	5
	push	8
	push	u_	; adres, czyli offset zmiennej &quot;u&quot;
	push	z_
	push	y_
	push	x_

	call	aaa_</PRE>

<P>(to niekoniecznie musi wygl±daæ tak ³adnie, gdy¿ zmienne <q>x</q>, <q>y</q>, <q>u</q> i <q>z</q>
 s± lokalne w funkcji MAIN__, czyli s± na stosie, wiêc ich adresy mog± wygl±daæ jak
 [ebp-28h] lub podobnie).</P>
<P>
Funkcja uruchamiaj±ca sprz±ta stos po uruchomieniu (podobnie jak w C).</P>
<P>
Do³±czaæ modu³y mo¿na bezpo¶rednio z linii poleceñ (w ka¿dym razie kompilatorem F77/G77).</P>
<P>
Podam teraz przyk³ad ³±czenia Fortrana 77 i asemblera (u¿yjê NASMa i F77):</P>
<PRE title="kod assmelbera wykorzystany w Fortranie">
	; NASM - asm1fl.asm

	section .text use32

	global	suma_

	suma_:

	; po wykonaniu push ebp i mov ebp, esp:
	; w [ebp]    znajduje siê stary EBP
	; w [ebp+4]  znajduje siê adres powrotny z procedury
	; w [ebp+8]  znajduje siê pierwszy parametr,
	; w [ebp+12] znajduje siê drugi parametr
	; itd.

	%idefine	a	[ebp+8]
	%idefine	b	[ebp+12]

		push	ebp
		mov	ebp, esp

	; przypominam, ¿e nasze parametry s± w rzeczywisto¶ci
	; wska¼nikami do prawdziwych parametrów

		mov	edx, a		; EDX = adres pierwszego parametru
		mov	eax, [edx]	; EAX = pierwszy parametr
		mov	edx, b
		add	eax, [edx]

	; LEAVE = mov esp, ebp / pop ebp
		leave
		ret</PRE>

<P>I teraz plik asmfl.f:</P>
<PRE title="kod Fortrana korzystaj±cy z powy¿szego">
	PROGRAM funkcja_zewnetrzna

	INTEGER a,b,suma

	a=1
	b=2

	WRITE (*,*) suma(a,b)

	END</PRE>

<P>Po skompilowaniu:</P>
<PRE>
	nasm -f elf asm1fl.asm
	g77 -o asmfl asmfl.f asm1fl.o</PRE>

<P>i uruchomieniu, na ekranie ponownie pojawia siê cyfra 3.</P>





<BR><HR>
<P class="b">
Informacji podanych w tym dokumencie <em class="wazne">NIE</em>
 nale¿y traktowaæ jako <q>uniwersalnych, jedynie
s³usznych regu³ dzia³aj±cych w ka¿dej sytuacji</q>. Aby uzyskaæ kompletne informacje, nale¿y
zapoznaæ siê z dokumentacj± posiadanego kompilatora.
</P>


<br><br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="linux09.html">Poprzednia czê¶æ kursu</a> (Alt+3)<br>
<a accesskey="4" hreflang="pl" href="linux11.html">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>


<BR><BR><HR>
<h2 class="nag">Æwiczenia</h2>
<OL>
 <LI>Napisz plik asemblera, zawieraj±cy funkcjê obliczania reszty z dzielenia dwóch liczb
	ca³kowitych. Nastêpnie, po³±cz ten plik z programem napisanym w dowolnym innym jêzyku
	(najlepiej w C/C++, gdy¿ jest najpopularniejszy) w taki sposób, by Twoj± funkcjê mo¿na
	by³o uruchamiaæ z tamtego programu. Je¶li planujesz ³±czyæ asemblera z C, upewnij siê
	¿e Twoja funkcja dzia³a równie¿ z programami napisanymi w C++.</LI>
</OL>

</BODY></HTML>
