<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks, czê¶æ 9 - Narzêdzia </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Prev"     hreflang="pl" lang="en" href="linux08.html" >
<link rel="Next"     hreflang="pl" lang="en" href="linux10.html" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="linux, linuks, kurs, asm, asembler, assembler, debugger,
	debuger, debug, gdb, Private ICE, make">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Mon, Feb 21 2011 16:00:56 CEST">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler pod Linuksem?<BR>
	<h1 class="nag">Czê¶æ 9 - Narzêdzia programisty, czyli co mo¿e nam pomagaæ w programowaniu</h1>
	</div>

<HR>
<h2 class="nag">Debugery</h2>

	<BR><a href="#ide" tabindex="1" class="bezdruk">(przeskocz debugery)</a>
<P>
Wszystkim siê mo¿e zdarzyæ, ¿e nieustanne, wielogodzinne gapienie siê w kod programu nic nie
daje i program ci±gle nie chce nam dzia³aæ. Wtedy z pomoc± przychodz± debugery. W tej czê¶ci
zaprezentujê kilka wartych uwagi programów tego typu.
</P>

<P>
Debugery programów Linuksowych:</P>
<OL>
 <LI>GDB, czyli Gnu Debugger + nak³adki, na przyk³ad DDD
	<P>Podstawowy debuger pracuj±cy w trybie tekstowym (nak³adka DDD - w graficznym).
	Sk³adnia podstawowa to <span lang="en">AT&amp;T</span>
	(odwrotna do zwyk³ej sk³adni Intela), podobnie jak w Gnu as i GCC.<BR>
	Aby u¿ywaæ GDB, nasz program musimy skompilowaæ <em class="wazne">BEZ opcji
	<code>-s</code></em> u linkera (aby zosta³y
	zachowane symbole).</P>

	<P>Krótki kurs obs³ugi:</P>
	<ul>
	<li>Uruchomienie jest proste - wystarczy <code>gdb naszprog</code>.</li>
	<li>Aby gdb stan±³ na wybranej funkcji, nale¿y wpisaæ <code>break nazwa_funkcji</code>.
	To powinno ustawiæ pu³apkê (<span lang="en">breakpoint</span>) na pierwszej instrukcji
	tej funkcji.
	Nie zawsze jednak breakpoint dzia³a na procedurze pocz±tkowej _start - wtedy tu¿ po
	<code>_start:</code> (w naszym programie) nale¿y
	wstawiæ instrukcjê <code>nop</code> i tu¿ po niej postawiæ
	etykietê, na której ju¿ bez problemów ustawimy dzia³aj±cy breakpoint.</li>
	<li>Aby zdisasemblowaæ konkretn± funkcjê, piszemy <code>disassemble nazwa_funkcji</code>.
	Zostanie wy¶wietlony kod podanej funkcji do najbli¿szej etykiety.
	Je¶li wolimy sk³adniê Intela, piszemy <code>set disassembly-flavor intel</code>.
	Je¶li nie, to <code>set disassembly-flavor att</code>.</li>
	<li>Aby wy¶wietliæ rejestry, piszemy <code>info r</code>, aby wy¶wietliæ
	konkretny rejestr, piszemy na przyk³ad <code>print /x $eax</code>.</li>
	<li>Aby zmieniæ warto¶æ rejestru, piszemy na przyk³ad <code>set $ebx=33</code>.</li>
	<li>Aby wy¶wietliæ rejestry koprocesora, piszemy <code>info float</code>.</li>
	<li>Aby wy¶wietliæ zawarto¶æ pamiêci, piszemy na przyk³ad <code>x 0x08048081</code>
	lub <code>print /x zmienna</code>.
	Aby wy¶wietliæ wiêcej ni¿ jedno 32-bitowe s³owo, dajemy liczbê s³ów po uko¶niku
	po komendzie <code>x</code>, na przyk³ad <code>x/8 0x08048081</code>.
	Zamiast adresu mo¿na podaæ etykietê.</li>
	<li>Aby zmieniæ warto¶æ zmiennej w pamiêci, u¿ywamy na przyk³ad
	<code>set variable var1 = 0x1</code> lub
	<code>set variable *0x8049094 = 0x2</code>, je¶li znamy tylko adres.</li>
	<li>Aby pobraæ adres zmiennej, u¿ywamy na przyk³ad <code>print /x &amp;var1</code>.</li>
	<li>Listê zdefiniowanych funkcji dostajemy po <code>info functions</code>.</li>
	<li>Bie¿±cy stos wywo³añ mo¿na otrzymaæ komend± <code>info stack</code>.</li>
	<li>Aby przej¶æ o 1 instrukcjê dalej, piszemy <code>stepi</code>.</li>
	<li>Pomoc mo¿emy wy¶wietliæ, wpisuj±c <code>help</code>.</li>
	</ul>
	<br>
  </LI>

 <LI><span lang="en">Private ICE - PICE</span>
	<P>Ze zrzutów ekranowych na jego stronie domowej
	(<A HREF="http://pice.sourceforge.net/" hreflang="en">pice.sf.net</A>)
	 wygl±da ca³kiem obiecuj±co. Poza tym, jest to
	<span lang="en">system-level debugger</span>,
	 czyli mo¿e on wnikaæ w zakamarki systemu. Szczegó³ów obs³ugi
	równie¿ niestety nie znam, gdy¿ kompilacja wymaga zabawy z kodem i posiadania ¼róde³ j±dra.
  </P></LI>

 <li><a href="http://bochs.sourceforge.net/" hreflang="en">Bochs</a>
	<P>
	Jest to emulator procesora, przydatny zw³aszcza w pisaniu i testowaniu bootsektorów i
	miniaturowych systemów operacyjnych, ale nie tylko. Posiada
	<a href="http://bochs.sourceforge.net/doc/docbook/user/internal-debugger.html"
	hreflang="en">wbudowany debuger</a>, dziêki któremu mo¿na debugowaæ programy w
	takich ¶rodowiskach, w których nie da siê uruchomiæ tradycyjnego debugera (na przyk³ad
	w³a¶nie w czasie bootowania systemu).
	</P>
 </LI>

 <li><a href="http://www.valgrind.org/" hreflang="en">Valgrind</a>
	<P>Mo¿e nie do koñca jest to debuger, ale narzêdzie do analizy pamiêci. Pozwala wykryæ
	miêdzy innymi wycieki pamiêci, miejsca spowalniaj±ce program oraz poprawiæ
	wydajno¶æ pamiêci podrêcznej.</P>
 </li>

</OL>


<P>
Wiem, ¿e nie wszyscy od razu z entuzjazmem rzuc± siê do ¶ci±gania i testowania przedstawionych
wy¿ej programów i do debugowania w³asnych.<BR>
Niektórzy mog± uwa¿aæ, ¿e
odpluskwiacz nie jest im potrzebny. Mo¿e i tak byæ, ale nie zawsze i nie u wszystkich. Czasem
(zwykle po d³ugim sterczeniu przed ekranem) przychodzi chêæ do u¿ycia czego¶, co tak
bardzo mo¿e u³atwiæ nam wszystkim ¿ycie.<BR>
Pomy¶lcie, ¿e gdyby nie by³o debugerów, znajdowanie b³êdów w programie musieliby¶my pozostawiæ
naszej nie zawsze wyæwiczonej wyobra¼ni. Dlatego zachêcam Was do korzystania z programów tego
typu (tylko tych posiadanych legalnie, oczywi¶cie).
</P>
<P>
Warto jeszcze wspomnieæ o dwóch programach: strace i ltrace.
 Pozwalaj± one na ¶ledzenie, których funkcji systemowych i kiedy dany program u¿ywa.
 Je¶li co¶ Wam nie dzia³a, mo¿na spojrzeæ, na których wywo³aniach funkcji s± jakie¶ problemy.
 Uruchomienie jest proste: <CODE>strace ./waszprogram</CODE>
</P>







<HR>
<h2 class="nag"><a name="ide" id="ide">Edytory i disasemblery</a>/hex-edytory</h2>

	<BR><a href="#make" class="bezdruk">(przeskocz ten dzia³)</a>
<P>
Do pisania programów w asemblerze wystarczy najzwyklejszy edytor tekstu (Emacs, VI, Joe,
PICO, LPE, ...), ale je¶li nie podoba siê Wam ¿aden z edytorów, to mo¿ecie wej¶æ na stronê
<A HREF="http://www.thefreecountry.com/programming/editors.shtml" hreflang="en" lang="en"
><span lang="en">The Free Country.com</span> - edytory</A>, gdzie przedstawionych jest
wiele edytorów dla programistów. Mo¿e znajdziecie co¶ dla siebie.<BR>
Zawsze mo¿na te¿ przeszukaæ <A HREF="http://www.sf.net" hreflang="en" lang="en">SourceForge.net</A>
</P>
<P>
Kolejn± przydatn± rzecz± mo¿e okazaæ siê disasembler lub hex-edytor. Jest to program, który
podobnie jak debugger czyta plik i ewentualnie t³umaczy zawarte w nim bajty na instrukcje asemblera,
jednak bez mo¿liwo¶ci uruchomienia czytanego programu.<BR>
Disasemblery mog± byæ przydatne w wielu sytuacjach, na przyk³ad gdy chcemy modyfikowaæ pojedyncze
bajty po kompilacji programu, zobaczyæ adresy zmiennych, itp.<BR>
Oto 2 przyk³ady programów tego typu:</P>

<UL>
 <LI>Biew: <A HREF="http://biew.sourceforge.net/en/biew.html" hreflang="en"
	>biew.sf.net</A></LI>
 <LI>HTE: <A HREF="http://hte.sourceforge.net/" hreflang="en">hte.sf.net</A></LI>
</UL>

<P>I ponownie, je¶li nie spodoba siê Wam ¿aden z wymienionych, to mo¿ecie wej¶æ na stronê
<A HREF="http://www.thefreecountry.com/programming/disasemblers.shtml" hreflang="en" lang="en"
><span lang="en">The Free Country.com</span> - disasemblery</A> lub na
<A HREF="http://www.sf.net" hreflang="en" lang="en">SourceForge.net</A> aby poszukaæ w¶ród pokazanych
tam programów czego¶ dla siebie.
</P>







<HR>
<h2 class="nag"><a name="make" id="make">Programy typu <span lang="en">MAKE</span></a></h2>

<P>
Programy typu <span lang="en">MAKE</span> s³u¿± do automatyzacji budowania du¿ych i ma³ych projektów.
Taki program dzia³a do¶æ prosto: uruchamiamy go, a on szuka pliku o nazwie <q lang="en">Makefile</q> w
bie¿±cym katalogu i wykonuje komendy w nim zawarte. Teraz zajmiemy siê omówieniem podstaw
sk³adni pliku <q lang="en">Makefile</q>.</P>
<P>
W pliku takim s± zadania do wykonania. Nazwa zadania zaczyna siê w pierwszej kolumnie, koñczy
dwukropkiem. Po dwukropku s± podane nazwy zadañ (lub plików) , od wykonania których zale¿y wykonanie
tego zadania. W kolejnych wierszach s± komendy s³u¿±ce do wykonania danego zadania.<BR>
<em class="wazne">UWAGA:</em> komendy NIE MOG¡ zaczynaæ siê od pierwszej kolumny!
 Nale¿y je pisaæ je po jednym tabulatorze (ale nie wolno zamiast tabulatora stawiaæ o¶miu spacji).<BR>
Aby wykonaæ dane zadanie, wydajemy komendê <code><span lang="en">make</span> nazwa_zadania</code>.
 Je¶li nie podamy nazwy zadania
(co jest czêsto spotykane), wykonywane jest zadanie o nazwie <q lang="en">all</q> (wszystko).</P>

<P>A teraz krótki przyk³ad:</P>
	<BR><a href="#make1" class="bezdruk">(przeskocz przyk³ad)</a>
<PRE title="prosty Makefile">
all:	kompilacja linkowanie
	echo &quot;Wszystko zakonczone pomyslnie&quot;

kompilacja:
	nasm -O999 -f elf -o plik1.o plik1.asm
	nasm -O999 -f elf -o plik2.o plik2.asm
	nasm -O999 -f elf -o plik3.o plik3.asm

	fasm plik4.asm plik4.o
	fasm plik5.asm plik5.o
	fasm plik6.asm plik6.o

linkowanie:	plik1.o plik2.o plik3.o plik4.o plik5.o plik6.o
	ld -s -o wynik plik1.o plik2.o plik3.o plik4.o \
		 plik5.o plik6.o

help:
	echo &quot;Wpisz make bez argumentow&quot;</PRE>

<P><a name="make1" id="make1">Ale <span lang="en">MAKE</span> jest m±drzejszy</a>, ni¿ mo¿e siê to wydawaæ!<BR>
Mianowicie: je¶li stwierdzi, ¿e wynik     zosta³ stworzony PÓ¬NIEJ ni¿ pliki .o   podane w
linii zale¿no¶ci, to nie wykona bloku <q>linkowanie</q>, bo nie ma to sensu skoro program wynikowy
i tak jest aktualny. <span lang="en">MAKE</span> robi tylko to, co
trzeba. Oczywi¶cie, niezale¿nie od <q>wieku</q> plików .o  , dzia³ <q>kompilacja</q> i tak zostanie
wykonany (bo nie ma zale¿no¶ci, wiêc <span lang="en">MAKE</span> nie bêdzie sprawdza³ wieku plików).
</P>
<P>
Znak odwrotnego uko¶nika <q>\</q> powoduje zrozumienie, ¿e nastêpna linia jest kontynuacj± bie¿±cej,
znak krzy¿yka <q>#</q> powoduje traktowanie reszty linijki jako komentarza.</P>
<P>
Je¶li w czasie wykonywanie któregokolwiek z poleceñ w bloku wyst±pi b³±d (¶ci¶le mówi±c, to
gdy b³±d zwróci wykonywane polecenie, jak u nas FASM czy NASM), to <span lang="en">MAKE</span>
 <em class="wazne">natychmiast przerywa
dzia³anie</em> z informacj± o b³êdzie i nie wykona ¿adnych dalszych poleceñ (pamiêtajcie wiêc
o umieszczeniu w zmiennej ¶rodowiskowej <span lang="en">PATH</span> ¶cie¿ki do kompilatorów).
</P>
<P>
W powy¿szym pliku widaæ jeszcze jedno: zmiana nazwy którego¶ z plików lub jakie¶ opcji sprawi,
¿e trzeba j± bêdzie zmieniaæ wielokrotnie, w wielu miejscach pliku. Bardzo niewygodne w
utrzymaniu, prawda?<BR>
Na szczê¶cie z pomoc± przychodz± nam ... zmienne, które mo¿emy deklarowaæ w <q lang="en">Makefile</q>
 i które zrozumie program <span lang="en">MAKE</span>.<BR>
Sk³adnia deklaracji zmiennej jest wyj±tkowo prosta i wygl±da tak:</P>
<PRE>		NAZWA_ZMIENNEJ = warto¶æ</PRE>
<P>A u¿ycie:</P>
<PRE>		$(NAZWA_ZMIENNEJ)</PRE>

<P>Polecam nazwy zmiennych pisaæ wielkimi literami w celu odró¿nienia ich od innych elementów. Pole
warto¶ci zmiennej mo¿e zawieraæ dowolny ci±g znaków.</P>

<P>Je¶li chcemy, aby tre¶æ polecenia NIE pojawia³a siê na ekranie, do nazwy tego polecenia
dopisujemy z przodu znak ma³pki <q>@</q>, na przyk³ad</P>
<PRE>		@echo &quot;Wszystko zakonczone pomyslnie&quot;</PRE>

<P>Uzbrojeni w te informacje, przepisujemy nasz wcze¶niejszy <q lang="en">Makefile</q>:</P>
	<BR><a href="#make2" class="bezdruk">(przeskocz drugi przyk³ad)</a>
<PRE title="bardziej rozbudowany Makefile">
# Mój pierwszy Makefile

FASM		= fasm	# ale mo¿na tu w przysz³o¶ci wpisaæ pe³n± ¶cie¿kê

NASM		= nasm
NASM_OPCJE	= -O999 -f elf

LD		= ld
LD_OPCJE	= -s

PLIKI_O		= plik1.o plik2.o plik3.o plik4.o plik5.o plik6.o
PROGRAM		= wynik

all:	kompilacja linkowanie
	@echo &quot;Wszystko zakonczone pomyslnie&quot;

kompilacja:
	$(NASM) $(NASM_OPCJE) -o plik1.o plik1.asm
	$(NASM) $(NASM_OPCJE) -o plik2.o plik2.asm
	$(NASM) $(NASM_OPCJE) -o plik3.o plik3.asm

	$(FASM) plik4.asm plik4.o
	$(FASM) plik5.asm plik5.o
	$(FASM) plik6.asm plik6.o

linkowanie:	$(PLIKI_O)
	$(LD) $(LD_OPCJE) -o $(PROGRAM) $(PLIKI_O)

help:
	@echo &quot;Wpisz make bez argumentow&quot;</PRE>

<P><a name="make2" id="make2">Oczywi¶cie, w koñcowym <q lang="en">Makefile</q></a>
 nale¿y napisaæ takie regu³ki,
 które pozwol± na ewentualn± kompilacjê pojedynczych plików, na przyk³ad</P>
<PRE title="regu³ki do kompilacji pojedynczych plików">
plik1.o:	plik1.asm plik1.inc
	$(NASM) $(NASM_OPCJE) -o plik1.o plik1.asm</PRE>
<P>
Choæ na razie byæ mo¿e niepotrzebna, umiejêtno¶æ pisania <q lang="en">Makefile</q>'ów
 mo¿e siê przydaæ ju¿
przy projektach zawieraj±cych tylko kilka modu³ów (bo nikt nigdy nie pamiêta, które pliki s±
aktualne, a które nie).<BR>
O tym, ile <q lang="en">Makefile</q> mo¿e zaoszczêdziæ czasu przekona³em siê sam, pisz±c swoj± bibliotekê -
kiedy¶ kompilowa³em ka¿dy modu³ z osobna, teraz wydajê jedno jedyne polecenie
<code lang="en">make</code> i
wszystko siê samo robi. <q lang="en">Makefile</q> z biblioteki jest spakowany razem
 z ni± i mo¿ecie go sobie zobaczyæ.</P>

<br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="linux08.html">Poprzednia czê¶æ kursu</a> (Alt+3)<br>
<a accesskey="4" hreflang="pl" href="linux10.html">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

</BODY></HTML>
