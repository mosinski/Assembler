<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks: Pisanie bootsektorów </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Pisanie bootsektorów w asemblerze pod Linuksem">
<META NAME="Keywords" CONTENT="boot, bootsector, bootsektor, assembler, asm, asembler">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Tue, Jan 18 2011 17:59:56 CEST">
</HEAD><BODY>

<h1 class="nag">Pisanie <span lang="en">boot</span>-sektorów pod Linuksem</h1>

<P>
Gdy ju¿ choæ ¶rednio znacie asemblera, to po pewnym czasie pojawiaj± siê pytania
 (mog± one byæ spowodowane tym, co us³yszeli¶cie lub Wasz± w³asn± ciekawo¶ci±):</P>
<OL>
 <LI>Co siê dzieje, gdy ma zostaæ uruchomiony jest system operacyjny?</LI>
 <LI>Sk±d <acronym lang="en" title="Basic Input/Output System">BIOS</acronym>
 	ma wiedzieæ, któr± czê¶æ systemu uruchomiæ?</LI>
 <LI>Jak BIOS odró¿nia systemy operacyjne, aby móc je uruchomiæ?</LI>
</OL>
<P>Odpowied¼ na pytanie 2 brzmi: nie wie. Odpowied¼ na pytanie 3 brzmi: wcale. Wszystkie Wasze
w±tpliwo¶ci rozwieje odpowied¼ na pytanie 1.</P>

<P>
Gdy zakoñczy³ siê POST (<span lang="en">Power-On Self Test</span>), wykrywanie dysków i innych urz±dzeñ,
 BIOS przystêpuje do czytania pierwszych sektorów tych urz±dzeñ, na których ma byæ szukany system
operacyjny (u mnie jest ustawiona kolejno¶æ: <acronym lang="en"
title="Compact Disc Read-Only Memory">CD-ROM</acronym>,
 stacja dyskietek, dysk twardy).<BR>
Gdy znajdzie sektor odpowiednio zaznaczony: bajt nr 510 = 55h i bajt 511 = AAh
(pamiêtajmy, ¿e 1 sektor ma 512 bajtów, a liczymy od zera), to wczytuje go pod adres
bezwzglêdny 07C00h i uruchamia kod w nim zawarty (po prostu wykonuje skok pod ten adres). Nie nale¿y
jednak polegaæ na tym, ¿e segment kodu CS = 0, a adres instrukcji IP=7C00h (choæ najczê¶ciej tak jest).
</P>
<P>
 To w³a¶nie <span lang="en">boot</span>-sektor jest odpowiedzialny za ³adowanie odpowiednich
 czê¶ci w³a¶ciwego systemu operacyjnego. Na komputerach z wieloma systemami operacyjnymi
 sprawa te¿ nie jest tak bardzo skomplikowana. Pierwszy sektor dysku twardego, zwany
 <span lang="en">Master Boot Record</span> (MBR),
zawiera program ³aduj±cy (<span lang="en">Boot Manager</span>, jak LILO czy GRUB), który z kolei
uruchamia <span lang="en">boot</span>-sektor wybranego systemu operacyjnego.
</P>
<P>
My oczywi¶cie nie bêdziemy operowaæ na dyskach twardych, gdy¿ by³oby to niebezpieczne. Z
dyskietkami za¶ mo¿na eksperymentowaæ do woli...<BR>
A instrukcja jest
prosta: umieszczamy nasz programik w pierwszym sektorze dyskietki, zaznaczamy go
odpowiednimi ostatnimi bajtami i tyle. No w³a¶nie... niby proste, ale jak o tym pomy¶leæ
to ani to pierwsze, ani to drugie nie jest spraw± banaln±.
</P>
<P>
Do zapisania naszego <span lang="en">boot</span>sektorka na dyskietkê mo¿emy oczywi¶cie u¿yæ
 gotowców - programów typu <CODE>dd</CODE> itp. Ma to pewne zalety - program by³ ju¿ u¿ywany
 przez du¿± liczbê osób, jest sprawdzony i dzia³a.<BR>
Przyk³adowy sposób u¿ycia (po skompilowaniu bootsektora):</P>
<PRE>		dd count=1 if=boot.bin of=/dev/fd0</PRE>


<P>Ale co¶ by by³o nie tak, gdybym w kursie programowania w asemblerze kaza³ Wam u¿ywaæ
cudzych programów. Do napisania swojego w³asnego programu zapisuj±cego dany plik w pierwszym
sektorze dyskietki w zupe³no¶ci wystarczy Wam wiedza uzyskana po przeczytaniu czê¶ci mojego
kursu po¶wiêconej operacjom na plikach.</P>
<P>Schemat dzia³ania jest taki:</P>
<UL>
 <LI>Otwórz plik zawieraj±cy skompilowany bootsektor</LI>
 <LI>Przeczytaj z niego 512 bajtów (do zadeklarowanej tablicy w pamiêci)</LI>
 <LI>Zamknij ten plik</LI>
 <LI>Otwórz plik /dev/fd0 do zapisu</LI>
 <LI>Zapisz do niego wcze¶niej odczytane dane</LI>
 <LI>Zamknij ten plik</LI>
</UL>
<P>Sprawa jest tak prosta, ¿e tym razem nie podam gotowca.</P>

<P>
Gdy ju¿ mamy program zapisuj±cy bootsektor na dyskietkê, trzeba siê postaraæ o to, aby
nasz programik (który ma staæ siê tym bootsektorem) mia³ dok³adnie 512 bajtów i aby 2 ostatnie
jego bajty to 55h, AAh.<BR>
Oczywi¶cie, nie bêdziemy rêcznie dok³adaæ tylu bajtów, ile trzeba, aby dope³niæ nasz program
do tych 512. Zrobi to za nas kompilator. Wystarczy po ca³ym kodzie i wszystkich danych, na
szarym koñcu, umie¶ciæ takie co¶:
</P>
<PRE>	times 510 - ($ - start) db 0
	dw 0aa55h</PRE>

<P>To wyra¿enie mówi tyle: od bie¿±cej pozycji w kodzie odejmij pozycjê pocz±tku kodu (tym
samym obliczaj±c d³ugo¶æ ca³ego kodu), otrzyman± liczbê odejmij od 510 - i do³ó¿ tyle
w³a¶nie bajtów zerowych. Gdy ju¿ mamy program d³ugo¶ci 510 bajtów, to dok³adamy jeszcze
znacznik i wszystko jest dobrze.
</P>
<P>
Jest jednak jeszcze jedna sprawa, o której nie wspomnia³em - ustawienie DS i warto¶ci ORG
dla naszego kodu. Otó¿, je¶li stwierdzimy, ¿e nasz kod powinien zaczynaæ siê od offsetu
0 w naszym segmencie, to ustawmy sobie <q>org 0</q> i DS=07C0h (tak, liczba zer siê zgadza), ale
mo¿emy te¿ mieæ <q>org 7C00h</q> i DS=0. ¯adne z tych nie wp³ywa w ¿aden sposób na d³ugo¶æ
otrzymanego programu, a nale¿y o to zadbaæ, gdy¿ nie mamy gwarancji, ¿e DS bêdzie pokazywa³
na nasze dane po uruchomieniu <span lang="en">boot</span>sektora.
</P>
<P>
Teraz, uzbrojeni w niezbêdn± wiedzê, zasiadamy do pisania kodu naszego bootsektora. Nie
musi to byæ co¶ wielkiego - tutaj poka¿ê co¶, co w lewym górnym rogu ekranu poka¿e cyfrê jeden
(o bezpo¶redniej manipulacji ekranem mo¿ecie przeczytaæ w moim innym artykule) i po naci¶niêciu
dowolnego klawisza zresetuje komputer (na jeden ze sposobów podanych w jeszcze innym
artykule...).</P>
<P>
Oto nasz kod (NASM):</P>
	<BR><a href="#boot_tut_linux01" class="bezdruk" tabindex="1">(przeskocz przyk³adowy <span lang="en">boot</span>sektor)</a>
<PRE>
	; nasm -o boot.bin -f bin boot.asm

	org 7c00h			; lub &nbsp; &nbsp; &quot;org 0&quot;

	start:
		mov	ax, 0b800h
		mov	es, ax		; ES = segment pamiêci ekranu

		mov	byte [es:0], &quot;1&quot; ; piszemy &quot;1&quot;

		xor	ah, ah
		int	16h		; czekamy na klawisz

		mov	bx, 40h
		mov	ds, bx
		mov	word [ds:72h], 1234h	; 40h:72h = 1234h -
						; wybieramy gor±cy reset

		jmp	0ffffh:0000h		; reset

	times 510 - ($ - start) db 0		; dope³nienie do 510 bajtów
	dw 0aa55h				; znacznik</PRE>


<P><a name="boot_tut_linux01" id="boot_tut_linux01">Nie by³o to d³ugie ani trudne</a>, prawda?
 Rzecz jasna, nie mo¿na w <span lang="en">boot</span>sektorach
 u¿ywaæ ¿adnych funkcji systemowych, na przyk³ad linuksowego int 80h, bo ¿aden system po prostu
 nie jest uruchomiony i za³adowany.
Tak napisany programik kompilujemy do formatu binarnego.
Po kompilacji umieszczamy go na dyskietce przy u¿yciu programu napisanego ju¿ przez nas
wcze¶niej. Resetujemy komputer (i upewniamy siê, ¿e BIOS spróbuje uruchomiæ system z
dyskietki), wk³adamy dyskietkê i.... cieszymy siê swoim dzie³em (co prawda ta jedynka
mo¿e byæ ma³o widoczna, ale rzeczywi¶cie znajduje siê na ekranie).
</P>
<P>
Zauwa¿cie te¿, ¿e system nie rozpoznaje ju¿ naszej dyskietki, mimo i¿ przedtem by³a
sformatowana. Dzieje siê tak dlatego, ¿e w bootsektorze umieszczane s± informacje o dysku.<BR>
Bootsektor typu <acronym lang="en" title="File Allocation Table">FAT</acronym>12
(vfat) powinien siê zaczynaæ mniej-wiêcej tak:</P>
	<BR><a href="#boot_tut_linux02" class="bezdruk">(przeskocz systemowy obszar <span lang="en">boot</span>sektora)</a>
<PRE title="obszar bootsektora u¿ywany przez system">
	org 7c00h			; lub org 0, oczywi¶cie

	start:
		jmp short kod
		nop

		db &quot;        &quot;	; nazwa OS i wersja OEM (8B)
		dw 512		; bajtów/sektor (2B)
		db 1		; sektory/jednostkê alokacji (1B)
		dw 1		; zarezerwowane sektory (2B)
		db 2		; liczba tablic alokacji (1B)
		dw 224		; liczba pozycji w katalogu g³ównym (2B)
				; 224 to typowa warto¶æ
		dw 2880		; liczba sektorów (2B)
		db 0f0h		; Media Descriptor Byte (1B)
		dw 9		; sektory/FAT (2B)
		dw 18		; sektory/¶cie¿kê (2B)
		dw 2		; liczba g³owic (2B)
		dd 0		; liczba ukrytych sektorów (4B)
		dd 0		; liczba sektorów (czê¶æ 2),
				; je¶li wcze¶niej by³o 0 (4B)
		db 0		; numer dysku (1B)
		db 0		; zarezerwowane (1B)
		db 0		; rozszerzona sygnatura bloku ³aduj±cego
		dd 0bbbbddddh	; numer seryjny dysku (4B)
		db &quot;           &quot;; etykieta (11B)
		db &quot;FAT 12  &quot;	; typ FAT (8B), zwykle  &quot;FAT 12  &quot;

	kod:
		; tutaj dopiero kod bootsektora</PRE>

<P><a name="boot_tut_linux02" id="boot_tut_linux02">Ta porcja danych oczywi¶cie uszczupla</a> ilo¶æ
kodu, któr± mo¿na umie¶ciæ w <span lang="en">boot</span>sektorze. Nie jest to
jednak du¿y problem, gdy¿ i tak jedyn± rol± wiêkszo¶ci <span lang="en">boot</span>sektorów
 jest uruchomienie innych programów (<span lang="en">second stage bootloaders</span>),
 które dopiero zajmuj± siê ³adowaniem w³a¶ciwego systemu.
</P>
<P>
Jeszcze ciekawostka: co wypisuje BIOS, gdy dysk jest niew³a¶ciwy (niesystemowy)?<BR>
Otó¿ - nic! BIOS bardzo chêtnie przeszed³by do kolejnego urz±dzenia.<BR>
Dlaczego wiêc tego nie robi i sk±d ten napis o niew³a¶ciwym dysku systemowym??<BR>
Odpowied¼ jest prosta - sformatowana dyskietka posiada <span lang="en">boot</span>sektor!<BR>
Dla BIOSu jest wszystko OK, uruchamia wiêc ten <span lang="en">boot</span>sektor.
 Dopiero ten wypisuje informacjê
o niew³a¶ciwym dysku, czeka na naci¶niêcie klawisza, po czym uruchamia int 19h. O tym, co
robi przerwanie 19h mo¿ecie przeczytaæ w artykule o resetowaniu.
</P>
<P>
Mi³ego <span lang="en">boot</span>owania systemu!</P>
<P>
P.S. Je¶li nie chcecie przy najdrobniejszej zmianie kodu resetowaæ komputera, mo¿ecie poszukaæ
w Internecie programów, które symuluj± procesor (w tym fazê ³adowania systemu).
Jednym z takich programów jest
<A HREF="http://bochs.sourceforge.net/" hreflang="en">Bochs</A>.</P>







<Br>
<hr>
<h2 class="nag">Co dalej?</h2>
<P>

Mimo i¿ <span lang="en">boot</span>sektor jest ograniczony do 512 bajtów, to mo¿e w do¶æ
 ³atwy sposób pos³u¿yæ do wczytania do pamiêci o wiele wiêkszych programów. Wystarczy u¿yæ
 funkcji czytania sektorów. W
 <A HREF="http://www-2.cs.cmu.edu/afs/cs.cmu.edu/user/ralf/pub/WWW/files.html" hreflang="en"
>spisie Przerwañ Ralfa <span lang="en">Brown</span>'a</A> czytamy:</P>
	<BR><a href="#boot_tut_linux05" class="bezdruk">(przeskocz opis int 13h, ah=2)</a>
<PRE lang="en" title="int 13h, ah=2">
	INT 13 - DISK - READ SECTOR(S) INTO MEMORY
		AH = 02h
		AL = number of sectors to read (must be nonzero)
		CH = low eight bits of cylinder number
		CL = sector number 1-63 (bits 0-5)
		     high two bits of cylinder (bits 6-7, hard disk only)
		DH = head number
		DL = drive number (bit 7 set for hard disk)
		ES:BX -> data buffer
	Return: CF set on error
		CF clear if successful</PRE>

<P><a name="boot_tut_linux05" id="boot_tut_linux05">Wystarczy wiêc wybraæ nieu¿ywany segment</a>
pamiêci, na przyk³ad ES=8000h i pocz±wszy od offsetu BX=0,
 czytaæ sektory zawieraj±ce nasz kod, zwiêkszaj±c BX o 512 za ka¿dym razem. Kod do za³adowania
 nie musi byæ oczywi¶cie w postaci pliku na dyskietce, to by tylko utrudni³o pracê (gdy¿ trzeba
 wtedy czytaæ tablicê plików FAT). Naj³atwiej za³adowaæ kod tym samym sposobem, co
 <span lang="en">boot</span>sektor, ale oczywi¶cie do innych sektorów.
 Naj³atwiej to zrobiæ, sklejaj±c skompilowany plik <span lang="en">boot</span>sektora
 ze skompilowanym kodem i potem nagraæ na dyskietkê:</P>
<pre>
		cat boot.bin system.bin > wszystko.bin
		dd if=wszystko.bin of=/dev/fd0	</pre>
<P>

Po za³adowaniu ca³ego potrzebnego kodu do pamiêci przez <span lang="en">boot</span>sektor,
 wystarczy wykonaæ skok:</P>
<pre>	jmp	8000h:0000h</pre>
<P>Wtedy kontrolê przejmuje kod wczytany z dyskietki.</P>
<P>
Ale jest jeden kruczek - trzeba wiedzieæ, jakie numery cylindra, g³owicy i sektora podaæ
 do funkcji czytaj±ce sektory, ¿eby rzeczywi¶cie odczyta³a te w³a¶ciwe.<br>
Struktura standardowej dyskietki jest nastêpuj±ca: 512 bajtów na sektor, 18 sektorów na ¶cie¿kê,
 2 ¶cie¿ki na cylinder (bo s± dwie strony dyskietki, co daje 36 sektorów na cylinder),
 80 cylindrów na g³owicê. Razem 2880 sektorów po 512 bajtów, czyli 1.474.560 bajtów.
</P>
<P>
Maj±c numer sektora (bo wiemy, pod jakimi sektorami zapisali¶my swój kod na dyskietce),
 odejmujemy od niego 1 (tak by zawsze wszystkie numery sektorów zaczyna³y siê od zera),
 po czym dzielimy go przez 36. Uzyskany iloraz to numer cylindra (rejestr CH),
 reszta za¶ oznacza numer sektora w tym¿e cylindrze (rejestr CL). Je¶li ta reszta
 jest wiêksza b±d¼ równa 18, nale¿y wybraæ g³owicê numer 1 (rejestr DH), za¶ od numeru
 sektora (rejestr CL) odj±æ 18. W przeciwnym przypadku nale¿y wybraæ g³owicê numer 0 i nie robiæ nic
 z numerem sektora.<br>
W ten sposób otrzymujemy wszystkie niezbêdne dane i mo¿emy bez przeszkód w pêtli czytaæ kolejne
 sektory zawieraj±ce nasz kod.</P>
<P>
Ca³± tê procedurê ilustruje ten przyk³adowy kod:</P>
	<BR><a href="#boot_tut_linux06" class="bezdruk">(przeskocz procedurê czytania sektorów)</a>
<pre title="procedura czytania sektorów">
secrd:
;wej¶cie: ax=sektor, es:bx wskazuje na dane

	dec ax		; z numerów 1-36 na 0-35
	mov cl,36	; liczba sektorów na cylinder = 36
	xor dx,dx	; zak³adamy na pocz±tek: g³owica 0, dysk 0 (a:)
	div cl		; AX (numer sektora) dzielimy przez 36
	mov ch,al	; AL=cylinder, AH=przesuniêcie wzglêdem
			;	pocz±tku cylindra, czyli sektor
	cmp ah,18	; czy numer sektora mniejszy od 18?
	jb .sec_ok	; je¶li tak, to nie robimy nic
	sub ah,18	; je¶li nie, to odejmujemy 18
	inc dh		; i zmieniamy g³owicê
.sec_ok:
	mov cl, ah	; CL = numer sektora
	mov ax,0201h	; odczytaj 1 sektor
	inc cl		; zwiêksz z powrotem z zakresu 0-17 do 1-18

	push dx		; niektóre biosy niszcz± DX, nie ustawiaj±
			;	flagi CF, lub zeruj± flagê IF
	stc
	int 13h		; wykonaj czytanie
	sti
	pop dx</pre>






<br><br>
<div class="bezdruk">
<A accesskey="1" hreflang="pl" href="../index.htm" name="boot_tut_linux06" id="boot_tut_linux06">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

</BODY></HTML>
