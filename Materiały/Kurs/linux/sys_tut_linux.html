<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks: Modu³y j±dra </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<link rel="alternate" type="text/html" href="sys_tut_linux_en.html"
	hreflang="en" lang="en" title="English version">

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Pisanie modu³ów j±dra Linuksa">
<META NAME="Keywords" CONTENT="asm, assembler, asembler, linux, linuks, j±dro, kernel, modu³, module, 2.4">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Tue, Jan 18 2011 18:00:00 CEST">
</HEAD><BODY>

<h1 class="nag">Pisanie modu³ów j±dra Linuksa</h1>

<P>
Do j±dra systemu Linux na sta³e wkompilowane s± tylko najwa¿niejsze sterowniki podstawowych
 urz±dzeñ (na przyk³ad dyski twarde), gdy¿ umieszczanie tam wszystkich to strata pamiêci a przede
 wszystkim czasu na uruchomienie i wy³±czenie siê sterowników do urz±dzeñ nieistniej±cych w danym
 komputerze. Dlatego sterowniki do urz±dzeñ opcjonalnych umieszczono w modu³ach j±dra,
 ³adowanych przez system na ¿±danie.</P>
<P>
Modu³ j±dra to najzwyklejszy skompilowany plik w standardowym formacie <acronym
 title="Executable-Linkable Format" lang="en">ELF</acronym>. Musi
 eksportowaæ na zewn±trz dwie funkcje: <span lang="en" class="b">init_module</span>, s³u¿±c± do
 inicjalizacji modu³u (i uruchamian± w czasie jego ³adowania)
 oraz <span lang="en" class="b">cleanup_module</span>, s³u¿±c± do wykonania
 czynno¶ci koniecznych do prawid³owego zakoñczenia pracy (uruchamian± w czasie usuwania modu³u z j±dra).</P>
<P>Funkcja <span lang="en" class="b">init_module</span> musi byæ tak napisana, ¿e w przypadku sukcesu
 zwraca zero, a w przypadku pora¿ki - najlepiej jedn± ze znanych ujemnych warto¶ci b³êdu, która
 dobrze bêdzie opisywaæ problem.</P>
<P>
<span class="b">Sporo informacji dotycz±cych j±dra 2.4 przenosi siê na j±dro 2.6, wiêc w
 sekcji po¶wiêconej j±dru 2.6 powiem tylko, co siê zmieni³o w stosunku do 2.4.</span>
</P>



<Hr>
<h2 class="nag">Najprostszy modu³ j±dra 2.4</h2>
	<BR><a href="#chardev" class="bezdruk" tabindex="1">(przeskocz najprostszy modu³)</a>

<P>
Zgodnie z tym, co powiedzia³em wy¿ej, najprostszy modu³ wygl±da tak:</P>

	<BR><a href="#sys_tut_linux01" class="bezdruk">(przeskocz kod najprostszego modu³u)</a>
<pre title="najprostszy modu³ j±dra 2.4">
	format ELF

	section &quot;.text&quot; executable	; pocz±tek sekcji kodu

	; eksportowanie dwóch wymaganych funkcji
	public	init_module
	public	cleanup_module

	; deklaracja zewnêtrznej funkcji, s³u¿±cej do wy¶wietlania
	extrn	printk

	init_module:
		push	dword napis1	; napis do wy¶wietlenia
		call	printk
		pop	eax		; zdejmujemy argumenty ze stosu

		xor	eax, eax	; zero oznacza brak b³êdu
		ret

	cleanup_module:
		push	dword napis2
		call	printk
		pop	eax

		ret

	section &quot;.data&quot; writeable
	napis1		db	&quot;&lt;1&gt; Jestem w init_module.&quot;   , 10, 0
	napis2		db	&quot;&lt;1&gt; Jestem w cleanup_module.&quot;, 10, 0

	section &quot;.modinfo&quot;
	__module_kernel_version db	&quot;kernel_version=2.4.26&quot;, 0
	__module_license	db	&quot;license=GPL&quot;, 0
	__module_author		db	&quot;author=Bogdan D.&quot;, 0
	__module_description	db &quot;description=Pierwszy modul jadra.&quot;, 0</pre>

<a name="sys_tut_linux01" id="sys_tut_linux01">Zauwa¿cie kilka spraw</a>:
<ol>
 <li>Wy¶wietlanie napisów odbywa siê wewnêtrzn± funkcj± j±dra - <span class="b">printk</span>.
 	Dzia³a ona podobnie do funkcji <span class="b">printf</span> z jêzyka C,
 	która na etapie ³adowania j±dra jest oczywi¶cie niedostêpna.

 	<P>W skrócie: adres napisu podajemy na stosie, poprzedzaj±c dodatkowymi danymi w odwrotnej
 	kolejno¶ci, je¶li funkcja w ogóle ma wy¶wietliæ jakie¶ zmienne w napisie, na przyk³ad %d (liczba ca³kowita).
 	Bêdzie to dok³adniej pokazane na przyk³adowym module.</P>
 	<P>Napis powinien siê zaczynaæ wyra¿eniem &lt;N&gt;, gdzie N to pewna liczba. Ma to
 	pozwoliæ j±dru rozró¿niæ powagê wiadomo¶ci. Nam wystarczy za N wstawiaæ 1.</P>

 	<P><span class="b">Je¶li wy¶wietlanych napisów nie widaæ na ekranie, to na pewno pojawi± siê po
 	komendzie <code>dmesg</code> (zwykle na koñcu)</span> oraz w pliku /var/log/messages.
 	</P></li>

 <li>Sk³adnia jest dla kompilatora FASM.
 	<P>Modu³y kompilowane NASMem z niewiadomych przyczyn nie chcia³y mi wchodziæ do j±dra.</P></li>

 <li><P>Ka¿da funkcja j±dra uruchamiana jest w konwencji C, czyli my sprz±tamy argumenty ze stosu.</P></li>

 <li>Nowa sekcja - modinfo.
 	<P>Zawiera informacje, dla której wersji j±dra modu³ jest przeznaczony, kto jest jego
 	autorem, na jakiej jest licencji, argumenty. Nazwy zmiennych musz± pozostaæ bez zmian, tre¶æ
 	po znakach równo¶ci powinni¶cie pozmieniaæ wed³ug potrzeb.</P></li>
</ol>

<P>Modu³ ten, po kompilacji (<code>fasm modul_hello.asm</code>) instaluje siê jako
 <em class="wazne" lang="en">root</em> komend±</P>
 <pre>	insmod ./modul_hello.o</pre>
 <P>a usuwa z j±dra - komend±</P>
 <pre>	rmmod modul_hello</pre>
 <P>(zauwa¿cie brak rozszerzenia .o).</P>
<P>Listê modu³ów obecnych w j±drze mo¿na otrzymaæ komend± <code>lsmod</code>.</P>
<P>
Poka¿ê teraz, jak zarejestrowaæ urz±dzenie znakowe, zaj±æ dla niego zasoby
 <acronym title="Interrupt ReQuest" lang="en">IRQ</acronym> oraz zakres portów i pamiêci.</P>






<Hr>
<h2 class="nag"><a name="chardev" id="chardev">Rejestracja urz±dzenia znakowego</a></h2>
	<BR><a href="#iop" class="bezdruk">(przeskocz rejestracjê urz±dzenia znakowego)</a>

<P>
Do rejestracji urz±dzenia znakowego (czyli takiego, z którego mo¿na odczytywaæ po bajcie,
 w przeciwieñstwie do na przyk³ad dysku twardego) s³u¿y eksportowana przez j±dro funkcja
 <code lang="en">register_chrdev</code>. Przyjmuje ona 3 argumenty. Od lewej (ostatni
 wk³adany na stos) s± to:</P>
<ol>
 <li>Numer g³ówny urz±dzenia, który sobie wybrali¶my.
	<P>Mo¿na podaæ zero, wtedy j±dro
 	przydzieli nam jaki¶ wolny. Numer g³ówny to pierwszy z dwóch numerów (drugi
 	to poboczny), widoczny w szczegó³owym widoku plików z katalogu /dev, na przyk³ad</P>
 	<pre>	crw-rw-rw-  1 root root 1, 5 sie 16 15:28 /dev/zero</pre>
 	<P>Urz±dzenie /dev/zero ma numer g³ówny 1 i poboczny 5, litera C na pocz±tku oznacza
 	w³a¶nie urz±dzenie znakowe. Inne oznaczenia to D (katalog), S (gniazdo),
 	B (urz±dzenie blokowe), P (<acronym lang="en" title="First In, First Out">FIFO</acronym>),
 	L (dowi±zanie symboliczne).
 	</P></li>
 <li><P>Adres nazwy urz±dzenia w postaci ci±gu znaków zakoñczonego bajtem zerowym.</P></li>
 <li>Adres struktury <span lang="en">file_operations</span>, do której wpiszemy adresy
 	odpowiednich funkcji do operacji na pliku.
	<P>Najwa¿niejsze s±: otwieranie, zamykanie,
 	zapis i czytanie z urz±dzenia. Sama struktura wygl±da tak dla j±dra 2.4:</P>
	<BR><a href="#sys_tut_linux02" class="bezdruk">(przeskocz strukturê <span lang="en">file_operations</span>)</a>
 	<pre title="struktura file_operations" lang="en">
	struct file_operations {
		struct module *owner;
		loff_t (*llseek) (struct file *, loff_t, int);
		ssize_t (*read) (struct file*, char*, size_t, loff_t *);
		ssize_t (*write) (struct file *, const char *, size_t,
			loff_t *);
		int (*readdir) (struct file *, void *, filldir_t);
		unsigned int (*poll) (struct file *,
			struct poll_table_struct *);
		int (*ioctl) (struct inode*, struct file*, unsigned int,
			unsigned long);
		int (*mmap) (struct file *, struct vm_area_struct *);
		int (*open) (struct inode *, struct file *);
		int (*flush) (struct file *);
		int (*release) (struct inode *, struct file *);
		int (*fsync) (struct file*,struct dentry*, int datasync);
		int (*fasync) (int, struct file *, int);
		int (*lock) (struct file *, int, struct file_lock *);
		ssize_t (*readv) (struct file *, const struct iovec *,
			unsigned long, loff_t *);
		ssize_t (*writev) (struct file *, const struct iovec *,
			unsigned long, loff_t *);
	}; </pre>
	<P><a name="sys_tut_linux02" id="sys_tut_linux02">Ka¿de pole tej struktury</a> to DWORD.
	Do podstawowej funkcjonalno¶ci wystarczy wype³niæ
	pola: trzecie, czwarte, dziewi±te i jedenaste (zamykanie pliku). Je¶li jakiej¶ funkcji
	nie planujemy pisaæ, nale¿y na odpowiadaj±ce jej miejsce w tej strukturze wpisaæ zero.</P></LI>
</ol>
<P>Je¶li podali¶my tej funkcji nasz w³asny numer g³ówny urz±dzenia, to je¶li rejestracja siê
 uda³a, <code lang="en">register_chrdev</code> zwróci zero w EAX. Je¶li poprosili¶my o przydzielenie
 nam numeru g³ównego, to je¶li rejestracja siê powiedzie, <code lang="en">register_chrdev</code>
 zwróci liczbê wiêksz± od zera, która to liczba bêdzie przeznaczonym dla naszego urz±dzenia
 numerem g³ównym.</P>
<P>
<em class="wazne">UWAGA:</em> Funkcja <code lang="en">register_chrdev</code> nie tworzy
 pliku urz±dzenia w katalogu /dev. O to musimy zadbaæ sami, po za³adowaniu modu³u.</P>
<P>
Wyrejestrowanie urz±dzenia znakowego nastêpuje poprzez wywo³anie funkcji
 <code lang="en">unregister_chrdev</code>. Pierwszy argument od lewej (ostatni na stos)
 to przydzielony urz±dzeniu numer g³ówny, a drugi - adres nazwy urz±dzenia.</P>





<Hr>
<h2 class="nag"><a name="iop" id="iop">Rejestracja portów wej¶cia-wyj¶cia</a> oraz obszaru pamiêci</h2>
	<BR><a href="#irq" class="bezdruk">(przeskocz rejestracjê portów i pamiêci)</a>

<P>
Zarezerwowanie tych zasobów jest do¶æ ³atwe. Nale¿y tylko uruchomiæ funkcjê
 <code lang="en">__request_region</code>. Przyjmuje ona 4 argumenty. Od lewej (ostatni
 wk³adany na stos) s± to:</P>
<ol>
 <Li>Typ zasobu. Je¶li chcemy zarezerwowaæ porty, podajemy tu adres zmiennej
 	<code lang="en">ioport_resource</code>, je¶li pamiêæ - <code lang="en">iomem_resource</code>.
 	Obie zmienne s± eksportowane przez j±dro, wiêc mo¿na je zadeklarowaæ
 	jako zewnêtrzne dla modu³u.</li>
 <li>Pocz±tkowy numer portu lub pocz±tkowy adres pamiêci.</li>
 <li>D³ugo¶æ zakresu portów lub pamiêci</li>
 <li>Adres nazwy urz±dzenia.</li>
</ol>
<P>W przypadku niepowodzenia, funkcja zwraca zero (w EAX).</P>
<P>
Oba te rodzaje zasobów zwalnia siê funkcj± <code lang="en">__release_region</code>. Jako
 swoje argumenty przyjmuje ona 3 pierwsze z powy¿szych (typ oraz pocz±tek i d³ugo¶æ zakresu).</P>





<Hr>
<h2 class="nag"><a name="irq" id="irq">Rejestracja zasobu
	<acronym lang="en" title="Interrupt ReQuest">IRQ</acronym></a></h2>
	<BR><a href="#przyk" class="bezdruk">(przeskocz rejestracjê IRQ)</a>

<P>
Zasoby ¿±dania przerwania (IRQ)
rejestruje siê funkcj± <code lang="en">request_irq</code>.
Przyjmuje ona a¿ 5 argumentów typu DWORD. Od lewej (ostatni wk³adany na stos) s± to:</P>
<ol>
 <li>Numer przerwania IRQ, które chcemy zaj±æ.</li>
 <li>Adres naszej funkcji, która bêdzie obs³ugiwaæ przerwania. Prototyp takiej funkcji wygl±da tak:
 	<pre lang="en">	void handler (int irq, void *dev_id, struct pt_regs *regs);</pre>
 	Jak widaæ, bêdzie mo¿na ze stosu otrzymaæ informacje, które przerwanie zosta³o wywo³ane
 	oraz przez jakie urz±dzenie. Ostatni argument podobno jest ju¿ rzadko u¿ywany.</li>
 <li>Warto¶æ SA_INTERRUPT = 0x20000000</li>
 <li>Adres nazwy urz±dzenia.</li>
 <li>Adres struktury <span lang="en">file_operations</span>, uzupe³nionej adresami funkcji</li>
</ol>
<P>Je¶li zajêcie przerwania siê nie powiedzie, funkcja zwróci warto¶æ ujemn±.</P>
<P>
Zwolnienie przerwania odbywa siê poprzez wywo³anie funkcji <code lang="en">free_irq</code>.
 Jej pierwszy argument od lewej (ostatni na stos) to nasz numer IRQ, a drugi - adres
 naszej struktury <span lang="en">file_operations</span>.</P>








<Hr>
<h2 class="nag"><a name="przyk" id="przyk">Przyk³ad modu³u j±dra 2.4</a></h2>
	<BR><a href="#j26" class="bezdruk">(przeskocz do j±dra 2.6)</a>

<P>
Pokazany ni¿ej program zarejestruje programowe urz±dzenie znakowe (czyli takie, dla którego
 nie ma odpowiednika w sprzêcie, jak na przyk³ad /dev/null) z IRQ 4, zakresem portów 600h-6FFh,
 zakresem pamiêci 80000000h - 8000FFFFh oraz z podstawowymi operacjami: otwieranie, zamykanie,
 czytanie, zapis, zmiana pozycji. Dla uproszczenia kodu nie sprawdzam, czy dane zakresy s±
 wolne. Je¶li oka¿± siê zajête, j±dro zwróci b³±d i modu³ siê nie za³aduje.</P>

	<BR><a href="#sys_tut_linux03" class="bezdruk">(przeskocz kod modu³u)</a>
<pre title="przyk³adowy modu³ j±dra 2.4">
; Przyk³adowy modu³ j±dra 2.4
;
; Autor: Bogdan D., bogdandr (na) op . pl
;
; kompilacja:
;   fasm modul_dev_fasm.asm

format ELF
section	&quot;.text&quot; executable

; eksportowanie wymaganych funkcji
public	init_module
public	cleanup_module

; importowanie u¿ywanych funkcji i symboli
extrn	printk
extrn	register_chrdev
extrn	unregister_chrdev
extrn	request_irq
extrn	free_irq

extrn	__check_region
extrn	__request_region
extrn	__release_region
extrn	ioport_resource
extrn	iomem_resource

; zakresy zasobów, o które poprosimy j±dro
PORTY_START	= 0x600
PORTY_ILE	= 0x100

RAM_START	= 0x80000000
RAM_ILE		= 0x00010000

; sta³e potrzebne do rezerwacji przerwania IRQ.
SA_INTERRUPT	= 0x20000000
NUMER_IRQ	= 4

; funkcja inicjalizacji modu³u
init_module:
	pushfd

	; rejestrowanie urz±dzenia znakowego:
	push	dword file_oper
	push	dword nazwa
	push	dword 0			; numer przydziel dynamicznie
	call	register_chrdev
	add	esp, 3*4		; usuwamy argumenty ze stosu

	cmp	eax, 0			; sprawdzamy, czy b³±d
	jg	.dev_ok

	; tu wiemy, ¿e jest b³±d. wy¶wietlmy to.
	push	eax			; argument do informacji o b³êdzie
	push	dword dev_blad		; adres informacji o b³êdzie
	call	printk			; wy¶wietl informacjê o b³êdzie
	add	esp, 1*4		; specjalnie usuwam tylko 1*4

	pop	eax			; wychodzimy z oryginalnym b³êdem
	jmp	.koniec

.dev_ok:

	mov	[major], eax

	; rezerwacja portów wej¶cia-wyj¶cia
	push	dword nazwa
	push	dword PORTY_ILE
	push	dword PORTY_START
	push	dword ioport_resource
	call	__request_region
	add	esp, 4*4

	test	eax, eax		; sprawdzamy, czy b³±d
	jnz	.iop_ok

	push	eax			; argument do informacji o b³êdzie
	push	dword porty_blad		; adres informacji o b³êdzie
	call	printk			; wy¶wietl informacjê o b³êdzie
	add	esp, 1*4		; potem pop eax

	; wyrejestrowanie urz±dzenia
	push	dword nazwa
	push	dword [major]
	call	unregister_chrdev
	add	esp, 2*4

	pop	eax			; wychodzimy z oryginalnym b³êdem
	jmp	.koniec

.iop_ok:

	; rezerwacja pamiêci
	push	dword nazwa
	push	dword RAM_ILE
	push	dword RAM_START
	push	dword iomem_resource
	call	__request_region
	add	esp, 4*4

	test	eax, eax		; sprawdzamy, czy b³±d
	jnz	.iomem_ok

	push	eax
	push	dword ram_blad
	call	printk			; wy¶wietl informacjê o b³êdzie
	add	esp, 1*4		; potem pop eax

	; wyrejestrowanie urz±dzenia
	push	dword nazwa
	push	dword [major]
	call	unregister_chrdev
	add	esp, 2*4

	; zwolnienie zajêtych przez nas portów
	push	dword PORTY_ILE
	push	dword PORTY_START
	push	dword ioport_resource
	call	__release_region
	add	esp, 3*4

	pop	eax			; wychodzimy z oryginalnym b³êdem
	jmp	.koniec

.iomem_ok:
	; przydzielanie przerwania IRQ:
	push	dword file_oper
	push	dword nazwa
	push	dword SA_INTERRUPT
	push	dword obsluga_irq
	push	dword NUMER_IRQ
	call	request_irq
	add	esp, 5*4

	cmp	eax, 0
	jge	.irq_ok

	push	eax
	push	dword irq_blad
	call	printk			; wy¶wietl informacjê o b³êdzie
	add	esp, 1*4		; potem pop eax

	; wyrejestrowanie urz±dzenia
	push	dword nazwa
	push	dword [major]
	call	unregister_chrdev
	add	esp, 2*4

	; zwolnienie zajêtych przez nas portów
	push	dword PORTY_ILE
	push	dword PORTY_START
	push	dword ioport_resource
	call	__release_region
	add	esp, 3*4

	; zwolnienie zajêtej przez nas pamiêci
	push	dword RAM_ILE
	push	dword RAM_START
	push	dword iomem_resource
	call	__release_region
	add	esp, 3*4

	pop	eax			; wychodzimy z oryginalnym b³êdem
	jmp	.koniec

.irq_ok:

	; wy¶wietlenie informacji o poprawnym uruchomieniu modu³u
	push	dword NUMER_IRQ
	push	dword [major]
	push	dword uruch
	call	printk
	add	esp, 3*4

	xor	eax, eax		; zero - brak b³êdu

.koniec:

	popfd
	ret

; funkcja uruchamiana przy usuwaniu modu³u
cleanup_module:
	pushfd
	push	eax

	; zwolnienie numeru IRQ:
	push	dword file_oper
	push	dword NUMER_IRQ
	call	free_irq
	add	esp, 2*4

	; wyrejestrowanie urz±dzenia:
	push	dword nazwa
	push	dword [major]
	call	unregister_chrdev
	add	esp, 2*4

	; zwolnienie zajêtych przez nas portów
	push	dword PORTY_ILE
	push	dword PORTY_START
	push	dword ioport_resource
	call	__release_region
	add	esp, 3*4

	; zwolnienie zajêtej przez nas pamiêci
	push	dword RAM_ILE
	push	dword RAM_START
	push	dword iomem_resource
	call	__release_region
	add	esp, 3*4

	; wy¶wietlenie informacji o usuniêciu modu³u
	push	dword usun
	call	printk
	add	esp, 1*4

	pop	eax
	popfd
	ret

; nasza funkcja obs³ugi przerwania. Ta tutaj nie robi nic, ale
;	pokazuje rozmieszczenie argumentów na stosie
obsluga_irq:
	push	ebp
	mov	ebp, esp

; [ebp] = stary EBP
; [ebp+4] = adres powrotny
; [ebp+8] = arg1
; ...

		irq	equ	ebp+8
		dev_id	equ	ebp+12
		regs	equ	ebp+16

	leave
	ret


; Zdefiniowane operacje na urz±dzeniu

; Czytanie z urz±dzenia - zwracamy ¿±danej d³ugo¶ci ci±g bajtów 1Eh.
; To urz±dzenie staje siê nieskoñczonym ¼ród³em, podobnie jak /dev/zero
czytanie:
	push	ebp
	mov	ebp, esp

	; rozmieszczenie argumentów na stosie:
	s_file	equ	ebp+8	; wska¼nik na strukturê file
	bufor	equ	ebp+12	; adres bufora na dane
	l_jedn	equ	ebp+16	; ¿±dana liczba bajtów
	loff	equ	ebp+20	; ¿±dany offset czytania

	pushfd
	push	edi
	push	ecx

	mov	ecx, [l_jedn]
	mov	al, 0x1e
	cld
	mov	edi, [bufor]
	rep	stosb		; zapychamy bufor bajtami 1Eh

	pop	ecx
	pop	edi
	popfd

	mov	eax, [l_jedn]	; zwracamy tyle, ile chciano

	leave
	ret

zapis:
	push	ebp
	mov	ebp, esp

	; nic fizycznie nie zapisujemy, zwracamy tylko liczbê bajtów,
	;	któr± mieli¶my zapisaæ
	mov	eax, [l_jedn]

	leave
	ret

przejscie:
zamykanie:
otwieranie:
	xor	eax, eax
	ret



section &quot;.data&quot; writeable

major	dd	0	; numer g³ówny urz±dzenia przydzielany przez j±dro

; adresy funkcji operacji na tym urz±dzeniu
file_oper:	dd 0, przejscie, czytanie, zapis, 0, 0, 0, 0, otwieranie, 0
		dd zamykanie, 0, 0, 0, 0, 0

dev_blad	db	&quot;&lt;1&gt;Blad rejestracji urzadzenia: %d.&quot;, 10, 0
irq_blad	db	&quot;&lt;1&gt;Blad przydzielania IRQ: %d.&quot;, 10, 0
porty_blad	db	&quot;&lt;1&gt;Blad przydzielania portow:  EAX=%d&quot;, 10, 0
ram_blad	db	&quot;&lt;1&gt;Blad przydzielania pamieci: EAX=%d&quot;, 10, 0


uruch		db	&quot;&lt;1&gt;Modul zaladowany. Maj=%d, IRQ=%d&quot;, 10, 0
usun		db	&quot;&lt;1&gt;Modul usuniety.&quot;, 10, 0

nazwa		db	&quot;test00&quot;, 0
sciezka		db	&quot;/dev/test00&quot;, 0

section &quot;.modinfo&quot;
__module_kernel_version	db	&quot;kernel_version=2.4.26&quot;, 0
__module_license	db	&quot;license=GPL&quot;, 0
__module_author		db	&quot;author=Bogdan D.&quot;, 0
__module_description	db	&quot;description=Pierwszy modul jadra&quot;, 0
__module_device		db	&quot;device=test00&quot;, 0</pre>





<P><a name="sys_tut_linux03" id="sys_tut_linux03">Powy¿szy modu³</a> po kompilacji najpro¶ciej
 zainstalowaæ w j±drze stosuj±c taki oto skrypt:</P>
	<BR><a href="#sys_tut_linux04" class="bezdruk">(przeskocz skrypt instalacji)</a>

<pre title="skrypt instalacji i testowania modu³u">
#!/bin/bash

PLIK=&quot;modul_dev_fasm.o&quot;		# Tu wstawiacie swoj± nazwê
NAZWA=&quot;test00&quot;

# umieszczenie modu³u w j±drze.
/sbin/insmod $PLIK $* || { echo &quot;Problem insmod!&quot; ; exit -1; }

# wyszukanie naszej nazwy modu³u w¶ród wszystkich
/sbin/lsmod | grep `echo $PLIK | sed 's/[^a-z]/ /g' | awk '{print $1}' `
# wy¶wietlenie informacji o zajmowanych zasobach
grep $NAZWA /proc/devices
grep $NAZWA /proc/ioports
grep $NAZWA /proc/iomem
grep $NAZWA /proc/interrupts

# znalezienie i wy¶wietlenie numeru g³ównego urz±dzenia
NR=`grep $NAZWA /proc/devices | awk '{print $1}'`
echo &quot;Major = $NR&quot;

# ewentualne usuniêcie starego pliku urz±dzenia
rm -f /dev/$NAZWA

# fizyczne utworzenie pliku urz±dzenia w katalogu /dev
# wykonanie funkcji sys_mknod z modu³u NIE dzia³a
mknod /dev/$NAZWA c $NR 0
ls -l /dev/$NAZWA

# krótki test: czytanie 512 bajtów i sprawdzenie ich zawarto¶ci
dd count=1 if=/dev/$NAZWA of=/x &amp;&amp; hexdump /x &amp;&amp; rm -f /x</pre>




<P><a name="sys_tut_linux04" id="sys_tut_linux04">Wystarczy ten skrypt</a> zachowaæ na przyk³ad pod nazw±
<code>instal.sh</code>, nadaæ prawo wykonywania komend± <code>chmod u+x instal.sh</code> i uruchamiaæ poprzez
 <code>./instal.sh</code>, oczywi¶cie jako <em class="wazne">root</em>. Je¶li za³adowanie
 modu³u siê uda, skrypt wy¶wietli przydzielone modu³owi zasoby - porty, IRQ, pamiêæ - poprzez
 zajrzenie do odpowiednich plików katalogu /proc. Skrypt utworzy te¿ plik urz±dzenia w katalogu
 /dev z odpowiednim numerem g³ównym oraz wykona prosty test.</P>
<P>
Odinstalowaæ modu³ mo¿na ³atwo takim oto skryptem:</P>

<pre title="skrypt usuwaj±cy modu³">
#!/bin/bash

PLIK=&quot;modul_dev_fasm&quot;	# Tu wstawiacie swoj± nazwê, bez rozszerzenia .o
NAZWA=&quot;test00&quot;

/sbin/rmmod $PLIK &amp;&amp; rm -f /dev/$NAZWA</pre>










<Hr>
<h2 class="nag"><a name="j26" id="j26">Najprostszy modu³ j±dra 2.6</a></h2>
	<BR><a href="#j26_res" class="bezdruk" tabindex="1">(przeskocz najprostszy modu³ j±dra 2.6)</a>

<P>
Najprostszy modu³ j±dra 2.6 wygl±da tak:</P>

	<BR><a href="#sys_tut_linux05" class="bezdruk">(przeskocz kod najprostszego modu³u j±dra 2.6)</a>
<pre title="najprostszy modu³ j±dra 2.6">
format ELF
section &quot;.init.text&quot; executable	align 1
section &quot;.text&quot; executable align 4

public init_module
public cleanup_module

extrn printk

init_module:
	push	dword str1
	call	printk
	pop	eax
	xor	eax, eax
	ret

cleanup_module:
	push	dword str2
	call	printk
	pop	eax
	ret

section &quot;.modinfo&quot; align 32
__kernel_version	db	&quot;kernel_version=2.6.16&quot;, 0
__mod_vermagic db &quot;vermagic=2.6.16 686 REGPARM 4KSTACKS gcc-4.0&quot;, 0
__module_license	db	&quot;license=GPL&quot;, 0
__module_author		db	&quot;author=Bogdan D.&quot;, 0
__module_description	db	&quot;description=Pierwszy modul jadra 2.6&quot;, 0

section &quot;__versions&quot; align 32
	dd	0xfa02c634
  n1:	db	&quot;struct_module&quot;
	times	64-4-($-n1) db 0

	dd	0x1b7d4074
  n2:	db	&quot;printk&quot;
	times	64-4-($-n2) db 0

section &quot;.data&quot; writeable align 4

str1		db	&quot;&lt;1&gt; Jestem w init_module(). &quot;, 10, 0
str2		db	&quot;&lt;1&gt; Jestem w cleanup_module(). &quot;, 10, 0

section &quot;.gnu.linkonce.this_module&quot; writeable align 128

align 128
__this_module:		; ³±czna d³ugo¶æ: 512 bajtów
			dd 0, 0, 0

		.nazwa:	db &quot;modul&quot;, 0
			times 64-4-($-.nazwa) db 0

			times 100 db 0
			dd init_module
			times 220 db 0
			dd cleanup_module
			times 112 db 0</pre>

<P><a name="sys_tut_linux05" id="sys_tut_linux05">Od razu widaæ sporo ró¿nic</a>, prawda?
Omówmy je po jednej sekcji na raz:</P>
<ol>
 <li><code>.init.text</code>
 	<P>W zasadzie powinny byæ co najmniej dwie: <code>.init.text</code>, zawieraj±ca procedurê
 	inicjalizacji oraz <code>.exit.text</code>, zawieraj±ca procedurê wyj¶cia.<br><Br>
 	Dodatkowo, mo¿e byæ oczywi¶cie sekcja danych <code>.data</code> i kodu <code>.text</code>.</P>

 	<P>Je¶li podczas próby zainstalowania modu³u dostajecie komunikat <q lang="en">Accessing
 	a corrupted shared library</q> (<q>Dostêp do uszkodzonej biblioteki wspó³dzielonej</q>),
 	to pogrzebcie w sekcjach - doróbcie <code>.text</code>, usuñcie <code>.init.text</code>,
 	zamieñcie kolejno¶æ itp.
 	</P></li>

 <li><code>.gnu.linkonce.this_module</code>
 	<P>Ta jest najwa¿niejsza. Bez niej próba
 	instalacji modu³u w jadrze zakoñczy siê komunikatem <q lang="en">No module found in
 	object</q> (<q>w pliku obiektowym nie znaleziono modu³u</q>). Zawarto¶æ tej sekcji to struktura
 	typu <q>module</q> o nazwie <q>__this_module</q>. Najlepiej zrobicie, przepisuj±c tê powy¿ej
 	do swoich modu³ów, zmieniaj±c tylko nazwê modu³u oraz funkcje wej¶cia i wyj¶cia.<br><br>
 	Mo¿ecie te¿ skorzystaæ z nastêpuj±cego makra:</P>
 	<pre>	macro	gen_this_module		name*, entry, exit
	{
		section '.gnu.linkonce.this_module' writeable align 128

		align 128
		__this_module:
				dd 0, 0, 0
	   	.mod_nazwa:	db name, 0
				times 64-4-($-.mod_nazwa) db 0
				times 100 db 0
				if entry eq
					dd init_module
				else
					dd entry
				end if
				times 220 db 0
				if exit eq
					dd cleanup_module
				else
					dd exit
				end if
				times 112 db 0

	}</pre>
	<P>Korzysta siê z niego do¶æ ³atwo: wystarczy podaæ nazwê modu³u, która ma byæ wy¶wietlana
	po komendzie <code>lsmod</code> oraz nazwy procedur wej¶cia i wyj¶cia z modu³u, na przyk³ad</P>
	<pre>	gen_this_module	"nasz_modul", init_module, cleanup_module</pre>
	<P>To wywo³anie makra nale¿y umie¶ciæ tam, gdzie normalnie ta sekcja by siê znalaz³a, czyli
	na przyk³ad po ostatniej deklaracji czegokolwiek w sekcji danych.
	W ka¿dym razie <em class="wazne">NIE</em> tak, ¿eby by³o to w ¶rodku jakiejkolwiek sekcji.

 	</P></li>

 <li><code>modinfo</code>
 	<P>Sekcja ta wzbogaci³a siê w stosunku do tej z j±dra 2.4 o tylko jeden, ale
 	za to bardzo wa¿ny wpis - <q lang="en">vermagic</q>. U wiêkszo¶ci z Was ten napis
 	bêdzie siê ró¿ni³ od mojego tylko wersj± j±dra. W oryginale wygl±da on tak:</P>
		<BR><a href="#sys_tut_linux06" class="bezdruk">(przeskocz definicjê vermagic)</a>
 	<pre lang="en">	#define VERMAGIC_STRING 				\
	  UTS_RELEASE &quot; &quot;					\
	  MODULE_VERMAGIC_SMP MODULE_VERMAGIC_PREEMPT 		\
	  MODULE_ARCH_VERMAGIC 					\
	  &quot;gcc-&quot; __stringify(__GNUC__) &quot;.&quot; __stringify(__GNUC_MINOR__)
	#define MODULE_ARCH_VERMAGIC MODULE_PROC_FAMILY \
 		 MODULE_REGPARM MODULE_STACKSIZE</pre>

 	<P><a name="sys_tut_linux06" id="sys_tut_linux06">a mo¿na go znale¼æ</a> w podkatalogach asm*
	katalogu INCLUDE w ¼ród³ach j±dra oraz w pliku VERMAGIC.H.
 	</P></li>

 <li><code>__versions</code>
 	<P>Ta sekcja zawiera informacje o wersjach procedur, z których
 	nasz modu³ korzysta. Struktura jest do¶æ prosta: najpierw jako DWORD wpisujemy numerek
 	odpowiadaj±cy danej funkcji j±dra, a znaleziony w pliku <span class="b">MODULE.SYMVERS</span>
 	w katalogu g³ównym ¼róde³ jadra. Zaraz za numerkiem wpisujemy nazwê naszej funkcji,
 	dope³nion± zerami do 64 bajtów.</P>

 	<P>Ta sekcja nie jest wymagana do prawid³owej pracy modu³u, ale powinna siê w ka¿dym znale¼æ,
 	¿eby nie pojawia³y siê komunikaty o <q>zanieczyszczeniu</q> j±dra (<q lang="en">kernel tainted</q>).
 	</P>
 	<P>Ca³± tê sekcjê mo¿ecie wygenerowaæ, korzystaj±c z mojego skryptu <a href="../inne/symvers-fasm.txt"
 	>symvers-fasm.txt</a>. Wystarczy uruchomiæ <code>perl symvers-fasm.pl wasz_modul.asm</code>.
 	</P></li>
</ol>









<Hr>
<h2 class="nag"><a name="j26_res" id="j26_res">Rezerwacja zasobów w j±drze 2.6</a></h2>
	<BR><a href="#j26_ex" class="bezdruk" tabindex="1">(przeskocz rezerwacjê zasobów w j±drze 2.6)</a>

<P>
Rezerwacja zasobów w j±drze 2.6 z zewn±trz (czyli z perspektywy jêzyka C) nie ró¿ni siê od tej
 z j±dra 2.4. Ale tak naprawdê zasz³y dwie istotne zmiany:</P>
<ol>
 <li>Struktura <span lang="en">file_operations</span>
	<P>W j±drze 2.6 wygl±da tak:</P>
	<BR><a href="#sys_tut_linux07" class="bezdruk">(przeskocz strukturê <span lang="en">file_operations</span> w j±drze 2.6)</a>
 	<pre title="struktura file_operations j±dra 2.6" lang="en">
	struct file_operations {
		struct module *owner;
		loff_t (*llseek) (struct file *, loff_t, int);
		ssize_t (*read) (struct file*,char __user*,size_t,
			loff_t*);
		ssize_t (*aio_read) (struct kiocb *, char __user *,
			size_t, loff_t);
		ssize_t (*write) (struct file *, const char __user *,
			size_t, loff_t *);
		ssize_t (*aio_write) (struct kiocb *, const char __user*,
			size_t, loff_t);
		int (*readdir) (struct file *, void *, filldir_t);
		unsigned int (*poll) (struct file *,
			struct poll_table_struct *);
		int (*ioctl) (struct inode *, struct file *,
			unsigned int, unsigned long);
		long (*unlocked_ioctl) (struct file *, unsigned int,
			unsigned long);
		long (*compat_ioctl) (struct file *, unsigned int,
			unsigned long);
		int (*mmap) (struct file *, struct vm_area_struct *);
		int (*open) (struct inode *, struct file *);
		int (*flush) (struct file *);
		int (*release) (struct inode *, struct file *);
		int (*fsync) (struct file *, struct dentry *,
			int datasync);
		int (*aio_fsync) (struct kiocb *, int datasync);
		int (*fasync) (int, struct file *, int);
		int (*lock) (struct file *, int, struct file_lock *);
		ssize_t (*readv) (struct file *, const struct iovec *,
			unsigned long, loff_t *);
		ssize_t (*writev) (struct file *, const struct iovec *,
			unsigned long, loff_t *);
		ssize_t (*sendfile) (struct file *, loff_t *, size_t,
			read_actor_t, void *);
		ssize_t (*sendpage) (struct file *, struct page *, int,
			size_t, loff_t *, int);
		unsigned long (*get_unmapped_area)(struct file *,
			unsigned long, unsigned long, unsigned long,
			unsigned long);
		int (*check_flags)(int);
		int (*dir_notify)(struct file *filp, unsigned long arg);
		int (*flock) (struct file *, int, struct file_lock *);
	};</pre>
 	</li>

 <li><a name="sys_tut_linux07" id="sys_tut_linux07">Sposób przekazywania parametrów</a>
 	<P>Moje j±dro dystrybucyjne zosta³o skompilowane tak, ¿eby trzy pierwsze parametry do ka¿dej
 	procedury <span class="b">z wyj±tkiem printk</span> przekazywa³o w rejestrach:
 	EAX, EDX, ECX, a resztê na stosie. Aby sprawdziæ, czy u Was te¿ tak jest, wykonajcie komendy:</P>
 	<pre>	grep -R regpar /lib/modules/`uname -r`/build/|grep Makefile
 	grep -R REGPAR /lib/modules/`uname -r`/build/|grep config</pre>
 	<P>Je¶li ich wyniki zawieraj± takie co¶:</P>
 	<pre> 	CONFIG_REGPARM=y
 	#define CONFIG_REGPARM 1</pre>
 	<P>to prawdopodobnie te¿ tak macie. Mo¿ecie wtedy bez przeszkód u¿ywaæ makra URUCHOM, które
 	umieszczê w module poni¿ej. Je¶li nie, mo¿ecie je zmodyfikowaæ. Potrzeba modyfikacji
 	mo¿e wynikaæ z zawieszania siê ca³ego systemu podczas próby zainstalowania modu³u.
 	</P></li>
</ol>








<Hr>
<h2 class="nag"><a name="j26_ex" id="j26_ex">Przyk³ad modu³u j±dra 2.6</a></h2>
	<BR><a href="#j26_wytlum" class="bezdruk" tabindex="1">(przeskocz przyk³ad modu³u j±dra 2.6)</a>

<P>
Podobnie, jak w j±drze 2.4, pokazany ni¿ej program zarejestruje programowe
 urz±dzenie znakowe (czyli takie, dla którego
 nie ma odpowiednika w sprzêcie, jak na przyk³ad /dev/null) z IRQ 4, zakresem portów 600h-6FFh,
 zakresem pamiêci 80000000h - 8000FFFFh oraz z podstawowymi operacjami: otwieranie, zamykanie,
 czytanie, zapis, zmiana pozycji. Dla uproszczenia kodu nie sprawdzam, czy dane zakresy s±
 wolne. Je¶li oka¿± siê zajête, j±dro zwróci b³±d i modu³ siê nie za³aduje.</P>


<pre title="przyk³adowy modu³ j±dra 2.6">
format ELF
section &quot;.text&quot; executable align 4

public	init_module
public	cleanup_module

extrn	printk
extrn	register_chrdev
extrn	unregister_chrdev
extrn	request_irq
extrn	free_irq

extrn	__request_region
extrn	__release_region
extrn	ioport_resource
extrn	iomem_resource

PORTY_START	= 0x600
PORTY_ILE	= 0x100

RAM_START	= 0x80000000
RAM_ILE		= 0x00010000

SA_INTERRUPT	= 0x20000000
NUMER_IRQ	= 4

macro	uruchom		funkcja, par1, par2, par3, par4, par5
{
	if ~ par5 eq
		push	dword par5
	end if
	if ~ par4 eq
		push	dword par4
	end if
	if ~ par3 eq
		mov	ecx, par3
	end if
	if ~ par2 eq
		mov	edx, par2
	end if
	if ~ par1 eq
		mov	eax, par1
	end if
	call	funkcja
	if ~ par5 eq
		add	esp, 4
	end if
	if ~ par4 eq
		add	esp, 4
	end if
}

init_module:
	pushfd

	; rejestrowanie urz±dzenia znakowego:
	uruchom	register_chrdev, 0, nazwa, file_oper

	cmp	eax, 0
	jg	.dev_ok

	; wy¶wietlenie informacji o b³êdzie
	push	eax
	push	dword dev_blad
	call	printk
	add	esp, 1*4		; specjalnie tylko 1*4

	pop	eax			; wychodzimy z oryginalnym b³êdem
	jmp	.koniec

.dev_ok:

	mov	[major], eax

	; rejestrowanie zakresu portów
 uruchom __request_region, ioport_resource, PORTY_START, PORTY_ILE, nazwa

	test	eax, eax
	jnz	.iop_ok

	push	eax
	push	dword porty_blad
	call	printk
	add	esp, 1*4		; potem pop eax

	; wyrejestrowanie urz±dzenia
	uruchom	unregister_chrdev, [major], nazwa

	pop	eax			; wychodzimy z oryginalnym b³êdem
	jmp	.koniec

.iop_ok:

	; rejestrowanie zakresu pamiêci
	uruchom	__request_region, iomem_resource, RAM_START, RAM_ILE, nazwa

	test	eax, eax
	jnz	.iomem_ok

	push	eax
	push	dword ram_blad
	call	printk
	add	esp, 1*4		; potem pop eax

	; wyrejestrowanie urz±dzenia
	uruchom	unregister_chrdev, [major], nazwa

	; wyrejestrowanie zakresu portów
	uruchom	__release_region, ioport_resource, PORTY_START, PORTY_ILE

	pop	eax			; wychodzimy z oryginalnym b³êdem
	jmp	.koniec

.iomem_ok:

	; przydzielanie przerwania IRQ:
 uruchom request_irq, NUMER_IRQ, obsluga_irq, SA_INTERRUPT, nazwa, file_oper

	cmp	eax, 0
	jge	.irq_ok

	push	eax
	push	dword irq_blad
	call	printk
	add	esp, 1*4		; potem pop eax

	; wyrejestrowanie urz±dzenia
	uruchom	unregister_chrdev, [major], nazwa

	; wyrejestrowanie zakresu portów
	uruchom	__release_region, ioport_resource, PORTY_START, PORTY_ILE

	; wyrejestrowanie zakresu pamiêci
	uruchom	__release_region, iomem_resource, RAM_START, RAM_ILE

	pop	eax			; wychodzimy z oryginalnym b³êdem
	jmp	.koniec

.irq_ok:

	; wy¶wietlenie informacji o za³adowaniu modu³u
	push	dword NUMER_IRQ
	push	dword [major]
	push	dword uruch
	call	printk
	add	esp, 3*4

	xor	eax, eax

.koniec:

	popfd
	ret

; funkcja uruchamiana przy usuwaniu modu³u
cleanup_module:
	pushfd
	push	eax

	; zwolnienie numeru IRQ:
	uruchom	free_irq, NUMER_IRQ, file_oper

	; wyrejestrowanie urz±dzenia:
	uruchom	unregister_chrdev, [major], nazwa

	; wyrejestrowanie zakresu portów
	uruchom	__release_region, ioport_resource, PORTY_START, PORTY_ILE

	; wyrejestrowanie zakresu pamiêci
	uruchom	__release_region, iomem_resource, RAM_START, RAM_ILE

	push	dword usun
	call	printk
	add	esp, 1*4

	pop	eax
	popfd
	ret

; deklaracja wygl±da tak:
; void handler (int irq, void *dev_id, struct pt_regs *regs);
; ostatni argument zwykle nieu¿ywany

section &quot;.text&quot; executable align 4

obsluga_irq:
	push	ebp
	mov	ebp, esp

	; tu Wasz kod

	leave
	ret

; Zdefiniowane operacje:

czytanie:
;	ssize_t (*read) (struct file *, char *, size_t, loff_t *);
	push	ebp
	mov	ebp, esp

	loff	equ	ebp+8

	pushfd
	push	edi
	push	ecx

	mov	al, 0x1e
	cld
	mov	edi, edx
	rep	stosb

	pop	ecx
	pop	edi
	popfd

	; mówimy, ¿e przeczytano tyle bajtów, ile ¿±dano
	mov	eax, ecx

	leave
	ret

zapis:
;	ssize_t (*write) (struct file *, const char *, size_t, loff_t *);
	push	ebp
	mov	ebp, esp

	; nic fizycznie nie zapisujemy, zwracamy tylko liczbê bajtów,
	;	któr± mieli¶my zapisaæ (trzeci parametr)
	mov	eax, ecx

	leave
	ret

przejscie:
zamykanie:
otwieranie:
	xor	eax, eax
	ret



section &quot;.data&quot; writeable align 4

major	dd	0	; numer g³ówny urz±dzenia przydzielany przez j±dro

; adresy funkcji operacji na tym urz±dzeniu
file_oper:	dd 0, przejscie, czytanie, 0, zapis, 0, 0, 0, 0, 0, 0, 0
		dd otwieranie, 0, zamykanie, 0, 0, 0, 0, 0, 0, 0, 0, 0
		dd 0, 0, 0
		dd 0, 0, 0

dev_blad	db	&quot;&lt;1&gt;Blad rejestracji urzadzenia: %d.&quot;, 10, 0
irq_blad	db	&quot;&lt;1&gt;Blad przydzielania IRQ: %d.&quot;, 10, 0
porty_blad	db	&quot;&lt;1&gt;Blad przydzielania portow:  EAX=%d&quot;, 10, 0
ram_blad	db	&quot;&lt;1&gt;Blad przydzielania pamieci: EAX=%d&quot;, 10, 0


uruch		db	&quot;&lt;1&gt;Modul zaladowany. Maj=%d, IRQ=%d&quot;, 10, 0
usun		db	&quot;&lt;1&gt;Modul usuniety.&quot;, 10, 0

nazwa		db	&quot;test00&quot;, 0, 0
sciezka		db	&quot;/dev/test00&quot;, 0

section &quot;.modinfo&quot; align 32
__kernel_version	db	&quot;kernel_version=2.6.16&quot;, 0
__mod_vermagic db &quot;vermagic=2.6.16 686 REGPARM 4KSTACKS gcc-4.0&quot;,0
__module_license	db	&quot;license=GPL&quot;, 0
__module_author		db	&quot;author=Bogdan D.&quot;, 0
__module_description	db	&quot;description=Pierwszy modul jadra 2.6&quot;, 0
__module_device		db	&quot;device=test00&quot;, 0
__module_depends	db	&quot;depends=&quot;, 0

; nieistotne, wziête ze skompilowanego modu³u C:
__mod_srcversion	db	&quot;srcversion=F5CE0CFFE0191EDB2F816D4&quot;, 0

section &quot;__versions&quot; align 32

____versions:
	dd	0xfa02c634		; Z MODULE.SYMVERS
  n1:	db	&quot;struct_module&quot;, 0
	times	64-4-($-n1) db 0

	dd	0x1b7d4074
  n2:	db	&quot;printk&quot;, 0
	times	64-4-($-n2) db 0

	dd	0xb5145e00
  n3:	db	&quot;register_chrdev&quot;, 0
	times	64-4-($-n3) db 0

	dd	0xc192d491
  n4:	db	&quot;unregister_chrdev&quot;, 0
	times	64-4-($-n4) db 0

	dd	0x26e96637
  n5:	db	&quot;request_irq&quot;, 0
	times	64-4-($-n5) db 0

	dd	0xf20dabd8
  n6:	db	&quot;free_irq&quot;, 0
	times	64-4-($-n6) db 0

	dd	0x1a1a4f09
  n7:	db	&quot;__request_region&quot;, 0
	times	64-4-($-n7) db 0

	dd	0xd49501d4
  n8:	db	&quot;__release_region&quot;, 0
	times	64-4-($-n8) db 0

	dd	0x865ebccd
  n9:	db	&quot;ioport_resource&quot;, 0
	times	64-4-($-n9) db 0

	dd	0x9efed5af
  n10:	db	&quot;iomem_resource&quot;, 0
	times	64-4-($-n10) db 0


section &quot;.gnu.linkonce.this_module&quot; writeable align 128

align 128
__this_module:		; ³±czna d³ugo¶æ: 512 bajtów
			dd 0, 0, 0
	.mod_nazwa:	db &quot;modul_dev_fasm&quot;, 0
			times 64-4-($-.mod_nazwa) db 0
			times 100 db 0
			dd init_module
			times 220 db 0
			dd cleanup_module
			times 112 db 0</pre>


<P><a name="j26_wytlum" id="j26_wytlum">Do instalacji i usuwania modu³u z j±dra</a> mo¿na u¿yæ
 tych samych <a href="#sys_tut_linux03" hreflang="pl">skryptów</a>, które by³y dla j±dra 2.4, zmieniaj±c
 ewentualnie nazwê pliku modu³u.</P>



<br>
<div class="bezdruk">
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

</BODY></HTML>
