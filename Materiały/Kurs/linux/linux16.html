<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks, czê¶æ 16 - £añcuchy znaków </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Prev"     hreflang="pl" lang="en" href="linux15.html" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="kurs, asm, asembler, assembler, regex, wyra¿enia regularne,
	REP, REPE, REPNE, REPZ, REPNZ, CMPS, SCAS, LODS, STOS, MOVS, linux, linuks">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Tue, Jan 18 2011 17:59:58 CEST">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler pod Linuksem?<BR>
	<h1 class="nag">Czê¶æ 16 - Operacje na ³añcuchach znaków. Wyra¿enia regularne</h1></div>

<P>
Jak wiemy, ³añcuch znaków to nic innego jak jednowymiarowa tablica bajtów. Dlatego podane tutaj
informacje tak samo dzia³aj± dla tablic.
</P>

<P>
W zestawie instrukcji procesora przeznaczonych jest klika rozkazów przeznaczonych specjalnie
do operacji na ³añcuchach znaków: <code>MOVS</code>, <code>CMPS</code>, <code>SCAS</code>,
<code>LODS</code>, <code>STOS</code>. To nimi w³a¶nie teraz siê zajmiemy.</P>
<P>
Rozkazy te operuj± na ³añcuchach spod DS:[ESI/RSI] lub ES:[EDI/RDI] lub obydwu. Rejestry
segmentowe nie bêd± tutaj graæ du¿ej roli bo pokazuj± zawsze na ten sam segment, wiêc bêdziemy
 je pomijaæ. Oraz, zajmiemy siê omówieniem instrukcji tylko na ESI oraz EDI, pomijaj±c rejestry 64-bitowe,
 dla których wszystko wygl±da analogicznie.
</P>
<P>
Instrukcje wystêpuj± w 4 formach: *B, *W, *D (dla 32-bitowych) i *Q (dla 64-bitowych).
Operuj± one odpowiednio na bajtach, s³owach, podwójnych s³owach i danych 64-bitowych.
Po ka¿dym wykonaniu pojedynczej operacji zwiêkszaj± rejestry
SI/ESI/RSI i DI/EDI/RDI o 1, 2, 4 lub 8, przechodz±c tym samym na nastêpne elementy.
</P>
<P>
<em class="wazne">UWAGA:</em> Zwiêkszaniem rejestrów *SI i *DI steruje flaga kierunku DF: je¶li równa 0,
oba rejestry s± zwiêkszane, je¶li 1 - s± zmniejszane o odpowiedni± liczbê (co pozwala na przyk³ad na
przeszukiwanie ³añcuchów wspak). Flagê DF mo¿na wyczy¶ciæ instrukcj± CLD, a ustawiæ instrukcj±
STD.
</P>





<BR><BR>
<HR>
<h2 class="nag">MOVS</h2>

	<BR><a href="#cmps" tabindex="1" class="bezdruk">(przeskocz MOVS)</a>
<P>
Zasad± dzia³ania tej instrukcji jest przeniesienie odpowiedniej ilo¶ci bajtów spod [ESI] i
umieszczenie ich pod [EDI]. Ale przeniesienie co najwy¿ej 4 bajtów to przecie¿ ¿aden wysi³ek:</P>
<PRE>
	mov	eax, [esi]
	mov	[edi], eax</PRE>

<P>Dlatego wymy¶lono prefiks <code>REP</code> (powtarzaj). Jest on wa¿ny tylko dla instrukcji operuj±cych na
³añcuchach znaków oraz instrukcji <code>INS</code> i <code>OUTS</code>. Powoduje on powtórzenie
dzia³ania instrukcji ECX razy. Teraz ju¿ widaæ mo¿liwo¶ci tej instrukcji. Chcemy przenie¶æ 128 bajtów? Proszê
bardzo:</P>
<PRE title="przyk³ad u¿ycia MOVS">
	mov	esi, zrodlo
	mov	edi, cel
	cld				; id¼ do przodu
	mov	ecx, 128
	rep	movsb</PRE>

<P>Oczywi¶cie, dwie ostatnie linijki mo¿na by³o zast±piæ czym¶ takim i te¿ by podzia³a³o:</P>
<PRE>
	mov	ecx, 32
	rep	movsd</PRE>

<P>Sposób drugi oczywi¶cie jest lepszy, bo ma mniej operacji (choæ najwiêcej czasu i tak zajmuje
 samo rozpêdzenie siê instrukcji <code>REP</code>).</P>
<P>
Instrukcji <code>REP MOVS*</code> mo¿na u¿ywaæ do przenoszenia ma³ej ilo¶ci danych. Gdy ilo¶ci danych rosn±,
lepiej sprawuj± siê MMX i SSE (patrz: <a href="linux06.html" hreflang="pl">czê¶æ 6</a>).
</P>








<BR><BR>
<HR>
	<h2 class="nag"><a name="cmps" id="cmps">CMPS</a></h2>

	<BR><a href="#scas" class="bezdruk">(przeskocz CMPS)</a>
<P>
Ta instrukcja porównuje odpowiedni± liczbê bajtów spod [ESI] i [EDI]. Ale nas oczywi¶cie nie
interesuje porównywanie pojedynczych ilo¶ci. My¶limy wiêc o prefiksie <code>REP</code>, ale po chwili
zastanowienia dochodzimy do wniosku, ¿e w ten sposób otrzymamy tylko wynik ostatniego porównania,
wszystkie wcze¶niejsze zostan± zaniedbane. Dlatego wymy¶lono prefiksy <code>REPE/REPZ</code> (powtarzaj,
dopóki równe/flaga ZF ustawiona) oraz <code>REPNE/REPNZ</code> (powtarzaj, dopóki nie równe/flaga ZF = 0).
<BR>
Na przyk³ad, aby sprawdziæ równo¶æ dwóch ³añcuchów, zrobimy tak:</P>
<PRE title="przyk³ad u¿ycia CMPS">
	mov	esi, lancuch1
	mov	edi, lancuch2

	mov	ecx, 256	; tyle bajtów maksymalnie chcemy porównaæ
	cld
	repe	cmpsb		; dopóki s± równe, porównuj dalej
	jnz	lancuchy_nie_rowne</PRE>

<P><code>REPE</code> przestanie dzia³aæ na pierwszych ró¿ni±cych siê bajtach. W ECX otrzymamy pewn± liczbê.
Ró¿nica liczby 256 i tej liczby mówi o ilo¶ci identycznych znaków i jednocze¶nie o tym, na
której pozycji znajduj± siê ró¿ni±ce siê znaki.<BR>
Oczywi¶cie, je¶li po ukoñczeniu <code>REPE</code> rejestr ECX=0, to znaczy ¿e sprawdzono wszystkie znaki
(i wszystkie dotychczas by³y równe). Wtedy flagi mówi± o ostatnim porównaniu.<BR>
<code>REPE CMPS</code> ustawia flagi jak normalna instrukcja <code>CMP</code>.</P>








<BR><BR>
<HR>
	<h2 class="nag"><a name="scas" id="scas">SCAS</a></h2>

	<BR><a href="#lods" class="bezdruk">(przeskocz SCAS)</a>
<P>
Ta instrukcja przeszukuje ³añcuch znaków pod [EDI] w poszukiwaniu bajtu z AL, s³owa z AX lub
podwójnego s³owa z EAX. S³u¿y to do szybkiego znalezienia pierwszego wyst±pienia danego
elementu w ³añcuchu.<BR>
Przyk³ad: znale¼æ pozycjê pierwszego wyst±pienia litery Z w ³añcuchu <q>lancuch1</q>:</P>
<PRE title="przyk³ad u¿ycia SCAS">
	mov	al, &quot;Z&quot;		; poszukiwany element
	mov	edi, lancuch1
	mov	ecx, 256
	cld
	repne	scasb		; dopóki sprawdzany znak ró¿ny
				; od &quot;Z&quot;, szukaj dalej

	je	znaleziono

	mov	edi, -1		; gdy nie znaleziono, zwracamy -1
	jmp	koniec

    znaleziono:
	sub	edi, lancuch1	; EDI = pozycja znalezionego znaku w ³añcuchu</PRE>

<P><code>REPNE</code> przestanie dzia³aæ w dwóch przypadkach: ECX=0 (wtedy nie znaleziono szukanego elementu)
oraz wtedy, gdy ZF=1 (gdy po drodze natrafi³a na szukany element, wynik porównania ustawi³ flagê ZF).</P>








<BR><BR>
<HR>
	<h2 class="nag"><a name="lods" id="lods">LODS</a></h2>

	<BR><a href="#stos" class="bezdruk">(przeskocz LODS)</a>
<P>
Instrukcje <code>LODS*</code> pobieraj± do AL/AX/EAX odpowiedni± liczbê bajtów spod [ESI]. Jak widaæ,
prefiksy <code>REP*</code> nie maj± tutaj sensu, bo w rejestrze docelowym i tak zawsze wyl±duje ostatni
element.<BR>
Ale za to tej instrukcji mo¿na u¿ywaæ do pobierania poszczególnych znaków do dalszego
sprawdzania, na przyk³ad</P>
<PRE title="przyk³ad u¿ycia LODS">
	cld
    petla:
	lodsb				; pobierz kolejny znak

	cmp	al, 13
	jne	nie_enter

	cmp	al, &quot;0&quot;
	je	al_to_zero

	....

	loop	petla</PRE>









<BR><BR>
<HR>
	<h2 class="nag"><a name="stos" id="stos">STOS</a></h2>

	<BR><a href="#regex" class="bezdruk">(przeskocz STOS)</a>
<P>
Instrukcja ta umieszcza AL/AX/EAX pod [EDI]. Poza oczywistym zastosowaniem, jakim jest na przyk³ad
zapisywanie kolejnych podawanych przez u¿ytkownika znaków gdzie¶ do tablicy, <code>STOS</code> mo¿na te¿
u¿yæ do szybkiej inicjalizacji tablicy w czasie dzia³ania programu lub do wyzerowania pamiêci:</P>
<PRE>
	mov	edi, tablica

	mov	eax, 11223344h
	mov	ecx, 1000
	cld
	rep	stosd
	...

	tablica: times 1000 dd 0</PRE>






<BR><BR>
<HR>
	<h2 class="nag"><a name="regex" id="regex">Wyra¿enia regularne</a></h2>
<P>
Wyra¿enia regularne (<span lang="en">regular expressions</span>, regex) to po prostu ci±gi znaczków,
 przy u¿yciu których mo¿emy opisywaæ dowolne
³añcuchy znaków (adresy <span lang="en">e-mail</span>,
<acronym lang="en" title="World Wide Web">WWW</acronym>, nazwy plików z pe³nymi ¶cie¿kami, ...).<BR>
Na wyra¿enie regularne sk³adaj± siê ró¿ne symbole. Postaram siê je teraz po krótce omówiæ.</P>
<UL>
 <LI> <q>aaa</q> (dowolny ci±g znaków) - reprezentuje wszystkie ³añcuchy, które go zawieraj±, na przyk³ad
	<q>laaaaaaaaaato</q>.</LI>
 <LI> ^ - oznacza pocz±tek linii (wiersza). Na przyk³ad wyra¿enie <q>^asembler</q> reprezentuje
	wszystkie linie, które zaczynaj± siê od ci±gu znaków <q>asembler</q>. Innymi s³owy, ka¿da
	linia zaczynaj±ca siê od <q>asembler</q> pasuje do tego wyra¿enia.</LI>
 <LI> $ - oznacza koniec linii. Na przyk³ad wyra¿enie <q>asm$</q> reprezentuje wszystkie linie,
	które koñcz± siê na <q>asm</q>.</LI>
 <LI> . (kropka) - dowolny znak (z wyj±tkiem znaku nowej linii). Na przyk³ad wyra¿enie
	<q>^a.m$</q> reprezentuje linie, które zawieraj± w sobie tylko a*m, gdzie gwiazdka to
	dowolny znak (w tym cyfry). Do tego wzorca pasuj± <q>asm</q>, <q>aim</q>, <q>a0m</q>
	i wiele innych.
	</LI>
 <LI> | (Shift+BackSlash)- oznacza alternatywê. Na przyk³ad wyra¿enie <q>a|b|z</q> reprezentuje
	dowoln± z tych trzech liter i ¿adn± inn±.</LI>
 <LI> (,) - nawiasy s³u¿± do grupowania wyrazów. Na przyk³ad <q>^(aa)|(bb)|(asm)</q> reprezentuje
	linie, które zaczynaj± siê od <q>aa</q>, <q>bb</q> lub <q>asm</q>.</LI>
 <LI> [,] - wyznaczaj± klasê znaków. Na przyk³ad wszystkie wyrazy zaczynaj±ce siê od <q>k</q>, <q>a</q> lub
	<q>j</q> pasuj± do wzorca <q>[ajk].*</q>. Mo¿na tutaj podawaæ przedzia³y znaków - wtedy 2 skrajne
	znaki oddzielamy my¶lnikiem, na przyk³ad <q>[a-z]</q>. Umieszczenie w ¶rodku znaku daszka ^ oznacza
	przeciwieñstwo, na przyk³ad <q>[^0-9]</q> reprezentuje znaki, które nie s± cyfr± (a tym samym
	wszystkie ci±gi nie zawieraj±ce cyfr).</LI>
 <LI> ? - oznacza co najwy¿ej jedno wyst±pienie poprzedzaj±cego znaku lub grupy. Na przyk³ad,
	<q>ko?t</q> reprezentuje wyrazy <q>kot</q> i <q>kt</q>, ale ju¿ nie <q>koot</q>.</LI>
 <LI> * - oznacza dowoln± liczbê wyst±pieñ poprzedzaj±cego znaku/grupy. Wyra¿enie <q>ko*t</q>
	reprezentuje wiêc wyrazy <q>kt</q>, <q>kot</q>, <q>koot</q>, <q>kooot</q>, itd.</LI>
 <LI> + - oznacza co najmniej jedno wyst±pienie poprzedzaj±cego znaku/grupy. Na przyk³ad
	<q>al(fa)+</q> reprezentuje <q>alfa</q>, <q>alfafa</q>, <q>alfafafa</q> itd, ale nie <q>al</q>.</LI>
 <LI> {n} - oznacza dok³adnie n wyst±pieñ poprzedzaj±cego znaku/grupy. Wyra¿enie
	<q>[0-9]{7}</q> reprezentuje wiêc dowolny ci±g sk³adaj±cy siê dok³adnie z 7 cyfr.</LI>
 <LI> {n,} - oznacza co najmniej n wyst±pieñ poprzedzaj±cego znaku/grupy. Wyra¿enie
	<q>[a-z]{2,}</q> reprezentuje wiêc dowolny ci±g znaków sk³adaj±cy siê co najmniej z 2 ma³ych
	liter.</LI>
 <LI> {n,m} - oznacza co najmniej n i co najwy¿ej m wyst±pieñ poprzedzaj±cego znaku/grupy.
	Wiêc wyra¿enie <q>[A-M]{3,7}</q> reprezentuje dowolny ci±g znaków sk³adaj±cy siê
	z co najmniej 3 i co najwy¿ej 7 wielkich liter z przedzia³u od A do M.</LI>
 <LI>Je¶li w ³añcuchu mo¿e wyst±piæ który¶ ze znaków specjalnych, nale¿y go w wyra¿eniu
	poprzedziæ odwrotnym uko¶nikiem <q>\</q>.</LI>
</UL>
<P>Dalsze przyk³ady:</P>
<UL>
 <LI> ([a-zA-Z0-9]+\.?)+[a-zA-Z]+@([a-zA-Z0-9]+\.)+[a-zA-Z]{2,4} - adres e-mail (zapisany
	tak, by login ani domena nie koñczy³y siê kropk±)</LI>
 <LI> ([a-zA-Z]{3,6}://)?([a-zA-Z0-9/\-]+\.?)+[a-zA-Z0-9]+(#[a-zA-Z0-9\-]+)? - adres
	(z protoko³em lub bez)
	zasobu na serwerze (zapisany tak, by nie koñczy³ siê kropk±, mo¿e zawieraæ my¶lniki
	a w ostatnim cz³onie tak¿e znak #)</LI>
</UL>

<br><br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="linux15.html">Poprzednia czê¶æ kursu</a> (Alt+3)<br>
<a accesskey="4" hreflang="pl" href="linux17.html">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>


<HR>
<h2 class="nag">Æwiczenia</h2>
<OL>
 <LI>Napisaæ program zawieraj±cy 2 tablice DWORDów o wymiarach 17 na 31, po czym w trakcie
	dzia³ania programu wype³niæ ka¿de pole pierwszej warto¶ci± FFEEDDCCh. Potem, 8
	pierwszych elementów skopiowaæ do drugiej tablicy, a resztê drugiej wype³niæ warto¶ci±
	BA098765h. Wtedy porównaæ zawarto¶æ obu tablic i wyliczyæ pierwsz± pozycjê, na której
	siê ró¿ni± (powinna oczywi¶cie wynosiæ 9)<BR><BR></LI>
 <LI>Napisaæ wyra¿enie regularne, które opisze:
  <UL>
   <LI>wszystkie wyra¿enia deklaracji zmiennych: DB, DW, DP, DQ, DT</LI>
   <LI>znacznik HTML bez atrybutów, czyli co¶ wygl±daj±ce tak:
   	&lt; PRE &gt; lub tak: &lt; /LI &gt; (bez spacji).</LI>
   <LI>liczbê szesnastkow± dowolnej niezerowej d³ugo¶ci z ewentualnym przedrostkiem <q>0x</q> albo
	(do wyboru) przyrostkiem <q>H</q> lub <q>h</q>.</LI>

  </UL></LI>
</OL>


</BODY></HTML>
