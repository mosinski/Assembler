<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks, czê¶æ 7 - Porty </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Prev"     hreflang="pl" lang="en" href="linux06.html" >
<link rel="Next"     hreflang="pl" lang="en" href="linux08.html" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="linux, linuks, kurs, asm, assembler, asembler, porty, CMOS">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Mon, Oct 29 2012 17:22:20 CEST">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler pod Linuksem?<BR>
	<h1 class="nag">Czê¶æ 7 - Porty, czyli ³±czno¶æ miêdzy procesorem a innymi urz±dzeniami</h1>
	</div>

<P>
Nie zastanawiali¶cie siê kiedy¶, jak procesor komunikuje siê z tymi wszystkimi urz±dzeniami,
które znajduj± siê w komputerze?<BR>
Teraz zajmiemy siê w³a¶nie sposobem, w jaki procesor uzyskuje dostêp do urz±dzeñ zewnêtrznych
 (zewnêtrznych dla procesora, niekoniecznie tych znajduj±cych siê poza obudow± komputera).
</P>
<P>
Mimo ¿e procesor mo¿e porozumiewaæ z urz±dzeniami przez wydzielone obszary
<acronym title="Random Access Memory" lang="en">RAM</acronym>-u,
to g³ównym sposobem komunikacji (gdy nie chcemy lub nie mo¿emy u¿ywaæ sterowników)
ci±gle pozostaj± porty. Je¶li chcecie, mo¿ecie wykonaæ komendê
 <q lang="en">cat /proc/ioports</q>, która powie, które urz±dzenie zajmuje które porty.
</P>
<P>
Porty s± to specjalne adresy, pod które procesor mo¿e wysy³aæ dane. Stanowi± oddzieln±
<q>strefê</q> adresow± (16-bitow±, jak dalej zobaczymy, wiêc najwy¿szy teoretyczny numer portu
wynosi 65535), choæ czasami do niektórych portów mo¿na dostaæ siê przez pamiêæ RAM. S± to
porty mapowane do pamiêci (<span lang="en">memory-mapped</span>), którymi nie bêdziemy siê zajmowaæ.
</P>
<P>
Lista przerwañ Ralfa <span lang="en">Brown</span>'a
(<A HREF="http://www-2.cs.cmu.edu/afs/cs.cmu.edu/user/ralf/pub/WWW/files.html" hreflang="en" tabindex="1"
 ><acronym title="Ralf Brown's Interrupt List" lang="en">RBIL</acronym></A>)
 zawiera plik ports.lst (który czasami trzeba osobno
utworzyæ - szczegó³y w dokumentacji). W pliku tym znajduj± siê szczegó³y dotycz±ce
ca³kiem sporej liczby portów odpowiadaj±cym ró¿nym urz±dzeniom. I tak, mamy na przyk³ad</P>
<UL>
 <LI>Kontrolery <acronym title="Direct Memory Access" lang="en">DMA</acronym></LI>
 <LI>Programowalny kontroler przerwañ (<span lang="en">Programmable Interrupt Controller</span>, PIC)</LI>
 <LI>Programowalny czasomierz (<span lang="en">Programmable Interval Timer</span>, PIT)</LI>
 <LI>Kontroler klawiatury</LI>
 <LI><acronym title="Complementary Metal-Oxide Semiconductor" lang="en">CMOS</acronym></LI>
 <LI><span lang="en">SoundBlaster</span> i inne karty d¼wiêkowe</LI>
 <LI>Karty graficzne i inne karty rozszerzeñ (na przyk³ad modem)</LI>
 <LI>Porty COM, LPT</LI>
 <LI>Kontrolery dysków twardych</LI>
 <LI>i wiele, wiele innych...</LI>
</UL>

<P>
No dobrze, wiemy co ma który port i tak dalej, ale jak z tego skorzystaæ?
</P>
<P>
Procesor posiada dwie instrukcje przeznaczone specjalnie do tego celu.
S± to <code>IN</code> i <code>OUT</code>.<BR>
Ich podstawowa sk³adnia wygl±da tak:</P>
<PRE title="sk³adnia instrukcji IN oraz OUT">
	in al/ax/eax, numer_portu
	out numer_portu, al/ax/eax</PRE>

<P>Uwagi:</P>
<OL>
 <LI>Je¶li numer_portu jest wiêkszy ni¿ 255, to w jego miejsce musimy u¿yæ rejestru DX</LI>
 <LI>Do operacji na portach nie mo¿na u¿ywaæ innych rejestrów ni¿ AL, AX lub EAX.
 <LI>Wczytane ilo¶ci bajtów zale¿± od rejestru, a ich pochodzenie - od rodzaju portu:
  <ul>
   <li>je¶li port <CODE>num</code> jest 8-bitowy, to<br>
    <CODE>IN AL, num</CODE>  wczyta 1 bajt z portu o numerze <CODE>num</code><br>
    <CODE>IN AX, num</CODE>  wczyta 1 bajt z portu <CODE>num</code> (do AL) i
      1 bajt z portu <CODE>num+1</code> (do AH)<br>
    <CODE>IN EAX, num</CODE>  wczyta po 1 bajcie z portów <CODE>num</code>, <CODE>num+1</code>,
      <CODE>num+2</code> i <CODE>num+3</code>
      i umie¶ci w odpowiednich czê¶ciach rejestru EAX (od najm³odszej)
    </LI>
   <li>je¶li port <CODE>num</code> jest 16-bitowy, to<br>
    <CODE>IN AX, num</CODE> wczyta 2 bajty z portu o numerze <CODE>num</code><br>
    <CODE>IN EAX, num</CODE> wczyta 2 bajty z portu o numerze <CODE>num</code> i 2 bajty z portu
      o numerze <CODE>num+1</code>
    </LI>
   <li>je¶li port <CODE>num</code> jest 32-bitowy, to<br>
    <CODE>IN EAX, num</CODE> wczyta 4 bajty z portu o numerze <CODE>num</code>
    </LI>
  </ul></li>
 <LI>Podobne uwagi maj± zastosowane dla instrukcji <CODE>OUT</CODE></LI>
</OL>

<P>Teraz by³aby dobra pora na jaki¶ przyk³ad (maj±c na uwadze dobro swojego komputera,
<em class="wazne">NIE URUCHAMIAJ PONI¯SZYCH KOMEND</em>):</P>
<PRE title="przyk³ady u¿ycia IN i OUT">
	in	al, 0	; pobierz bajt z portu 0
	out	60h, eax; wy¶lij 4 bajty na port 60h <!--wy¶lij po jednym bajcie na porty 60h, 61h, 62h, 63h-->

	mov	dx, 300	; 300 &gt; 255, wiêc musimy u¿yæ DX
	in	al, dx	; wczytaj 1 bajt z portu 300
	out	dx, ax	; wy¶lij 2 bajty na port 300 <!--po bajcie na port 300 i 301--></PRE>

<P>Nie rozpisywa³em siê tutaj za bardzo, bo ciekawsze i bardziej u¿yteczne przyk³ady znajduj± siê
w moich mini-kursach (<a href="diody_tut_linux.html" hreflang="pl">programowanie diód na klawiaturze</a>,
<a href="spkr_tut_linux.html" hreflang="pl">programowanie g³o¶niczka</a>).
</P>
<P>
Jak ju¿ wspomnia³em wcze¶niej, porty umo¿liwiaj± dostêp do wielu urz±dzeñ. Je¶li wiêc chcesz
poeksperymentowaæ, nie wybieraj portów zajêtych na przyk³ad przez kontrolery dysków twardych, gdy¿
zabawa portami mo¿e prowadziæ do utraty danych lub uszkodzenia sprzêtu.<BR>
Dlatego w³a¶nie w nowszych systemach operacyjnych (tych pracuj±cych w trybie chronionym, jak na przyk³ad
Linux) dostêp do portów jest zabroniony dla zwyk³ych aplikacji (o prawa
dostêpu do portów trzeba prosiæ system operacyjny - zaraz zobaczymy, jak to zrobiæ).<BR>
Jak wiêc dzia³aj± na przyk³ad stare DOS-owe gry? Odpowied¼ jest prosta: nie dzia³aj± w trybie
chronionym. Windows uruchamia je w trybie udaj±cym tryb rzeczywisty (taki, w jakim pracuje
DOS), co umo¿liwia im pe³n± kontrolê nad sprzêtem.<BR>
Wszystkie programy, które dot±d pisali¶my te¿ uruchamiaj± siê w tym samym trybie, wiêc maj±
swobodê w dostêpie na przyk³ad do g³o¶niczka czy karty d¼wiêkowej. Co innego programy pisane w nowszych
kompilatorach na przyk³ad jêzyka C - tutaj mo¿e ju¿ byæ problem. Ale na szczê¶cie my nie musimy siê
tym martwiæ...
</P>
<P>
Jeszcze jeden ciekawy przyk³ad - u¿ywanie CMOSu. CMOS ma 2 podstawowe porty: 70h, zwany portem
adresu i 71h, zwany portem danych. Operacje s± proste i sk³adaj± siê z 2 kroków:</P>
<OL>
 <LI>Na port 70h wy¶lij numer komórki (1 bajt), któr± chcesz odczytaæ lub zmieniæ. Polecam
	plik cmos.lst z RBIL, zawieraj±cy szczegó³owy opis komórek CMOS-u</LI>
 <LI>Na port 71h wy¶lij dane, je¶li chcesz zmieniæ komórkê lub z portu 71h odczytaj dane, je¶li
	chcesz odczytaæ komórkê</LI>
</OL>
<P>Oto przyk³ad. Odczytamy tutaj czas w komputerze, a konkretnie - sekundy:</P>
<PRE title="odczytywanie sekund zegara z CMOS-u">
	mov	eax, 101	; funkcja systemowa &quot;sys_ioperm&quot;:
	mov	ebx, 70h	; poczynaj±c od portu 70h
	mov	ecx, 20		; tyle bajtów bêdziemy mogli wys³aæ/odebraæ
	mov	edx, 71h	; koñcowy numer portu
	int	80h		; niestety, musimy byæ rootem

	cmp	eax, 0		; sprawdzamy, czy b³±d. Nie wiem,
				; co ta funkcja ma
				; zwracaæ, ale ten sposób zdaje
				; siê dzia³aæ

	jl	koniec		; je¶li wyst±pi³ b³±d, to zapis do
				; portów, do których nie mamy uprawnieñ,
				; zakoñczy siê &nbsp;&quot;Segmentation fault&quot;
				; (&nbsp;&quot;Naruszenie ochrony pamiêci&quot;&nbsp;)
	mov	al, 0
	out	70h, al

				; ustaw przerwê na milion nanosekund, czyli
				; jedn± milisekundê
	mov	dword [ts1+timespec.tv_sec], 0
	mov	dword [ts1+timespec.tv_nsec], 1000000
; w FASMie:
;	mov	dword [ts1.tv_sec], 0
;	mov	dword [ts1.tv_nsec], 1000000

	mov	eax, 162	; sys_nanosleep
	mov	ebx, ts1	; adres struktury timespec
	mov	ecx, 0		; adres wynikowej struktury timespec
	int	80h		; wykonaj przerwê w programie

	in	al, 71h

    koniec:
    	; ...

; w FASMie:
;	segment readable writeable
section .data

; w FASMie:
;struc timespec
;{
;	.tv_sec:		rd 1
;	.tv_nsec:		rd 1
;}
;
;ts1: timespec

struc timespec
                .tv_sec:	resd 1
                .tv_nsec:	resd 1
endstruc

ts1 istruc timespec</PRE>

<P>Wszystko jasne, oprócz bloku z wywo³aniem <span class="b" lang="en">sys_nanosleep</span>.
Po co to komu, pytacie?<BR>
Przy wspó³czesnych czêstotliwo¶ciach procesorów, CMOS (jak z reszt± i inne uk³ady) mo¿e
po prostu nie zd±¿yæ z odpowiedzi± na nasz± pro¶bê, gdy¿ od chwili wys³ania numeru komórki do
chwili odczytania danych mija za ma³o czasu. Dlatego robimy sobie przerwê na kilkana¶cie taktów
zegara procesora.<BR>
 Kiedy¶ miêdzy operacjami na CMOSie zwyk³o siê pisaæ <CODE>jmp short $+2</CODE>, co te¿
oczywi¶cie nie robi³o nic, poza zajmowaniem czasu (to jest po prostu skok o 2 bajty do przodu
od miejsca, gdzie zaczyna siê ta dwubajtowa instrukcja, czyli skok do nastêpnej instrukcji),
ale ta operacja ju¿ nie trwa wystarczaj±co d³ugo, aby j± dalej stosowaæ.
</P>
<P>
Komunikacja z urz±dzeniami nie zawsze jednak musi wymagaæ uprawnieñ administratora i
korzystania z funkcji <span class="b" lang="en">sys_ioperm</span>. Sporo rzeczy
(na przyk³ad z klawiatur±) mo¿na zrobiæ, korzystaj±c z funkcji <span class="b" lang="en">sys_ioctl</span>.
</P>
<P>
W dzisiejszych czasach porty ju¿ nie s± tak czêsto u¿ywane, jak by³y kiedy¶. Jest to spowodowane
przede wszystkim wspomnianym trybem chronionym oraz tym, ¿e wszystkie urz±dzenia maj± ju¿
w³asne sterowniki (maj±ce wiêksze uprawnienia do manipulowania sprzêtem), które zajmuj± siê
wszystkimi operacjami I/O. Programista musi jedynie uruchomiæ odpowiedni± funkcjê i niczym siê
nie przejmowaæ.
</P>
<P>
Dawniej, portów u¿ywa³o siê do sterowania grafik± czy wysy³ania d¼wiêków przez g³o¶niczek lub
karty d¼wiêkowe. Teraz tym wszystkim zajmuje siê za nas system operacyjny. Dziêki temu mo¿emy
siê uchroniæ przed zniszczeniem sprzêtu.
</P>
<P>Mimo i¿ rola portów ju¿ nie jest taka du¿a, zdecydowa³em siê je omówiæ, gdy¿ po prostu czasami
mog± siê przydaæ. I nie bêdziecie zdziwieni, gdy kto¶ poka¿e wam kod z jakimi¶ dziwnymi
instrukcjami IN i OUT...</P>
<P>
Szczegó³y dotycz±ce instrukcji dostêpu do portów tak¿e znajdziecie, jak zwykle, u
<A class="amd_link" href="http://developer.amd.com/Resources/documentation/guides/Pages/default.aspx" hreflang="en"><acronym title="Advanced Micro Devices" lang="en">AMD</acronym></A>
i  <A class="intel_link" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" hreflang="en">Intela</A>.</P>

<P>
Mi³ej zabawy.</P>

<br><br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="linux06.html">Poprzednia czê¶æ kursu</a> (Alt+3)<br>
<a accesskey="4" hreflang="pl" href="linux08.html">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>


<BR><BR><HR>
<h2 class="nag">Æwiczenia</h2>
<OL>
 <LI>Zapoznaj siê z opisem CMOSu i napisz program, który wy¶wietli bie¿±cy czas w postaci
	gg:mm:ss (z dwukropkami). Pamiêtaj o umieszczeniu opó¼nieñ w swoim programie i
	o uprawnieniach.</LI>

</OL>

</BODY></HTML>
