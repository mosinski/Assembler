<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks, czê¶æ 17 - Pobieranie i wy¶wietlanie </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Prev"     hreflang="pl" lang="en" href="linux16.htm">
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="kurs, asm, assembler, assembler, wej¶cie/wyj¶cie, wczytywanie liczb,
	wy¶wietlanie">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Tue, Jan 18 2011 17:59:58 CEST">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler pod Linuksem?<BR>
	<h1 class="nag">Czê¶æ 17 - Pobieranie i wy¶wietlanie, czyli jak komunikowaæ siê ze ¶wiatem</h1>
	</div>

<p>
O ile wy¶wietlanie i pobieranie od u¿ytkownika tekstów jest ³atwe do wykonania - wystarczy
uruchomiæ tylko jedn± funkcjê systemow± (eax=3 lub 4 przerwania 80h) -
to pobieranie i wy¶wietlanie na przyk³ad liczb
wcale nie jest takie proste i ka¿demu mo¿e przysporzyæ problemów. W tej czê¶ci podam parê
algorytmów, dziêki którym ka¿dy powinien sobie z tym poradziæ.
</p>

<BR>

<HR>
	<h2 class="nag">Wy¶wietlanie tekstu</h2>

	<BR><a href="#pobieranie_txt" tabindex="1" class="bezdruk">(przeskocz wy¶wietlanie tekstu)</a>
<P>
Co prawda wszyscy ju¿ to umiej±, ale dla porz±dku te¿ o tym wspomnê.<br>
Wszyscy znaj± funkcjê EAX=4 przerwania Linuksa - w EBX podajemy deskryptor, na który wy¶wietlamy
(1 oznacza standardowe wyj¶cie, najczê¶ciej ekran), w ECX - adres bufora z napisem do wy¶wietlenia, a
w EDX - liczba bajtów do wy¶wietlenia. Po wywo³aniu <code>int 80h</code>
w EAX dostajemy liczba zapisanych bajtów (je¶li EAX jest ujemny, to wyst±pi³ b³±d).
</P>
<P>
Zawsze mo¿na te¿ <a href="tryb_txt_linux.html" hreflang="pl">wy¶wietlaæ tekst rêcznie</a>.</P>





<BR>

<HR>
	<h2 class="nag"><a name="pobieranie_txt" id="pobieranie_txt">Pobieranie tekstu</a></h2>

	<BR><a href="#wysw_liczb" class="bezdruk">(przeskocz pobieranie tekstu)</a>
<P>
Do pobierania tekstów od u¿ytkownika s³u¿y funkcja EAX=3 przerwania Linuksa -
w EBX podajemy deskryptor, z którego czytamy
(0 oznacza standardowe wej¶cie, najczê¶ciej klawiaturê), w ECX - adres bufora na dane, a
w EDX - liczba bajtów do przeczytania. Po wywo³aniu <code>int 80h</code> w buforze dostajemy
dane, a w EAX - liczba przeczytanych bajtów (je¶li EAX jest ujemny, to wyst±pi³ b³±d).
</P>




<HR>
	<h2 class="nag"><a name="wysw_liczb" id="wysw_liczb">Wy¶wietlanie liczb</a></h2>

	<BR><a href="#pobieranie_liczb" class="bezdruk">(przeskocz wy¶wietlanie liczb)</a>
<P>
S± generalnie dwa podej¶cia do tego problemu:</P>
<ol>
<li>dzielenie przez coraz mniejsze potêgi liczby 10 (zaczynaj±c od najwy¿szej
  odpowiedniej) i wy¶wietlanie ilorazów</li>
<li>dzielenie przez 10 i wy¶wietlanie reszt wspak</li>
</ol>
<P>Podej¶cie pierwsze jest zilustrowane takim kodem dla liczb 16-bitowych (0-65535):</P>
<pre>
	mov	ax, [liczba]
	xor	dx, dx
	mov	cx, 10000
	div	cx
	or	al, '0'
	; wy¶wietl AL jako znak
	mov	ax, dx
	xor	dx, dx
	mov	cx, 1000
	div	cx
	or	al, '0'
	; wy¶wietl AL jako znak
	mov	ax, dx
	mov	cl, 100
	div	cl
	or	al, '0'
	; wy¶wietl AL jako znak
	mov	al, ah
	xor	ah, ah
	mov	cl, 10
	div	cl
	or	ax, '00'
	; wy¶wietl AL jako znak
	; potem wy¶wietl AH jako znak</pre>

<P>Jak widaæ, im wiêcej cyfr mo¿e mieæ liczba, tym wiêcej bêdzie takich bloków. Trzeba zacz±æ
od najwy¿szej mo¿liwej potêgi liczby 10, bo inaczej mo¿e doj¶æ do przepe³nienia. W ka¿dym
kroku dzielnik musi mieæ o jedno zero mniej, gdy¿ inaczej nie uda siê wy¶wietliæ prawid³owego
wyniku (mo¿e byæ dwucyfrowy i wy¶wietli siê tylko jaki¶ znaczek). Ponadto, je¶li liczba wynosi
na przyk³ad 9, to wy¶wietli siê 00009, czyli wiod±ce zera nie bêd± skasowane. Mo¿na to
oczywi¶cie omin±æ.</P>

<P>
Podej¶cie drugie jest o tyle wygodniejsze, ¿e mo¿na je zapisaæ za pomoc± pêtli. Jest to
zilustrowane procedur± _pisz_ld z
<a href="linux04.html" hreflang="pl">czê¶ci czwartej</a> oraz kodem z mojej biblioteki:</P>
<pre>
	mov	ax, [liczba]
	xor	si, si			; indeks do bufora
	mov	cx, 10			; dzielnik
_pisz_l_petla:				; wpisujemy do bufora reszty z
					; dzielenia liczby przez 10,
	xor	dx, dx			; czyli cyfry wspak
	div	cx			; dziel przez 10
	or	dl, '0'			; dodaj kod ASCII cyfry zero
	mov	[_pisz_bufor+si], dl	; zapisz cyfrê do bufora
	inc	si			; zwiêksz indeks
	test	ax, ax			; dopóki liczba jest ró¿na od 0
	jnz	_pisz_l_petla

_pisz_l_wypis:
	mov	al, [_pisz_bufor+si-1]	; pobierz znak z bufora
	call	far _pisz_z		; wy¶wietla znak
	dec	si			; przejd¼ na poprzedni znak
	jnz	_pisz_l_wypis</pre>

<P>Zmienna _pisz_bufor to bufor odpowiedniej liczby bajtów.</P>







<BR>

<HR>
	<h2 class="nag"><a name="pobieranie_liczb" id="pobieranie_liczb">Pobieranie liczb</a></h2>

	<BR><a href="#spr" class="bezdruk">(przeskocz pobieranie liczb)</a>
<P>
Do tego zagadnienia algorytm jest nastêpuj±cy:</P>
<ol>
<li>wczytaj ³añcuch znaków od razu w ca³o¶ci lub wczytuj znak po znaku w kroku 3</li>
<li>wstêpnie ustaw wynik na 0</li>
<li>we¼ kolejny znak z wczytanego ³añcucha znaków (je¶li ju¿ nie ma, to koniec)</li>
<li>zamieñ go na jego warto¶æ binarn±. Je¶li znak wczyta³e¶ do AL, to wystarczy:<br>
    <code>sub al, '0'</code></li>
<li>przemnó¿ bie¿±cy wynik przez 10</li>
<li>dodaj do niego warto¶æ AL otrzyman± z kroku 4</li>
<li>skacz do 3</li>
</ol>
<P>Przyk³adow± ilustracjê mo¿na znale¼æ tak¿e w mojej bibliotece:</P>
<pre>
	xor	bx, bx		; miejsce na liczbê
l_petla:
	call	far _we_z	; pobierz znak z klawiatury

	cmp	al, lf		; czy Enter?
	je	l_juz		; je¶li tak, to wychodzimy
	cmp	al, cr
	je	l_juz
				; przepuszczamy Spacje:
	cmp	al, spc
	je	l_petla

	cmp	al, '0'		; je¶li nie cyfra, to b³±d
	jb	l_blad
	cmp	al, '9'
	ja	l_blad

	and	al, 0fh		; izolujemy warto¶æ (sub al, '0')
	mov	cl, al
	mov	ax, bx

	shl	bx, 1		; zrobimy miejsce na now± cyfrê
	jc	l_blad

	shl	ax, 1
	jc	l_blad
	shl	ax, 1
	jc	l_blad
	shl	ax, 1
	jc	l_blad

	add	bx, ax		; BX=BX*10 - bie¿±c± liczbê mno¿ymy przez 10
	jc	l_blad

	add	bl, cl		; dodajemy cyfrê
	adc	bh, 0
	jc	l_blad		; je¶li przekroczony limit, to b³±d

	jmp	short l_petla
l_juz:
	; wynik w AX</pre>


<BR>

<HR>
	<h2 class="nag"><a name="spr" id="spr">Sprawdzanie rodzaju znaku</a></h2>

	<BR><a href="#wyswietlanie_ulamkow" class="bezdruk">(przeskocz sprawdzanie rodzaju znaku)</a>
<P>
Powiedzmy, ¿e u¿ytkownik naszego programu wpisa³ nam jakie¶ znaki (tekst, liczby).
 Jak teraz sprawdziæ, co dok³adnie otrzymali¶my? Sprawa nie jest trudna, lecz wymaga czasem
 zastanowienia i tablicy
 <acronym title="American Standard Code for Information Interchange" lang="en">ASCII</acronym>
 pod rêk±.</P>
<ol>
 <li>Cyfry<br>
	<P>Cyfry w kodzie ASCII zajmuj± miejsca od 30h (zero) do 39h (dziewi±tka). Wystarczy wiêc
	sprawdziæ, czy wczytany znak mie¶ci siê w tym zakresie:</P>
	<pre>
		cmp	al, '0'
		jb	nie_cyfra
		cmp	al, '9'
		ja	nie_cyfra
		; tu wiemy, ¿e AL reprezentuje cyfrê.
		; Pobranie warto¶ci tej cyfry:
		and	al, 0fh	; skasuj wysokie 4 bity, zostaw 0-9</pre>
 	</li>

 <li>Litery<br>
 	<P>Litery, podobnie jak cyfry, s± uporz±dkowane w kolejno¶ci w dwóch osobnych grupach
 	(najpierw wielkie, potem ma³e). Aby sprawdziæ, czy znak w AL jest liter±, wystarczy kod</P>
	<pre>
			cmp	al, 'A'
			jb	nie_litera	; na pewno nie litera
			cmp	al, 'Z'
			ja	sprawdz_male	; na pewno nie wielka,
						; sprawd¼ ma³e
			; tu wiemy, ¿e AL reprezentuje wielk± literê.
			; ...
		sprawdz_male:
			cmp	al, 'a'
			jb	nie_litera	; na pewno nie litera
			cmp	al, 'z'
			ja	nie_litera
			; tu wiemy, ¿e AL reprezentuje ma³± literê.</pre>
 	</li>

 <li>Cyfry szesnastkowe<br>
	<P>Tu sprawa jest ³atwa: nale¿y najpierw sprawdziæ, czy dany znak jest cyfr±.
	Je¶li nie, to sprawdzamy, czy jest wielk± liter± z zakresu od A do F. Je¶li nie,
	to sprawdzamy, czy jest ma³± liter± z zakresu od a do f. Wystarczy po³±czyæ powy¿sze
	fragmenty kodu. Wyci±gniêcie warto¶ci wymaga jednak wiêcej kroków:</P>
	<pre>
		; je¶li AL to cyfra '0'-'9'
		and	al, 0fh
		; je¶li AL to litera 'A'-'F'
		sub	al, 'A' - 10
		; je¶li AL to litera 'a'-'f'
		sub	al, 'a' - 10</pre>

	<P>Je¶li AL jest liter±, to najpierw odejmujemy od niego kod odpowiedniej (ma³ej
	lub wielkiej) litery A. Dostajemy wtedy warto¶æ od 0 do 5. Aby dostaæ realn± warto¶æ
	danej litery w kodzie szesnastkowym, wystarczy teraz dodaæ 10. A skoro AL-'A'+10 to
	to samo, co AL-('A'-10), to ju¿ wiecie, sk±d siê wziê³y powy¿sze instrukcje.
 	</P></li>

 <li>Przerabianie wielkich liter na ma³e i odwrotnie<br>
 	<P>Oczywistym sposobem jest odjêcie od litery kodu odpowiedniej litery A (ma³ej lub wielkiej),
 	po czym dodanie kodu tej drugiej, czyli:</P>
 	<pre>
 		; z ma³ej na wielk±
 		sub	al, 'a'
 		add	al, 'A'
 		; z wielkiej na ma³±
 		sub	al, 'A'
 		add	al, 'a'</pre>

 	<P>lub nieco szybciej:</P>
 	<pre>
 		; z ma³ej na wielk±
 		sub	al, 'a' - 'A'
 		; z wielkiej na ma³±
 		sub	al, 'A' - 'a'</pre>

 	<P>Ale jest lepszy sposób: patrz±c w tabelê kodów ASCII widaæ, ¿e litery ma³e od wielkich
 	ró¿ni± siê tylko jednym bitem - bitem numer 5. Teraz widaæ, ¿e wystarczy</P>
 	<pre>
 		; z ma³ej na wielk±
 		and	al, 5fh
 		; z wielkiej na ma³±
 		or	al, 20h</pre>
 	</li>
</ol>



<BR><BR>

<HR>
<h2 class="nag"><a name="wyswietlanie_ulamkow" id="wyswietlanie_ulamkow">Wy¶wietlanie liczb nieca³kowitych</a></h2>

<BR><a href="#pobieranie_ulamkow" class="bezdruk">(przeskocz wy¶wietlanie liczb nieca³kowitych)</a>
<P>
To zagadnienie mo¿na rozbiæ na dwa etapy:</P>
<ol>
 <li>wy¶wietlenie czê¶ci ca³kowitej liczby</li>
 <li>wy¶wietlenie czê¶ci u³amkowej liczby</li>
</ol>
<P>Do wy¶wietlenia czê¶ci ca³kowitej mo¿e nam pos³u¿yæ procedura wy¶wietlania liczb ca³kowitych,
wystarczy z danej liczby wyci±gn±æ czê¶æ ca³kowit±. W tym celu najpierw ustawiamy tryb zaokr±glania
na obcinanie (gdy¿ inaczej na przyk³ad czê¶æ ca³kowita z liczby 1,9 wynios³aby 2):</P>
<pre>
	fnstcw	[status]			  ; status to 16-bitowe s³owo
	or	word [status], (0Ch &lt;&lt; 8)  ; zaokr±glanie: obcinaj
	;or	word [status], (0Ch shl 8) ; dla FASMa
	fldcw	[status]</pre>

<P>W trakcie ca³ej procedury wy¶wietlania bêdziemy korzystaæ z tego w³a¶nie trybu zaokr±glania.
<em class="wazne">Pamiêtajcie</em>, aby przy wyj¶ciu z procedury przywróciæ poprzedni stan
s³owa kontrolnego koprocesora (na przyk³ad poprzez skopiowanie warto¶ci zmiennej <code>status</code>
przed jej zmian± do innej zmiennej, po czym za³adowanie s³owa kontrolnego z tej drugiej zmiennej).
</P>
<P>
Teraz wyci±gamy czê¶æ ca³kowit± liczby nastêpuj±cym kodem:</P>
<pre>
	frndint				; je¶li liczba by³a w ST0
	fistp	qword [cz_calkowita]</pre>

<P>Pojawia siê jednak problem, gdy czê¶æ ca³kowita nie zmie¶ci siê nawet w 64 bitach. Wtedy trzeba
skorzystaæ z tego samego sposobu, który by³ podany dla liczb ca³kowitych: ci±g³e dzielenie przez 10
i wy¶wietlenie reszt z dzielenia wspak.<br>
W tym celu ³adujemy na stos <acronym title="Floaing-Point Unit" lang="en">FPU</acronym> czê¶æ ca³kowit±
z naszej liczby oraz liczbê 10:</P>
<pre>
	frndint				; je¶li liczba by³a w ST0
	fild	word [dziesiec]		; zmienna zawieraj±ca warto¶æ 10
	fxch	st1			; stos: ST0=czê¶æ ca³kowita, ST1=10</pre>

<P>Stos koprocesora zawiera teraz czê¶æ ca³kowit± naszej liczby w ST0 i warto¶æ 10 w ST1. Po wykonaniu</P>
<pre>
	fprem				; stos: ST0=mod (czê¶æ ca³kowita,10), ST1=10</pre>

<P>w ST0 dostajemy resztê z dzielenia naszej liczby przez 10 (czyli cyfrê jedno¶ci, do wy¶wietlenia jako
ostatni±). Resztê tê zachowujemy do bufora na cyfry. Teraz dzielimy liczbê przez 10:</P>
<pre>
					; ST0=czê¶æ ca³kowita, ST1=10
	fdiv	st0, st1		; ST0=czê¶æ ca³kowita/10, ST1=10
	frndint				; ST0=czê¶æ ca³kowita z poprzedniej
					; podzielonej przez 10, ST1=10</pre>

<P>i powtarzamy ca³± procedurê do chwili, w której czê¶æ ca³kowita stanie siê zerem, co sprawdzamy takim
na przyk³ad kodem:</P>
<pre>
	ftst				; zbadaj liczbê w ST0 i ustaw flagi FPU
	fstsw	[status]		; zachowaj flagi FPU do zmiennej
	mov	ax, [status]
	sahf				; zapisz AH do flag procesora
	jnz	powtarzamy_dzielenie</pre>

<P>Po wy¶wietleniu czê¶ci ca³kowitej nale¿y wy¶wietliæ separator (czyli przecinek), po czym zabraæ siê
do wy¶wietlania czê¶ci u³amkowej. To jest o tyle prostsze, ¿e uzyskane cyfry mo¿na od razu wy¶wietliæ,
bez korzystania z ¿adnego bufora.</P>
<P>
Algorytm jest podobny jak dla liczb ca³kowitych, z t± ró¿nic±, ¿e teraz liczba jest na ka¿dym kroku
mno¿ona przez 10:</P>
<pre>
					; ST0=czê¶æ u³amkowa, ST1=10
	fmul	st0, st1		; ST0=czê¶æ u³amkowa * 10, ST1=10
	fist	word [liczba]		; cyfra (czê¶æ u³amkowa*10) do zmiennej</pre>

<P>Po wy¶wietleniu warto¶ci znajduj±cej siê we wskazanej zmiennej, nale¿y odj±æ j± od bie¿±cej liczby,
dziêki czemu na stosie znów bêdzie liczba mniejsza od jeden i bêdzie mo¿na powtórzyæ procedurê:</P>
<pre>
	fild	word [liczba]		; ST0=czê¶æ ca³kowita,
					; ST1=czê¶æ ca³kowita + czê¶æ u³amkowa,
					; ST2=10
	fsubp	st1, st0		; ST0=nowa czê¶æ u³amkowa, ST1=10</pre>

<P>Po ka¿dej iteracji sprawdzamy, czy liczba jeszcze nie jest zerem (podobnie jak powy¿ej).</P>

<BR>

<HR>
<h2 class="nag"><a name="pobieranie_ulamkow" id="pobieranie_ulamkow">Pobieranie liczb nieca³kowitych</a></h2>

<P>
Procedurê wczytywania liczb nieca³kowitych mo¿na podzieliæ na dwa etapy:</P>
<ol>
 <li>wczytanie czê¶ci ca³kowitej</li>
 <li>wczytanie czê¶ci u³amkowej</li>
</ol>
<P>Wczytywanie czê¶ci ca³kowitej odbywa siê podobnie, jak dla liczb ca³kowitych: bie¿±c± liczbê
pomnó¿ przez 10, po czym dodaj aktualnie wprowadzon± cyfrê. Kluczowa czê¶æ kodu wygl±daæ mo¿e wiêc
podobnie do tego fragmentu:</P>
<pre>
	; kod wczytuj±cy cyfrê ³aduje j± do zmiennej WORD [cyfra]
					; ST0=10, ST1=aktualna liczba
	fmul	st1, st0		; ST0=10, ST1=liczba*10
	fild	word [cyfra]		; ³adujemy ostatni± cyfrê,
					; ST0=cyfra, ST1=10, ST2=10 * liczba
	faddp	st2, st0		; ST0=10, ST1=liczba*10 + cyfra</pre>

<P>Procedurê tê powtarza siê do chwili napotkania separatora czê¶ci u³amkowej (czyli przecinka, ale
mo¿na akceptowaæ te¿ kropkê). Od chwili napotkania separatora nastêpuje przej¶cie do wczytywania
czê¶ci u³amkowej.</P>
<P>
Aby wczytaæ czê¶æ u³amkow±, najlepiej powróciæ do algorytmu z dzieleniem. Wszystkie wprowadzane cyfry
najpierw ³adujemy do bufora, potem odczytujemy wspak, dodajemy do naszej liczby i dzielimy j± przez 10.
Zasadnicza czê¶æ pêtli mog³aby wygl±daæ podobnie do tego:</P>
<pre>
	fild	word [cyfra]	; ST0=cyfra, ST0=bie¿±ca czê¶æ u³amkowa, ST2=10
	faddp	st1, st0	; ST0=cyfra+bie¿±ca czê¶æ u³amkowa, ST1=10
	fdiv	st0, st1	; ST0=nowa liczba/10 = nowy u³amek, ST1=10</pre>

<P>Po wczytaniu ca³ej czê¶ci u³amkowej pozostaje tylko dodaæ j± do uprzednio wczytanej czê¶ci ca³kowitej
i wynik gotowy.</P>
<P>
<em class="wazne">Pamiêtajcie</em> o dobrym wykorzystaniu stosu koprocesora: nigdy nie przekraczajcie
o¶miu elementów i nie zostawiajcie wiêcej, ni¿ otrzymali¶cie jako parametry.</P>


<br><br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="linux16.html">Poprzednia czê¶æ kursu</a> (Alt+3)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>


<HR>
<h2 class="nag">Æwiczenia</h2>
<OL>
 <li>Korzystaj±c z przedstawionych tu algorytmów, napisz algorytmy wczytuj±ce i wy¶wietlaj±ce
 	liczby dziesiêtne 8-bitowe.</li>
 <li>Korzystaj±c z przedstawionych tu algorytmów, napisz algorytmy wczytuj±ce i wy¶wietlaj±ce
 	liczby szesnastkowe 16-bitowe (wystarczy zmieniæ liczby, przez które mno¿ysz i dzielisz
 	oraz to, jakie znaki s± dozwolone i wy¶wietlane - dochodz± litery od A do F).</li>
</OL>

</BODY></HTML>
