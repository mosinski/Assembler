<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks, czê¶æ 5 - Koprocesor </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Prev"     hreflang="pl" lang="en" href="linux04.html" >
<link rel="Next"     hreflang="pl" lang="en" href="linux06.html" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="kurs, asm, asembler, assembler, FPU, NPX, NPU, ONP, RPN, float,
	koprocesor, st(0), finit, BCD, linux, linuks">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Mon, Oct 29 2012 17:22:19 CEST">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler pod Linuksem?<BR>
	<h1 class="nag">Czê¶æ 5 - Koprocesor, czyli jak liczyæ na u³amkach.
	 Odwrotna Notacja Polska</h1></div>

<P>
Jak zapewne wiêkszo¶æ wie, koprocesor (FPU = <span lang="en">Floating Point Unit</span>,
 NPX = <span lang="en">Numerical Processor eXtension</span>)
  s³u¿y do wykonywania dzia³añ matematycznych. Podstawowy procesor te¿ oczywi¶cie
wykonuje dzia³ania matematyczne (dodawanie, mno¿enie, ...) ale tylko na liczbach ca³kowitych.
Z czasem jednak przysz³a potrzeba wykonywania obliczeñ na liczbach nieca³kowitych, czyli u³amkach
(liczbach zmiennoprzecinkowych). Dlatego firmy produkuj±ce procesory zaczê³y je wyposa¿aæ
w³a¶nie w uk³ady wspomagaj±ce pracê na u³amkach. Do procesorów 8086, 80286, 80386 by³y do³±czane
jako osobne uk³ady koprocesory: 8087, 80287, 80387 (80187 nie wprowadzi³ ¿adnych istotnych
nowo¶ci. By³a to przeróbka 8087, a mo¿e nawet by³ to po prostu ten sam uk³ad). Procesory
486SX mia³y jeszcze oddzielny koprocesor (80387) a od 486DX (w ka¿dym razie u Intela)
koprocesor by³ ju¿ na jednym chipie z procesorem. I tak jest do dzi¶.
</P>
<P>
Ale do¶æ wstêpu. Pora na szczegó³y.</P>




<HR>
<h2 class="nag">Typy danych</h2>
<br>

<P>Zanim zaczniemy cokolwiek robiæ, trzeba wiedzieæ, na czym
ten ca³y koprocesor operuje.<BR>
Oprócz liczb ca³kowitych, FPU operuje na liczbach u³amkowych ró¿nej precyzji:</P>
<UL>
 <LI>Pojedyncza precyzja. Liczby takie zajmuj± po 32 bity (4 bajty) i ich warto¶æ maksymalna
	wynosi ok. 10<SUP>39</SUP> (10^39). Znane s± programistom jêzyka C jako <q lang="en">float</q>.</LI>
 <LI>Podwójna precyzja. 64 bity (8 bajtów), max = ok. 10<SUP>409</SUP> (10^409). W jêzyku C s± znane
	jako <q lang="en">double</q></LI>
 <LI>Rozszerzona precyzja. 80 bitów (10 bajtów), max = ok. 10<SUP>4930</SUP> (10^4930). W jêzyku C s± to
	<q lang="en">long double</q></LI>
</UL>
<P>Jak widaæ, ilo¶ci bitów s± oczywi¶cie skoñczone. Wiêc nie ka¿d± liczbê rzeczywist± da siê
dok³adnie zapisaæ w postaci binarnej. Na przyk³ad, jedna dziesi±ta (0.1) zapisana dwójkowo jest
u³amkiem nieskoñczonym okresowym! Poza tym, to, czego nas uczyli na matematyce, na przyk³ad oczywista
równo¶æ: a+(b-a)=b nie musi byæ prawd± w ¶wiecie u³amków w procesorze ze wzglêdu na brak
precyzji!
</P>
<P>
Poza u³amkami, FPU umie operowaæ na BCD (<span lang="en">binary coded decimal</span>).
 W takich liczbach 1 bajt dzieli siê
na 2 czê¶ci po 4 bity, z których ka¿da mo¿e mieæ warto¶æ 0-9. Ca³y bajt reprezentuje wiêc liczby
od 0 do 99, w których cyfra jedno¶ci jest w m³odszych 4 bitach a cyfra dziesi±tek - w starszych
4 bitach.</P>
<P>
Szczegó³ami zapisu liczb u³amkowych nie bêdziemy siê tutaj zajmowaæ. Polecam, tak jak poprzednio,
<A class="intel_link" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" tabindex="1" hreflang="en">strony Intela</A>
i <A class="amd_link" href="http://developer.amd.com/Resources/documentation/guides/Pages/default.aspx" hreflang="en">strony <acronym title="Advanced Micro Devices" lang="en">AMD</acronym></A>,
gdzie znajduje siê te¿ kompletny opis wszystkich instrukcji procesora i koprocesora.</P>





<BR>
<HR>
<h2 class="nag">Rejestry koprocesora</h2>

<P>Po zapoznaniu siê z typami (a przede wszystkim z rozmiarami) liczb u³amkowych, powstaje pytanie:
gdzie koprocesor przechowuje takie ilo¶ci danych?</P>
<P>
FPU ma specjalnie do tego celu przeznaczonych 8 rejestrów, po 80 bitów ka¿dy. W operacjach
wewnêtrznych (czyli bez pobierania lub zapisywania danych do pamiêci) FPU zawsze u¿ywa
rozszerzonej precyzji.</P>
<P> Rejestry danych nazwano st(0), st(1), ... , st(7) (NASM: st0 ... st7). Nie dzia³aj± jednak
one tak, jak zwyk³e rejestry, lecz jak ... stos! To znaczy, ¿e dowolnie dostêpna jest tylko
warto¶æ ostatnio po³o¿ona na stosie czyli wierzcho³ek stosu, w tym przypadku: st(0). Znaczy to,
¿e do pamiêci (FPU operuje tylko na w³asnych rejestrach lub pamiêci - nie mo¿e u¿ywaæ rejestrów
ogólnego przeznaczenia na przyk³ad EAX itp.) mo¿e byæ zapisana tylko warto¶æ z st(0), a ka¿da warto¶æ
pobierana z pamiêci idzie do st(0) a stare st(0) przesuwa siê do st(1) itd. ka¿dy rejestr
przesuwa siê o 1 dalej. Je¿eli brakuje na to miejsca, to FPU mo¿e wygenerowaæ przerwanie
(wyj±tek) a rejestry danych bêd± prawdopodobnie zawieraæ ¶mieci.</P>
<P>Operowanie na rejestrach FPU bêdzie wymaga³o nieco wiêcej uwagi ni¿ na zwyk³ych, ale i do tego
mo¿na siê przyzwyczaiæ.</P>





<BR><HR>
<h2 class="nag">Instrukcje koprocesora</h2>

<P>
Zacznijmy wiêc od omówienia kilku podstawowych instrukcji. Przez [mem] bêdê nazywa³ dane bêd±ce
w pamiêci (32-, 64- lub 80-bitowe, <q>int</q> oznacza liczbê ca³kowit±), <q>st</q> jest czêstym skrótem
od <q>st(0)</q>. Je¿eli komenda koñczy siê na P to oznacza, ¿e zdejmuje dane raz ze stosu, PP
oznacza, ¿e zdejmuje 2 razy, czyli st(0) i st(1).</P>
<OL>
 <LI>Instrukcje przemieszczenia danych:
  <UL>
   <LI><code>FLD/FILD [mem]</code> - za³aduj liczbê rzeczywist±/ca³kowit± z pamiêci. Dla liczby rzeczywistej
	jest to 32, 64 lub 80 bitów. Dla ca³kowitej - 16, 32 lub 64 bity.</LI>
   <LI><code>FST [mem32/64/80]</code> - do pamiêci idzie liczba ze st(0).</LI>
   <LI><code>FSTP [mem32/64/80]</code> - zapisz st(0) w pamiêci i zdejmij je ze stosu. Znaczy
	 to tyle, ¿e st(1) o ile istnieje, staje siê st(0) itd. ka¿dy rejestr cofa siê o 1.</LI>
   <LI><code>FIST [mem16/32]</code> - ewentualnie obciêt± do ca³kowitej liczbê z st(0) zapisz do pamiêci.</LI>
   <LI><code>FISTP [mem16/32/64]</code> - jak wy¿ej, tylko ze zdjêciem ze stosu.</LI>
   <LI><code>FXCH st(i)</code> - zamieñ st(0) z st(i).</LI>
  </UL><BR><BR></LI>
 <LI>Instrukcje ³adowania sta³ych
  <UL>
   <LI><code>FLDZ</code> - za³aduj zero. st(0) = 0.0</LI>
   <LI><code>FLD1</code> - za³aduj 1. st(0) = 1.0</LI>
   <LI><code>FLDPI</code> - za³aduj pi.</LI>
   <LI><code>FLDL2T</code> - za³aduj log2(10)</LI>
   <LI><code>FLDL2E</code> - za³aduj log2(e)</LI>
   <LI><code>FLDLG2</code> - za³aduj log(2)=log10(2)</LI>
   <LI><code>FLDLN2</code> - za³aduj ln(2)</LI>
  </UL><BR><BR></LI>
 <LI>Dzia³ania matematyczne:
  <UL>
   <LI>dodawanie: <code>FADD</code>, sk³adnia identyczna jak w odejmowaniu prostym<BR><BR>
   <LI>odejmowanie:
	<UL>
	 <LI><code>FSUB [mem32/64]</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st := st-[mem]</LI>
	 <LI><code>FSUB st(0),st(i)</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st := st-st(i)</LI>
	 <LI><code>FSUB st(i),st(0)</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(i) := st(i)-st(0)</LI>
	 <LI><code>FSUBP st(i), st(0)</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(i) := st(i)-st(0) i zdejmij</LI>
	 <LI><code>FSUBP</code> (bez argumentów) = <code>FSUBP st(1),st(0)</code></LI>
	 <LI><code>FISUB [mem16/32int]</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st := st-[mem]</LI>
	</UL><BR></LI>

   <LI>odejmowanie odwrotne:
	<UL>
	 <LI><code>FSUBR [mem32/64]</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st := [mem]-st(0)</LI>
	 <LI><code>FSUBR st(0),st(i)</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st := st(i)-st(0)</LI>
	 <LI><code>FSUBR st(i),st(0)</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(i) := st(0)-st(i)</LI>
	 <LI><code>FSUBRP st(i),st(0)</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(i) := st(0)-st(i) i zdejmij</LI>
	 <LI><code>FSUBRP</code> (bez argumentów) = <code>FSUBRP st(1),st(0)</code></LI>
	 <LI><code>FISUBR [mem16/32int]</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st := [mem]-st</LI>
	</UL><BR></LI>
   <LI>mno¿enie: <code>FMUL</code>, sk³adnia identyczna jak w odejmowaniu prostym.<BR><BR></LI>
   <LI>dzielenie: <code>FDIV</code>, sk³adnia identyczna jak w odejmowaniu prostym.</LI>
   <LI>dzielenie odwrotne: <code>FDIVR</code>, sk³adnia identyczna jak w odejmowaniu odwrotnym.<BR><BR></LI>
   <LI>warto¶æ bezwzglêdna: <code>FABS</code> (bez argumentów) zastêpuje st(0) jego warto¶ci± bezwzglêdn±.</LI>
   <LI>zmiana znaku: <code>FCHS</code>: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(0) := -st(0).</LI>
   <LI>pierwiastek kwadratowy: <code>FSQRT</code>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(0) := SQRT[ st(0) ]</LI>
   <LI>reszty z dzielenia: <code>FPREM</code>, <code>FPREM1</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(0) := st(0) mod st(1).</LI>
   <LI>zaokr±glanie do liczby ca³kowitej: <code>FRNDINT</code>: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;st(0) := (int)st(0).</LI>
  </UL><BR><BR></LI>
 <LI>Komendy porównania:<BR>
     - <code>FCOM/FCOMP/FCOMPP</code>, <code>FUCOM/FUCOMP/FUCOMPP</code>, <code>FICOM/FICOMP</code>,
	<code>FCOMI/FCOMIP</code>, <code>FUCOMI/FUCOMIP</code>, <code>FTST</code>, <code>FXAM</code>.
	<P>Tutaj trzeba trochê omówiæ sytuacjê. FPU oprócz rejestrów danych zawiera tak¿e rejestr
	kontrolny (16 bitów) i rejestr stanu (16 bitów).<BR> W rejestrze stanu s± 4 bity nazwane
	C0, C1, C2 i C3. To one wskazuj± wynik ostatniego porównania, a uk³ad ich jest taki sam,
	jak flag procesora, co pozwala na ich szybkie przeniesienie do flag procesora.
 	Aby odczytaæ wynik porównania, nale¿y zrobiæ takie co¶:</P>
	<PRE>
	fcom
	fstsw	ax	; tylko od 386. Inaczej:
			; fstsw word ptr [zmienna] / mov ax,[zmienna]
	sahf		; AH zapisane do flag</PRE>

	<P>i u¿ywaæ normalnych komend JE, JB itp.</P>
	<UL>
	 <LI><code>FCOM st(n)/[mem]</code> - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; porównaj st(0) z st(n)
		(lub zmienn± w pamiêci) bez zdejmowania st(0) ze stosu FPU</LI>
	 <LI><code>FCOMP st(n)/[mem]</code> - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; porównaj st(0) z st(n)
		(lub zmienn± w pamiêci) i zdejmij st(0)</LI>
	 <LI><code>FCOMPP</code> - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; porównaj st(0) z st(1) i zdejmij oba ze stosu</LI>
	 <LI><code>FICOM [mem]</code> - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; porównaj st(0) ze zmienn±
		ca³kowit± 16- lub 32-bitow± w pamiêci</LI>
	 <LI><code>FICOMP [mem]</code> - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; porównaj st(0) ze zmienn±
		ca³kowit± 16- lub 32-bitow± w pamiêci, zdejmij st(0)</LI>
	 <LI><code>FCOMI st(0), st(n)</code> - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; porównaj st(0) z st(n)
		i ustaw flagi <em class="wazne">procesora</em>, nie tylko FPU</LI>
	 <LI><code>FCOMIP st(0), st(n)</code> - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; porównaj st(0) z st(n)
		i ustaw flagi <em class="wazne">procesora</em>, nie tylko FPU, zdejmij st(0)</LI>
	</UL>
	<P>Komendy koñcz±ce siê na I lub IP zapisuj± swój wynik bezpo¶rednio do flag procesora.
	Mo¿na tych flag od razu u¿ywaæ (<code>JZ</code>, <code>JA</code>, ...). Te komendy s±
	dostêpne tylko od 386.</P>

	<P><code>FTST</code> porównuje st(0) z zerem.</P>
	<P><code>FXAM</code> bada, co jest w st(0) - prawid³owa liczba, b³±d
	(NaN = <span lang="en">Not a Number</span>), czy 0.</P>
	</LI>
  <LI>Instrukcje trygonometryczne:<BR>
     <UL>
	<LI><code>FSIN</code> - st(0) := sinus [st(0)]</LI>
	<LI><code>FCOS</code> - st(0) := kosinus [st(0)]</LI>
	<LI><code>FSINCOS</code> - st(0) := kosinus [st(0)], st(1) := sinus [st(0)]</LI>
	<LI><code>FPTAN</code> - <span lang="en">partial tangent</span> = tangens st(0) := tg [st(0)]</LI>
	<LI><code>FPATAN</code> - <span lang="en">arcus</span> tangens st(0) := arctg [st(0)]</LI>
     </UL>
    <BR></LI>
  <LI>Logarytmiczne, wyk³adnicze:<BR>
   <UL>
    <LI><code>FYL2X</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(1) := st(1)*log2[st(0)] i zdejmij</LI>
    <LI><code>FYL2XPI</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(1) := st(1)*log2[ st(0) + 1.0 ] i zdejmij </LI>
    <LI><code>F2XM1</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(0) := 2^[st(0)] - 1</LI>
   </UL><BR><BR></LI>
  <LI>Instrukcje kontrolne:
   <UL>
    <LI><code><span class="b">FINIT/FNINIT</span></code> - inicjalizacja FPU. Litera N po F oznacza,
    	 aby nie braæ po uwagê potencjalnych nieza³atwionych wyj±tków.</LI>
    <LI><code>FLDCW</code>, <code>FSTCW/FNSTCW</code> - <span lang="en">Load/Store control word</span>
    	 - zapisuje 16 kontrolnych bitów do pamiêci,
	gdzie mo¿na je zmieniaæ na przyk³ad aby zmieniæ sposób zaokr±glania liczb.</LI>
    <LI><code>FSTSW/FNSTSW</code> - zapisz do pamiêci (lub rejestru AX) s³owo statusu, czyli stan FPU</LI>
    <LI><code>FCLEX/FNCLEX</code> - wyczy¶æ wyj±tki</LI>
    <LI><code>FLDENV</code>, <code>FSTENV/FNSTENV</code> - wczytaj/zapisz ¶rodowisko (rejestry stanu,
	kontrolny i kilka innych, bez rejestrów danych). Wymaga 14 albo 28 bajtów pamiêci, w zale¿no¶ci
	 od trybu pracy procesora (rzeczywisty - DOS lub chroniony - <span lang="en">Windows</span>/Linux).</LI>
    <LI><code>FRSTOR</code>, <code>FSAVE/FNSAVE</code> - jak wy¿ej, tylko ¿e z rejestrami danych. Wymaga 94
	lub 108 bajtów w pamiêci, zale¿nie od trybu procesora.</LI>
    <LI><code>FINCSTP</code>, <code>FDECSTP</code> - zwiêksz/zmniejsz wska¼nik stosu - przesuñ st(0)
	na st(7), st(1) na st(0) itd. oraz w drug± stronê, odpowiednio.</LI>
    <LI><code>FFREE</code> - zwolnij podany rejestr danych</LI>
    <LI><code>FNOP</code> - no operation. Nic nie robi, ale zabiera czas.</LI>
    <LI><code>WAIT/FWAIT</code> - czekaj, a¿ FPU skoñczy pracê. U¿ywane do synchronizacji z CPU.</LI>
   </UL><BR><BR></LI>
</OL>






<HR>
<h2 class="nag">Przyk³ady</h2>

<P>Do¶æ ju¿ teorii, pora na przyk³ady. Programiki te wymy¶li³em pisz±c ten kurs.
</P>
<P>
Przyk³ad 1 (NASM):</P>
<BR><a href="#linux0501" class="bezdruk">(przeskocz program wy¶wietlaj±cy czêstotliwo¶æ zegara)</a>
<PRE>
; z wy¶wietlaniem:
;   nasm -O999 -f elf -o fpu1.o fpu1.asm
;   ld -s -o fpu1 fpu1.o bibl/lib/libasmio.a
; bez wy¶wietlania:
;   nasm -O999 -f elf -o fpu1.o fpu1.asm
;   ld -s -o fpu1 fpu1.o

section .text

; je¶li nie chcesz wy¶wietlania, usuñ tê linijkê ni¿ej:
%include &quot;bibl/incl/linuxbsd/nasm/std_bibl.inc&quot;

global _start

_start:
	finit			; zawsze o tym pamiêtaj !

	fild	dword [dzielna]	; ³adujemy dzieln±. st(0) = 1234DD
	fild	dword [dzielnik]; ³adujemy dzielnik. st(0) = 10000h,
				; st(1) = 1234DD
	fdivp	st1		; dzielimy. st(1) := st(1)/st(0) i pop.
				; st(0) ~= 18.2
				; FASM: fdivp st(1)

	fstp	tword [iloraz]	; zapisujemy st(0) do pamiêci i
				; zdejmujemy ze stosu

; je¶li nie chcesz wy¶wietlania, usuñ te 3 linijki ni¿ej:
	mov	edi, iloraz
	piszd80			; wy¶wietl wynik
	nwln			; przejd¼ do nowego wiersza

	mov	eax, 1
	xor	ebx, ebx
	int	80h

section .data

align 8				; NASM w tym miejscu dorobi kilka
				; NOPów (instrukcji nic nie
				; robi±cych, ale zabieraj±cych czas),
				; aby adres dzieli³ siê
				; przez 8 (patrz dalej).

dzielna		dd 1234ddh	; 4013 91a6 e800 0000 0000
dzielnik	dd 10000h

section .bss			; dane w sekcji nazwanej .BSS nie
				; bêd± fizycznie umieszczone
				; w programie, a dopiero w pamiêci.
				; Zaoszczêdzi to
				; miejsce = d³ugo¶æ pliku.
				; Mo¿na tu umieszczaæ tylko
				; niezainicjalizowane dane.

iloraz		rest 1		; rezerwacja 10 bajtów.</PRE>

<hr>
<P><a name="linux0501" id="linux0501">Teraz wersja dla FASMa</a>:</P>

	<BR><a href="#linux0502" class="bezdruk">(przeskocz ten program w wersji FASMa)</a>
<PRE>
; z wy¶wietlaniem:
;   fasm fpu1.asm
;   ld -s -o fpu1 fpu1.o bibl/lib/libasmio.a
; bez wy¶wietlania:
;   fasm fpu1.asm
;   ld -s -o fpu1 fpu1.o

format ELF

public _start

section &quot;.text&quot; executable
; je¶li nie chcesz wy¶wietlania, usuñ tê linijkê ni¿ej:
include &quot;bibl/incl/linuxbsd/fasm/std_bibl.inc&quot;

_start:
	finit			; zawsze o tym pamiêtaj !

	fild	dword [dzielna]	; ³adujemy dzieln±. st(0) = 1234DD
	fild	dword [dzielnik]; ³adujemy dzielnik. st(0) = 10000h,
				; st(1) = 1234DD
	fdivp	st1, st0	; dzielimy. st(1) := st(1)/st(0) i
				; pop. st(0) ~= 18.2
				; FASM: fdivp st(1)

	fstp	tword [iloraz]	; zapisujemy st(0) do pamiêci i
				; zdejmujemy ze stosu

; je¶li nie chcesz wy¶wietlania, usuñ te 3 linijki ni¿ej:
	mov	edi, iloraz
	piszd80			; wy¶wietl wynik
	nwln			; przejd¼ do nowego wiersza

	mov	eax, 1
	xor	ebx, ebx
	int	80h

section &quot;.data&quot; writeable align 8

dzielna		dd 1234ddh	; 4013 91a6 e800 0000 0000
dzielnik	dd 10000h

section &quot;.bss&quot; writeable
iloraz		dt 0.0</PRE>



<P><a name="linux0502" id="linux0502">Ten przyk³ad do zmiennej <q>iloraz</q></a>
 wstawia czêstotliwo¶æ zegara komputerowego (ok. 18,2 Hz) i wy¶wietla
 j± przy u¿yciu jednej z procedur z mojej biblioteki (mo¿na to usun±æ).<BR>
Nale¿y zwróciæ uwagê na zaznaczanie rozmiarów zmiennych (dword/tword).</P>
<P>Dyrektywa <q lang="en">align 8</q>
ustawia kolejn± zmienn±/etykietê tak, ¿e jej adres dzieli siê przez 8 (qword = 8 bajtów). Dziêki
temu, operacje na pamiêci s± szybsze (na przyk³ad pobranie 8 bajtów: zamiast 3 razy pobieraæ po 4 bajty,
 bo akurat tak siê
zdarzy³o, ¿e mia³a jaki¶ nieparzysty adres, pobiera siê 2x4 bajty). Rzecz jasna, skoro zmienna
<q>dzielna</q> (i <q>dzielnik</q>) ma 4 bajty, to adresy zmiennych <q>dzielnik</q> i <q>iloraz</q>
te¿ bêd± podzielne przez 4. Ci±g cyfr po ¶redniku to u³amkowa reprezentacja dzielnej. Skomplikowane,
prawda? Dlatego nie chcia³em tego omawiaæ.</P>

<hr>
<P>Przyk³ad 2: czy sinus liczby pi rzeczywi¶cie jest równy 0 (w komputerze)?</P>
	<BR><a href="#linux0503" class="bezdruk">(przeskocz program z sinusem)</a>
<PRE>
; format ELF executable		; tylko dla FASMa
; entry _start

; FASM: segment readable executable
section .text

global _start			; FASM: usun±æ

_start:
	finit			; zawsze o tym pamiêtaj !

	fldpi			; wczytujemy PI
	fsin			; obliczamy sinus z PI
	ftst			; porównujemy st(0) z zerem.
	fstsw	ax		; zapisujemy rejestr stanu
				; bezpo¶rednio w AX.


	sahf			; AH idzie do flag
	mov	ah,9		; AH=9, flagi niezmienione
	je	jest_zero	; st(0) = 0?
				; Je¶li tak, to wypisz, ¿e jest

	mov	ecx, nie_zero
	mov	edx, dlugosc_nie_zero

	jmp 	pisz

jest_zero:
	mov	ecx, zero
	mov	edx, dlugosc_zero

pisz:
	mov	eax, 4
	mov	ebx, 1
	int	80h		; wypisz jedn± z wiadomo¶ci.

	mov	eax, 1
	xor	ebx, ebx
	int	80h

; FASM: segment readable writeable
section .data

nie_zero	db	&quot;Sin(PI) != 0&quot;,0ah
dlugosc_nie_zero	equ	$ - nie_zero
		; FASM: &quot;=&quot; zamiast &quot;equ&quot;

zero		db	&quot;Sin(PI) = 0&quot;,0ah
dlugosc_zero		equ	$ - zero
		; FASM: &quot;=&quot; zamiast &quot;equ&quot;</PRE>


<hr>
<P><a name="linux0503" id="linux0503">Przyk³ad 3</a>:
 czy pierwiastek z 256 rzeczywi¶cie jest równy 16, czy 200 jest kwadratem liczby ca³kowitej?</P>
<BR><a href="#linux0504" class="bezdruk">(przeskocz ten program)</a>
<PRE>
; format ELF executable		; tylko dla FASMa
; entry _start

; FASM: segment readable executable
section .text

global _start			; FASM: usun±æ

_start:
	finit			; zawsze o tym pamiêtaj !

	fild word  [dwa_pie_sze]; st(0) = 256
	fsqrt			; st(0) = sqrt(256)
	fild word [szesnascie]	; st(0) = 16, st(1) = sqrt(256)
	fcompp			; porównaj st(0) i st(1) i
				; zdejmij oba. st: [pusty]

	fstsw	ax
	sahf

	mov	ah,9
	je	tak256
	mov	ecx, nie_256
	mov	edx, dlugosc_nie_256

	jmp	short pisz_256

tak256:
	mov	ecx, tak_256
	mov	edx, dlugosc_tak_256

pisz_256:

	mov	eax, 4
	mov	ebx, 1
	int 	80h		; wypisz stosown± wiadomo¶æ

				; do zapisu stanu stosu, czyli
				; rejestrów danych FPU mo¿na
				; u¿ywaæ takiego schematu zapisu,
				; który jest krótszy:
				; st:  (0),  (1),  (2),  ... , (7)

	fild word [dwiescie]	; st: 200
	fsqrt			; st: sqrt(200)
	fld	st0		; do st(0) wczytaj st(0).
				; st: sqrt(200), sqrt(200)
	frndint			; zaokr±glij do liczby ca³kowitej.
				; st:  (int)sqrt(200), sqrt(200)
	fcompp			; porównaj i zdejmij oba.
	fstsw ax
	sahf

	mov ah,9
	je tak200

	mov	ecx, nie_200
	mov	edx, dlugosc_nie_200

	jmp short pisz_200

tak200:
	mov	ecx, tak_200
	mov	edx, dlugosc_tak_200

pisz_200:

	mov	eax, 4
	mov	ebx, 1
	int 	80h		; wypisz stosown± wiadomo¶æ

	mov	eax, 1
	xor	ebx, ebx
	int	80h

; FASM: segment readable writeable
section .data

dwa_pie_sze	dw	256
dwiescie	dw	200
szesnascie	dw	16

nie_256		db	&quot;SQRT(256) != 16&quot;, 0ah
dlugosc_nie_256		equ	$ - nie_256
		; FASM: &quot;=&quot; zamiast &quot;equ&quot;

tak_256		db	&quot;SQRT(256) = 16&quot;, 0ah
dlugosc_tak_256		equ	$ - tak_256
		; FASM: &quot;=&quot; zamiast &quot;equ&quot;

nie_200	db &quot;Liczba 200 nie jest kwadratem liczby calkowitej&quot;, 0ah
dlugosc_nie_200		equ	$ - nie_200
		; FASM: &quot;=&quot; zamiast &quot;equ&quot;

tak_200	db &quot;Liczba 200 jest kwadratem liczby calkowitej&quot;, 0ah
dlugosc_tak_200		equ	$ - tak_200
		; FASM: &quot;=&quot; zamiast &quot;equ&quot;</PRE>

<P><a name="linux0504" id="linux0504">Dwa ostatnie programiki zbi³em</a> u siebie
 w jeden i przetestowa³em. Wysz³o, ¿e sinus PI jest ró¿ny od zera,
reszta by³a prawid³owa.</P>

<P>
Oczywi¶cie, w tych przyk³adach nie u¿y³em wszystkich instrukcji koprocesora (nawet spo¶ród tych,
które wymieni³em). Mam jednak nadziejê, ¿e te proste programy rozja¶ni± nieco sposób
pos³ugiwania siê koprocesorem.
</P>







<HR>
<h2 class="nag">Odwrotna Notacja Polska (Reverse Polish Notation, RPN)</h2>


<P>£adnie brzmi, prawda? Ale co to takiego?</P>
<P>Otó¿, bardzo dawno temu pewien polski matematyk, Jan £ukasiewicz,
wymy¶li³ taki sposób zapisywania dzia³añ, ¿e nie trzeba w nim u¿ywaæ nawiasów. By³a to notacja polska.
Sposób ten zosta³ potem dopracowany przez Charlesa Hamblina na potrzeby informatyki - w ten sposób
powsta³a <a href="http://pl.wikipedia.org/wiki/Odwrotna_notacja_polska" hreflang="pl">Odwrotna Notacja
 Polska</a>.</P>
<P>W zapisie tym argumenty dzia³ania zapisuje przed symbolem
tego dzia³ania. Dla jasno¶ci podam teraz kilka przyk³adów:</P>

	<BR><a href="#linux0508" class="bezdruk">(przeskocz przyk³ady na ONP)</a>
<PRE title="zamiana zapisu dzia³ania na postaæ ONP">
   Zapis tradycyjny		     ONP
	a+b			a b +
	a+b+c			a b + c + ; ab+ stanowi pierwszy argument
						; drugiego dodawania
	c+b+a			c b + a +
	(a+b)*c			a b + c *
	c*(a+b)			c a b + *
	(a+b)*c+d		a b + c * d +
	(a+b)*c+d*a		a b + c * d a * +
	(a+b)*c+d*(a+c)		a b + c * d a c + * +
	(a+b)*c+(a+c)*d		a b + c * a c + d * +
	(2+5)/7+3/5		2 5 + 7 / 3 5 / +</PRE>

<P><a name="linux0508" id="linux0508">Ale po co to komu i dlaczego</a> mówiê o tym akurat w tej czê¶ci?<BR>
Powód jest prosty: jak siê dobrze przyjrzeæ zapisowi dzia³ania w ONP, to mo¿na zobaczyæ, ¿e mówi
on o kolejno¶ci dzia³añ, jakie nale¿y wykonaæ na koprocesorze. Omówimy to na przyk³adzie:</P>

	<BR><a href="#linux0509" class="bezdruk">(przeskocz ilustracjê relacji miêdzy ONP a koprocesorem)</a>
<PRE title="ilustracja relacji miêdzy ONP a koprocesorem">
	Zapis tradycyjny (jeden z powy¿szych przyk³adów):
	(a+b)*c+(a+c)*d

	Zapis w ONP:
	a b + c * a c + d * +

	Uproszczony kod programu:

	fld	[a]
	fld	[b]
	faddp	st1, st0
	fld	[c]
	fmulp	st1, st0
	fld	[a]
	fld	[c]
	faddp	st1, st0
	fld	[d]
	fmulp	st1, st0
	faddp	st1, st0

	Teraz st0 jest równe warto¶ci ca³ego wyra¿enia.</PRE>

<P><a name="linux0509" id="linux0509">Jak widaæ, ONP znacznie upraszcza</a>
 przet³umaczenie wyra¿enia na kod programu. Jednak,
kod nie jest optymalny. Mo¿na by³oby na przyk³ad zachowaæ warto¶ci zmiennych a i c na stosie
i wtedy nie musieliby¶my ci±gle pobieraæ ich z pamiêci. Dlatego w krytycznych sekcjach kodu
stosowanie zasad ONP nie jest zalecane. Ale w wiêkszo¶ci przypadków Odwrotna Notacja Polska
sprawuje siê dobrze i uwalnia programistów od obowi±zku zgadywania kiedy i jakie dzia³anie
wykonaæ.</P>
<P>
Pamiêtajcie tylko, ¿e <em class="wazne">stos koprocesora mo¿e pomie¶ciæ tylko 8 zmiennych</em>!</P>

<P>
Nastêpnym razem o SIMD.</P>

<br><br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="linux04.html">Poprzednia czê¶æ kursu</a> (Alt+3)<br>
<a accesskey="4" hreflang="pl" href="linux06.html">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>



<BR><BR><HR>
<h2 class="nag">Æwiczenia</h2>
<OL>
 <LI>Napisz program, który sprawdzi (wy¶wietli stosown± informacjê), czy liczba PI dzielona
	przez sam± siebie daje dok³adne 1.0<BR><BR></LI>
 <LI>Napisz program obliczaj±cy (nie wy¶wietlaj±cy) warto¶æ 10*PI.
	Potem sprawd¼, czy sinus tej liczby jest zerem.<BR><BR></LI>
 <LI>Napisz program mówi±cy, która z tych liczb jest wiêksza: PI czy log2(10).<BR><BR></LI>
 <LI>Napisz program sprawdzaj±cy, czy 10*PI - PI - PI - PI - PI - PI = 5*PI.<BR><BR></LI>
 <LI>Zamieñ na ONP:<BR>
	a/c/d + b/c/d<BR>
	a/(c*d) + b/(c*d)<BR>
	(a+b)/c/d<BR>
	(a+b)/(c*d)<BR>
	<BR><BR></LI>
 <LI>Zamieñ z ONP na zapis tradycyjny (daszek ^ oznacza potêgowanie):<BR>
	ab*cd*e/-<BR>
	a5/c7/ed-9/*+<BR>
	a3+b/de+6^-<BR>
	dc-7b*2^/
	</LI>
</OL>

</BODY></HTML>
