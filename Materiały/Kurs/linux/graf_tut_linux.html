<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks: Rysowanie w trybie graficznym </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Rysowanie w trybie graficznym pod Linuksem">
<META NAME="Keywords" CONTENT="asm, assembler, asembler, linux, rysowanie, svgalib, drawline, drawpixel, setcolor">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Tue, Jan 18 2011 17:59:57 CEST">
</HEAD><BODY>

<h1 class="nag">Rysowanie w trybie graficznym pod Linuksem</h1>

<P>
W Linuksie oczywi¶cie nie mo¿na rysowaæ bezpo¶rednio, czyli programowaæ kartê graficzn± lub zapisywaæ
 do pamiêci ekranu (dostêpnej na przyk³ad w DOSie pod segmentem A000h). Zamiast tego, wiêkszo¶æ roboty
wykonaj± za nas
biblioteki oraz modu³y j±dra, odpowiedzialne za urz±dzenia (je¶li programujemy na przyk³ad
<span lang="en">framebuffer</span>). W tym
artykule wykorzystam mo¿liwo¶ci biblioteki <span class="b">SVGAlib</span>, ze wzglêdu na prostotê
jej opanowania, oraz z biblioteki Allegro ze wzglêdu na jej wieloplatformowo¶æ, ³atwo¶æ
u¿ywania i mo¿liwo¶æ zapisania obrazów do pliku.
</P>

<Hr>
<h2 class="nag">SVGAlib</h2>
	<BR><a href="#svgalibmmap" class="bezdruk" tabindex="1">(przeskocz do SVGAlib z
	mapowaniem pamiêci)</a>

<P>
  Aby móc korzystaæ z SVGAlib, musicie zainstalowaæ pakiety svgalib oraz svgalib-devel
  lub po prostu samemu skompilowaæ bibliotekê, je¶li pakiety nie s± dostêpne.</P>
<P>
Bêdziemy siê zajmowaæ dwoma trybami (ale nic nie stoi na przeszkodzie, aby skorzystaæ z dowolnego innego).
 Bêd± to: tryb 320x200 w 256 kolorach i oczywi¶cie tryb tekstowy (ten, do którego wrócimy
 po zakoñczeniu programu). Do ustawienia bie¿±cego trybu s³u¿y funkcja
 <span class="b">vga_<span lang="en">setmode</span></span>.
 Przyjmuje ona jeden argument - numer trybu
 (G320x200x256 = 5, TEXT = 0).</P>
<P>
Do zmiany bie¿±cego koloru s³u¿y funkcja <span class="b">vga_<span lang="en">setcolor</span></span>.
 Jedynym jej argumentem jest numer koloru (na przyk³ad
 1-niebieski, 2-zielony, 3-jasnoniebieski, 4-czerwony, 5-fioletowy, 6-br±zowy, 7-bia³y).</P>
<P>
Do narysowania pojedynczego piksela s³u¿y funkcja <span class="b">vga_<span lang="en">drawpixel</span></span>.
 Przyjmuje ona dwa argumenty. Od lewej
 (ostatni wk³adany na stos) s± to: wspó³rzêdna X oraz wspó³rzêdna Y punktu do zapalenia.
 Punkt o wspó³rzêdnych (0,0)
 to lewy górny róg ekranu.
</P>
<P>Wspó³rzêdna X ro¶nie w prawo, a Y - w dó³ ekranu.
</P>
<P>
Do narysowania linii s³u¿y funkcja <span class="b">vga_<span lang="en">drawline</span></span>.
 Przyjmuje ona 4 argumenty. Od lewej
 (ostatni wk³adany na stos) s± to: wspó³rzêdna X pocz±tku linii, wspó³rzêdna Y pocz±tku linii,
 wspó³rzêdna X koñca linii, wspó³rzêdna Y koñca linii.</P>
<P>
Aby nasz rysunek by³ widoczny choæ przez chwilê, skorzystamy z funkcji systemowej
 <span class="b">sys_nano<span lang="en">sleep</span></span>, podaj±c
 jej adres struktury timespec mówi±cej, jak d³ug± przerwê chcemy.
 Wiêcej szczegó³ów w innych artyku³ach oraz
 w <A HREF="przer80h_4.html#0162">opisie przerwania int 80h</A>.</P>
<P>
Do dzia³ania programów pod X-ami potrzebne mog± byæ uprawnienia do pliku
 <span class="b">/dev/console</span> a pod konsol± tekstow± - do pliku <span class="b">/dev/mem</span>.</P>
<P>
Jak widaæ, teoria nie jest trudna, wiêc przejd¼my od razu do przyk³adowych programów.</P>
<P>
 Pierwszy z nich ma zaprezentowaæ
 rysowanie pojedynczego piksela oraz dowolnych linii. Zwróæcie uwagê na
 <em class="wazne">sposób kompilacji</em>. Korzystamy z bibliotek
 dostêpnych dla programistów jêzyka C, wiêc do ³±czenia programu w ca³o¶æ
 najlepiej u¿yæ GCC - zajmie siê on
 do³±czeniem wszystkich niezbêdnych bibliotek. A skoro u¿ywamy gcc, to funkcja
 g³ówna zamiast _start, <em class="wazne">musi siê
 nazywaæ main</em> - tak samo jak funkcja g³ówna w programach napisanych w C.
 I tak samo, zamiast funkcji wychodzenia
 z programu, mo¿emy u¿yæ komendy RET, aby zamkn±æ program.
</P>

	<BR><a href="#graf_tut_linux01" class="bezdruk">(przeskocz program rysuj±cy linie)</a>
<PRE>
; Program do rysowania linii dowolnej z wykorzystaniem SVGAlib
;
; Autor: Bogdan D., bogdandr (at) op.pl
;
; kompilacja:
; nasm -O999 -f elf -o graf1.o graf1.asm
; gcc -o graf1 graf1.o -lvga


section .text
global	main

; reszta trybów dostêpna w /usr/include/vga.h (wymagany svgalib-devel)
%define TEXT 	     0
%define G320x200x256 5

; deklaracje funkcji zewnêtrznych:

extern	vga_setmode
extern	vga_setcolor
extern	vga_drawline
extern	vga_drawpixel

main:
	push	dword G320x200x256
	call	vga_setmode		; ustawiamy tryb graficzny:
					; 320x200 w 256 kolorach
	add	esp, 4			; zdejmujemy argument ze stosu

	push	dword 5			; ustawiamy kolor (5=fioletowy)
	call	vga_setcolor
	add	esp, 4

	push	dword 100		; wspó³rzêdna y punktu
	push	dword 160		; wspó³rzêdna x punktu
	call	vga_drawpixel		; rysujemy piksel
	add	esp, 8

	push	dword 6			; ustawiamy kolor (6=br±zowy)
	call	vga_setcolor
	add	esp, 4

	push	dword 160
	push	dword 320
	push	dword 0
	push	dword 0
	call	vga_drawline		; linia od lewego górnego
					; naro¿nika do ¶rodka prawego boku
	add	esp, 16

	push	dword 7			; ustawiamy kolor (7=bia³y)
	call	vga_setcolor
	add	esp, 4

	push	dword 10
	push	dword 20
	push	dword 110
	push	dword 50
	call	vga_drawline
	add	esp, 16

	mov	dword [t1+timespec.tv_nsec], 0
	mov	dword [t1+timespec.tv_sec], 5		; czekaj 5 sekund

	mov     eax, 162		; sys_nanosleep
	mov     ebx, t1			; adres struktury mówi±cej,
					; ile chcemy czekaæ
	mov     ecx, 0
	int     80h			; robimy przerwê...

	push	dword TEXT
	call	vga_setmode		; ustawiamy tryb tekstowy 80x25
	add	esp, 4

	xor	eax, eax		; zerowy kod zakoñczenia (bez b³êdu)
	ret				; powrót z funkcji main i
					; zakoñczenie programu

section .data


struc timespec
	.tv_sec:	resd 1
	.tv_nsec:	resd 1
endstruc

t1 		istruc timespec</PRE>

<P><a name="graf_tut_linux01" id="graf_tut_linux01">Drugi program rysuje okr±g</a>. ¦rodek tego
okrêgu jest w ¶rodku ekranu, kolejne punkty (³±cznie bêdzie ich 360)
 obliczam nastêpuj±co: wspó³rzêdna x = wspó³rzêdna x ¶rodka + r*cos(t),
 y = y_¶rodka + r*sin(t), po przerobieniu
 k±ta t na radiany. Do liczenia tych sinusów i kosinusów wykorzystujê FPU.</P>

	<BR><a href="#svgalibmmap" class="bezdruk">(przeskocz program rysuj±cy okr±g)</a>
<PRE>
; Program do rysowania okrêgu z wykorzystaniem SVGAlib
;
; Autor: Bogdan D., bogdandr (at) op.pl
;
; kompilacja:
; nasm -O999 -f elf -o kolo_linux.o kolo_linux.asm
; gcc -o kolo_linux kolo_linux.o -lvga


section .text
global	main

; reszta trybów dostêpna w /usr/include/vga.h (wymagany svgalib-devel)
%define TEXT 	     0
%define G320x200x256 5

extern	vga_setmode
extern	vga_setcolor
extern	vga_drawpixel

main:
	push	dword G320x200x256
	call	vga_setmode		; ustawiamy tryb graficzny:
					; 320x200 w 256 kolorach
	add	esp, 4			; zdejmujemy argument ze stosu

	push	dword 2			; ustawiamy kolor
	call	vga_setcolor
	add	esp, 4

	mov	ebx, 360

	finit				; poni¿ej bêdê zapisywa³ stan
					; rejestrów FPU, od st0 do st7
	fldpi				; pi
	fild	word [sto80]		; 180, pi

	fdivp	st1, st0		; pi/180

	fld1				; 1, pi/180
	fild	word [r]		; r, 1, pi/180
	fldz				; k±t=0, r, 1, pi/180

rysuj:
	fld	st0			; k±t, k±t, r, 1, pi/180

	fmul	st4			; k±t w radianach

	fsin				; sin(k±t), k±t, r, 1, pi/180
	fmul	st2			; sin(k±t)*r, k±t, r, 1, pi/180

	fistp	dword [wys]		; k±t, r, 1, pi/180

	fld	st0			; k±t, k±t, r, 1, pi/180
	fmul	st4			; k±t w radianach
	fcos				; cos(k±t), k±t, r, 1, pi/180
	fmul	st2			; r*cos(k±t), k±t, r, 1, pi/180

	fistp	dword [szer]		; k±t, r, 1, pi/180

	mov	eax, [wys]
	mov	edx, [szer]
	add	eax, 100		; dodajemy wspó³rzêdn± y ¶rodka
	add	edx, 160		; dodajemy wspó³rzêdn± x ¶rodka
	push	eax			; umieszczamy wspó³rzêdne na stosie
	push	edx
	call	vga_drawpixel		; rysujemy piksel
	add	esp, 8

	fadd	st0, st2		; k±t = k±t + 1

	dec	ebx
	jnz	rysuj

	mov	dword [t1+timespec.tv_nsec], 0
	mov	dword [t1+timespec.tv_sec], 5		; 5 sekund

	mov     eax, 162		; sys_nanosleep
	mov     ebx, t1			; adres struktury mówi±cej,
					; ile chcemy czekaæ
	mov     ecx, 0
	int     80h			; robimy przerwê...

	push	dword TEXT
	call	vga_setmode		; ustawiamy tryb tekstowy 80x25
	add	esp, 4

	xor	eax, eax		; zerowy kod zakoñczenia (bez b³êdu)
	ret				; powrót z funkcji main

section .data


struc timespec
	.tv_sec:	resd 1
	.tv_nsec:	resd 1
endstruc

t1 		istruc timespec

r		dw	50		; promieñ okrêgu
szer		dd	0
wys		dd	0
sto80		dw	180</PRE>






<Hr>
<h2 class="nag"><a name="svgalibmmap" id="svgalibmmap">SVGAlib z mapowaniem pamiêci</a></h2>
	<BR><a href="#allegro" class="bezdruk" tabindex="1">(przeskocz do Allegro)</a>

<P>
  Aby móc korzystaæ z SVGAlib, musicie zainstalowaæ pakiety svgalib oraz svgalib-devel
  lub po prostu samemu skompilowaæ bibliotekê, je¶li pakiety nie s± dostêpne.</P>
<P>
UWAGA: zmieni siê sposób kompilacji programu w stosunku do tradycyjnych, asemblerowych programów.
Korzystamy z bibliotek dostêpnych dla programistów jêzyka C, wiêc do ³±czenia programu
w ca³o¶æ najlepiej u¿yæ GCC - zajmie siê on do³±czeniem wszystkich niezbêdnych bibliotek.
A skoro u¿ywamy gcc, to funkcja g³ówna zamiast _start, <em class="wazne">musi siê
nazywaæ main</em> - tak samo
jak funkcja g³ówna w programach napisanych w C. I tak samo, zamiast funkcji wychodzenia
z programu, mo¿emy u¿yæ komendy RET, aby zamkn±æ program. Sama kompilacja przebiega
nastêpuj±co:</P>
<pre>
	nasm -O999 -f elf -o graf2.o graf2.asm
	gcc -o graf2 graf2.o -lvga
</pre>
<P>
Bêdziemy siê zajmowaæ dwoma trybami (ale nic nie stoi na przeszkodzie,
 aby skorzystaæ z dowolnego innego).
 Bêd± to: tryb 320x200 w 256 kolorach i oczywi¶cie tryb tekstowy (ten, do którego wrócimy
 po zakoñczeniu programu). Do ustawienia bie¿±cego trybu s³u¿y funkcja
 <span class="b">vga_<span lang="en">setmode</span></span>.
 Przyjmuje ona jeden argument - numer trybu
 (G320x200x256 = 5, TEXT = 0).</P>
<P>
Przed rozpoczêciem pracy ustawiamy tryb graficzny 320x200, wykonuj±c</P>
<pre>
	extern	vga_setmode
		...
		push	dword 5			; G320x200x256
		call	vga_setmode		; ustawiamy tryb graficzny:
						; 320x200 w 256 kolorach
		add	esp, 4			; zdejmujemy argument ze stosu</pre>

<P>Ale teraz zajmiemy siê rysowaniem bez funkcji SVGAlib, poprzez zapis do odpowiednich
komórek pamiêci. Pamiêæ trybów graficznych znajduje siê w segmencie A000, co odpowiada liniowemu
adresowi A0000, licz±c od adresu 0. Oczywi¶cie system, ze wzglêdów bezpieczeñstwa, nie
pozwoli nam bezpo¶rednio pisaæ pod ten adres, wiêc musimy sobie poradziæ w inny sposób.
Sposób ten polega na otwarciu specjalnego pliku urz±dzenia, który symbolizuje ca³± pamiêæ
w komputerze - <span class="b">/dev/mem</span>. Na wiêkszo¶ci systemów otwarcie tego pliku
wymaga uprawnieñ administratora.</P>
<P>Po otwarciu pliku mamy dwie mo¿liwo¶ci. Pierwsza to
poruszaæ siê po nim funkcjami do zmiany pozycji w pliku, oraz odczytywaæ i zapisywaæ
funkcjami odczytu i zapisu danych z i do pliku. Mo¿e to byæ powolne, ale sposób jest.
Druga mo¿liwo¶æ to zmapowaæ plik do pamiêci, po czym korzystaæ z niego jak ze zwyk³ej
tablicy. Tê mo¿liwo¶æ opiszê teraz szczegó³owo.
</P>
<P>Otwieranie pliku odbywa siê za pomoc± tradycyjnego wywo³ania:</P>
<pre>
	mov	eax, 5		; sys_open
	mov	ebx, pamiec	; adres nazwy pliku "/dev/mem", 0
	mov	ecx, 2		; O_RDWR, zapis i odczyt
	mov	edx, 666o	; pe³ne prawa
	int	80h
	...
	pamiec		db	"/dev/mem", 0</pre>

<P>Drugim krokiem jest zmapowanie naszego otwartego pliku do pamiêci. Odbywa siê to za
pomoc± funkcji systemowej <span class="b">sys_mmap2</span>. Przyjmuje ona 6 argumentów:</P>
<ol>
 <li>EBX = adres, pod jaki chcieliby¶my zmapowaæ plik. Najlepiej podaæ zero, wtedy system sam
 	wybierze dogodny adres</li>
 <li>ECX = d³ugo¶æ mapowanego obszaru pliku, w bajtach. Podamy to 100000h, by na pewno
 	obj±æ obszar zaczynaj±cy siê A0000 i d³ugo¶ci 64000 bajtów (tyle, ile trzeba na jeden
 	ekran w trybie 320x200)</li>
 <li>EDX = tryb dostêpu do zmapowanej pamiêci. Je¶li chcemy odczyt i zapis, podamy tutaj
 	PROT_READ=1 + PROT_WRITE=2</li>
 <li>ESI = tryb wspó³dzielenia zmapowanej pamiêci. Podamy tu MAP_SHARED=1 (wspó³dzielona,
 	nie prywatna)</li>
 <li>EDI = deskryptor otwartego pliku, który chcemy zmapowaæ</li>
 <li>EBP = adres pocz±tkowy w pliku, od którego mapowaæ. Adres ten jest podawany w
 	jednostkach strony systemowej, której wielko¶æ mo¿e byæ ró¿na na ró¿nych systemach.
 	Naj³atwiej podaæ tu zero, a do adresów dodawaæ potem A0000</li>
</ol>
<P>Po pomy¶lnym wykonaniu, system zwróci nam w EAX adres zmapowanego obszaru pamiêci, którego
mo¿emy u¿ywaæ (w przypadku b³êdu otrzymujemy warto¶æ od -4096 do -1 w³±cznie).
Przyk³adowe wywo³anie wygl±da wiêc tak:</P>
<pre>
	mov	eax, 192		; sys_mmap2
	xor	ebx, ebx		; j±dro wybierze adres
	mov	ecx, 100000h		; d³ugo¶æ mapowanego obszaru
	mov	edx, 3			; PROT_READ | PROT_WRITE, mo¿liwo¶æ
					; zapisu i odczytu
	mov	esi, 1			; MAP_SHARED - tryb wspó³dzielenia
	mov	edi, [deskryptor]	; deskryptor pliku pamiêci, otrzymany
					; z sys_open w poprzednim kroku
	mov	ebp, 0			; adres pocz±tkowy w pliku
	int	80h
</pre>
<P>Teraz wystarczy ju¿ korzystaæ z otrzymanego wska¼nika, na przyk³ad:</P>
<pre>	mov	byte [eax+0a0000h], 7</pre>

<P>Kolejne adresy w pamiêci oznaczaj± kolejne piksele okre¶lonego wiersza. Po przekroczeniu
320 bajtów, kolejny bajt oznacza pierwszy piksel kolejnego wiersza i tak dalej.
</P>
<P>Bajty zapisywane w pamiêci (czyli kolory pikseli) maj± takie same warto¶ci, jak w tradycyjnym
podej¶ciu: 1-niebieski, 2-zielony, 3-jasnoniebieski, 4-czerwony, 5-fioletowy, 6-br±zowy, 7-bia³y.
</P>
<P>Zmiany, które zapiszemy w pamiêci, mog± jednak nie od razu pojawiæ siê w pliku (czyli
na ekranie w tym przypadku). Aby wymusiæ fizyczny zapis danych, korzysta siê z funkcji
<span class="b">sys_msync</span>. Przyjmuje ona 3 argumenty:</P>
<ol>
 <li>EBX = adres pocz±tku danych do synchronizacji</li>
 <li>ECX = liczba bajtów do zsynchronizowania</li>
 <LI>EDX = 0 lub zORowane flagi: MS_ASYNC=1 (wykonaj asynchronicznie), MS_INVALIDATE=2
 	(uniewa¿nij obszar po zapisaniu), MS_SYNC (wykonaj synchronicznie)</li>
</ol>
<P>Przyk³adowe wywo³anie wygl±da wiêc tak:</P>
<pre>
	mov	eax, 144		; sys_msync
	mov	ebx, 0a0000h		; adres startowy
	mov	ecx, 4000		; ile zsynchronizowaæ
	mov	edx, 0			; flagi
	int	80h</pre>

<P>Po zakoñczeniu pracy nale¿y przywróciæ tryb tekstowy:</P>
<pre>
	push	dword 0			; TEXT
	call	vga_setmode		; ustawiamy tryb tekstowy 80x25
	add	esp, 4</pre>

<P>oraz odmapowaæ plik:</P>
<pre>
	mov	eax, 91			; sys_munmap
	mov	ebx, [wskaznik]		; wska¼nik otrzymany z sys_mmap2
	mov	ecx, 100000h		; liczba bajtów
	int	80h</pre>

<P>i zamkn±æ go:</P>
<pre>
	mov	eax, 6			; sys_close
	mov	ebx, [deskryptor]	; deskryptor pliku "/dev/mem"
	int	80h</pre>

<P>Je¶li Wasza grafika ma czêsto siê zmieniaæ (na przyk³ad jest to animacja), to pisanie
bezpo¶rednio do zmapowanej pamiêci
(lub pamiêci wideo, je¶li macie dostêp) mo¿e byæ zbyt powolne, by efekty graficzne by³y
zadowalaj±ce. Ale mo¿na to obej¶æ na dwa sposoby: uruchamiaæ <span class="b">sys_msync</span>
dopiero po zape³nieniu ca³ego ekranu lub ca³y ekran najpierw zbudowaæ sobie w osobnym
buforze, po czym jednym ruchem wrzuciæ ca³y ten bufor do zmapowanej pamiêci czy pamiêci
wideo.
</P>
<P>
Jak widaæ, mapowanie plików do pamiêci jest wygodne, gdy¿ nie trzeba ci±gle skakaæ po pliku
funkcj± <span class="b">sys_lseek</span> i wykonywaæ kosztownych czasowo wywo³añ innych funkcji
systemowych. Warto wiêc siê z tym zaznajomiæ. Nale¿y jednak pamiêtaæ, ¿e nie wszystkie
pliki czy urz±dzenia daj± siê zmapowaæ do pamiêci - nie nale¿y wtedy zamykaæ swojego
programu z b³êdem, lecz korzystaæ z tradycyjnego interfejsu funkcji plikowych.
</P>





<br>
<Hr>
<h2 class="nag"><a name="allegro" id="allegro">Allegro</a></h2>

<P>
Biblioteka <acronym lang="en" title="Allegro Low-LEvel Game ROutines">Allegro</acronym>
powinna na wiêkszo¶ci systemów byæ dostêpna jako gotowy pakiet, ale w razie czego
mo¿na j± pobraæ na przyk³ad ze strony <a href="http://alleg.sourceforge.net"
hreflang="pl">alleg.sf.net</a>.
</P>
<P>Pierwszymi funkcjami, jakie w ogóle nale¿y uruchomiæ przez rozpoczêciem czegokolwiek s±
<span class="b" lang="en">install_allegro</span> (w jêzyku C - allegro_init)
 i <span class="b" lang="en">install_keyboard</span>.</P>
<P>
Pierwsza s³u¿y do inicjalizacji biblioteki. Jako parametry oczekuje: liczbê SYSTEM_AUTODETECT=0,
adres zmiennej do przechowywania b³êdów (ale uwaga, próba deklaracji i u¿ycia
<span class="b" lang="en">errno</span> w naszym programie mo¿e skoñczyæ siê b³êdem linkera,
wiêc lepiej podaæ adres jakiego¶ naszego w³asnego DWORDa) oraz wska¼nika na elementy
uruchamiane przy wyj¶ciu (u nas wpiszemy NULL). Druga funkcja nie przyjmuje ¿adnych argumentów,
a s³u¿y do
instalacji funkcji odpowiedzialnych za dzia³anie klawiatury. Allegro samo zajmuje siê klawiatur±,
wiêc standardowe funkcje czytania z klawiatury mog± nie dzia³aæ. Do czytania klawiszy
s³u¿y funkcja <span class="b" lang="en">readkey</span>. Nie przyjmuje ona ¿adnych argumentów,
a zwraca warto¶æ przeczytanego klawisza.
</P>
<P>
Biblioteka pozwala na ustawienie wielu rozdzielczo¶ci, my zajmiemy siê rozdzielczo¶ci±
640x480 w 8-bitowej g³êbi kolorów. Do ustawienia g³êbi kolorów s³u¿y funkcja
<span class="b" lang="en">set_color_depth</span> przyjmuj±ca jeden argument - warto¶æ
owej g³êbi, czyli w naszym przypadku 8.</P>
<P>
Po inicjalizacji biblioteki, instalacji klawiatury i ustawieniu g³êbi kolorów mo¿na
przyst±piæ do ustawienia trybu graficznego. Robi siê to za pomoc± funkcji
<span class="b" lang="en">set_gfx_mode</span>. Przyjmuje ona 5 argumentów: sterownik
(u nas bêdziemy korzystaæ z autowykrywania, wpisuj±c tu liczbê GFX_AUTODETECT=0),
szeroko¶æ ¿±danego trybu w pikselach, wysoko¶æ trybu, szeroko¶æ okna widoku i
wysoko¶æ okna widoku. U nas oknem widoku bêdzie ca³y ekran, wiêc ostatnie dwa
parametry przyjm± warto¶æ zero, a ca³e wywo³anie (w jêzyku C) bêdzie mia³o postaæ:
</P>
<pre>		set_gfx_mode ( GFX_AUTODETECT, 640, 480, 0, 0 );</pre>
<P>
Je¶li ustawienie rozdzielczo¶ci siê nie powiedzie, wywo³anie funkcji zwróci warto¶æ niezerow±.
</P>
<P>
Po skoñczeniu pracy z Allegro nale¿y wywo³aæ funkcjê <span class="b" lang="en">allegro_exit</span>
w celu zamkniêcia i odinstalowania biblioteki z programu. Funkcja ta nie przyjmuje
¿adnych argumentów.
</P>
<P>
Aby ustawiæ domy¶ln± paletê kolorów, wywo³ujemy funkcjê
<span class="b" lang="en">set_palette</span>. Jako jej jedyny parametr podajemy zewnêtrzn±
(pochodz±c± z Allegro) zmienn± <span class="b" lang="en">default_palette</span>.
</P>
<P>
Do czyszczenia ekranu (a w³a¶ciwie wype³nienia go okre¶lonym kolorem) s³u¿y funkcja
<span class="b" lang="en">clear_to_color</span>. Jej pierwszy parametr mówi, co ma zostaæ
wyczyszczone - u nas chcemy wyczy¶ciæ ca³y ekran, wiêc bêdzie to zmienna z Allegro o
nazwie <span class="b" lang="en">screen</span>. Drugi parametr tej funkcji to kolor,
jakim chcemy wype³niæ ekran. Zero oznacza czarny.
</P>
<P>
Do wy¶wietlania tekstu na ekranie w trybie tekstowym s³u¿y funkcja
<span class="b" lang="en">allegro_message</span>. Jej jedyny argument to tekst do wy¶wietlenia.
Aby wy¶wietliæ tekst w trybie graficznym, najpierw nale¿y podj±æ decyzjê, czy tekst
ma byæ na tle, czy t³o ma go przykryæ. Je¶li t³o ma byæ pod tekstem, nale¿y jednorazowo wywo³aæ
<span class="b" lang="en">text_mode</span>, jako parametr podaj±c liczbê -1 (minus jeden).
Potem mo¿na ju¿ wy¶wietlaæ tekst funkcj± <span class="b" lang="en">textout</span>. Przyjmuje
ona 5 argumentów: gdzie wy¶wietliæ (u nas znów <span lang="en">screen</span>), jak± czcionk±
(skorzystamy z domy¶lnej czcionki w zmiennej Allegro o nazwie <span class="b" lang="en">font</span>),
co wy¶wietliæ (adres naszego napisu), wspó³rzêdna X, wspó³rzêdna Y oraz ¿±dany kolor.
</P>
<P>
Wspó³rzêdna X ro¶nie w prawo, a Y - w dó³ ekranu.</P>
<P>
Ale przejd¼my wreszcie do wy¶wietlania podstawowych elementów.<br>
Liniê wy¶wietla siê funkcj± <span class="b" lang="en">line</span>, przyjmuj±c± 6
argumentów: gdzie wy¶wietliæ (tak, znowu <span lang="en">screen</span>), wspó³rzêdna X
pocz±tku, wspó³rzêdna Y pocz±tku, wspó³rzêdna X koñca, wspó³rzêdna Y koñca, kolor.<br>
Kolor, jak w ka¿dej innej funkcji, mo¿emy podawaæ rêcznie jako liczbê, ale mo¿emy te¿
uruchomiæ funkcjê <span class="b" lang="en">makecol</span>, podaj±c jej warto¶ci od 0
do 255 kolejno dla kolorów: czerwonego, zielonego, niebieskiego, a wynik tej funkcji
podajemy tam, gdzie podaliby¶my kolor.<br>
Okrêgi wy¶wietla siê funkcj± <span class="b" lang="en">circle</span>, przyjmuj±c±
5 argumentów: gdzie wy¶wietliæ (i znowu <span lang="en">screen</span>), wspó³rzêdna X
¶rodka, wspó³rzêdna Y ¶rodka, promieñ i kolor.
</P>
<P>
Po omówieniu tego, co ma byæ w programie jeszcze dwa s³owa o tworzeniu programu.
O ile kompilacja pliku w asemblerze jest taka jak zawsze, to linkowanie najlepiej
przeprowadziæ za pomoc± GCC. Normalnie nasz± funkcjê g³ówna nazwaliby¶my <span lang="en">main</span>,
ale Allegro posiada w³asn± funkcjê <span lang="en">main</span>, a oczekuje, ¿e nasza
funkcja g³ówna bêdzie sie nazywaæ <span lang="en">_mangled_main</span> (z podkre¶leniem
z przodu). Ponadto, Allegro oczekuje, ¿e zadeklarujemy zmienn± globaln±
<span lang="en">_mangled_main_address</span> i wpiszemy do niej adres
<span lang="en">_mangled_main</span>. W jêzyku C robi to za nas makro
<span lang="en">END_OF_MAIN</span>.
</P>
<P>
Niektóre wersje biblioteki Allegro mog± od nas jednak
wymagaæ, aby¶my to my mieli funkcjê <span lang="en">main</span> - je¶li
w czasie linkowania wyst±pi b³±d, to wystarczy
w³±czyæ dwie odpowiednio oznaczone linijki w poni¿szym programie.
</P>
<P>Program linkuje siê nastêpuj±c± komend±:</P>
<pre>		gcc -o program program.o `allegro-config --libs`</pre>
<P>
Zwróæcie uwagê na odwrotne apostrofy. Sprawi± one, ¿e wynik zawartej w nich komendy
(a wiêc niezbêdne biblioteki) zostanie przekazany do GCC, dziêki czemu znajdzie on
wszystko, co potrzeba.
</P>
<P>
A oto przyk³adowy program. Wy¶wietla on tekst, liniê i okr±g, po czym czeka na naci¶niêcie
jakiegokolwiek klawisza. Po naci¶niêciu klawisza biblioteka Allegro jest zamykana i program
siê koñczy.</P>
	<BR><a href="#graf_koniec" class="bezdruk">(przeskocz przyk³adowy program Allegro)</a>
<pre>
; Program demonstracyjny biblioteki Allegro
;
; Autor: Bogdan D., bogdandr (at) op.pl
;
; kompilacja:
; nasm -O999 -f elf -o graf2.o graf2.asm
; gcc -o graf2 graf2.o `allegro-config --libs`

section .text
; wymagane przez Allegro:
;global main		; TO W£¡CZYÆ, JE¦LI ALLEGRO WYMAGA FUNKCJI MAIN
global _mangled_main
global _mangled_main_address

; deklaracje elementów zewnêtrznych:
extern	install_allegro
extern	install_keyboard
extern	set_color_depth
extern	set_gfx_mode
extern	allegro_exit
extern	text_mode
extern	set_palette
extern	default_palette
extern	clear_to_color
extern	screen
extern	textout
extern	font
extern	line
extern	makecol
extern	circle
extern	readkey

%define GFX_AUTODETECT 0		; autowykrywanie sterownika

;main:			; TO W£¡CZYÆ, JE¦LI ALLEGRO WYMAGA FUNKCJI MAIN
_mangled_main:
	; inicjalizacja biblioteki:
	push	dword 0
	push	err			; nasza zmienna do b³êdów
	push	dword 0
	call	install_allegro
	add	esp, 3*4		; zdjêcie parametrów ze stosu

	; instalacja klawiatury
	call	install_keyboard

	; ustawienie g³êbi kolorów:
	push	dword 8
	call	set_color_depth
	add	esp, 1*4		; zdjêcie parametrów ze stosu

	; ustawienie rozdzielczo¶ci:
	push	dword 0			; wysoko¶æ okna
	push	dword 0			; szeroko¶æ okna
	push	dword 480		; wysoko¶æ ca³ego trybu
	push	dword 640		; szeroko¶æ ca³ego trybu
	push	dword GFX_AUTODETECT
	call	set_gfx_mode
	add	esp, 5*4

	; sprawd¼, czy siê uda³o
	cmp	eax, 0
	jne	koniec

	; ustaw t³o pod tekstem
	push	dword -1
	call	text_mode
	add	esp, 1*4

	; ustaw domy¶ln± paletê
	push	dword default_palette
	call	set_palette
	add	esp, 1*4

	; wyczy¶æ ekran
	push	dword 0			; czy¶æ na czarno
	push	dword [screen]		; co czy¶ciæ
	call	clear_to_color
	add	esp, 2*4

	; wy¶wietl napis
	push	dword 15		; kolor
	push	dword 10		; wspó³rzêdna Y
	push	dword 10		; wspó³rzêdna X
	push	dword napis		; napis do wy¶wietlenia
	push	dword [font]		; czcionka
	push	dword [screen]		; gdzie wy¶wietliæ
	call	textout
	add	esp, 6*4

	; stwórz kolor bia³y do narysowania linii
	push	dword 255		; sk³adowa niebieska
	push	dword 255		; sk³adowa zielona
	push	dword 255		; sk³adowa czerwona
	call	makecol
	add	esp, 3*4

	; narysuj liniê
	push	eax			; kolor
	push	dword 240		; wspó³rzêdna Y koñca
	push	dword 320		; wspó³rzêdna X koñca
	push	dword 400		; wspó³rzêdna Y pocz±tku
	push	dword 540		; wspó³rzêdna X pocz±tku
	push	dword [screen]
	call	line
	add	esp, 6*4

	; stwórz kolor zielony do narysowania ko³a
	push	dword 0
	push	dword 255
	push	dword 0
	call	makecol
	add	esp, 3*4

	; narysuj ko³o
	push	eax			; kolor
	push	dword 20		; promieñ
	push	dword 240		; wspó³rzêdna Y ¶rodka
	push	dword 320		; wspó³rzêdna X ¶rodka
	push	dword [screen]
	call	circle
	add	esp, 5*4

	; czekaj na klawisz
	call	readkey

koniec:
	; zamknij Allegro
	call	allegro_exit
	; powróæ z naszej funkcji g³ównej
	ret

section .data
napis			db	"Allegro", 0	; napis do wy¶wietlenia
_mangled_main_address	dd	_mangled_main	; wymagane
err			dd	0		; nasza zmienna b³êdów</pre>

<P>Jak widaæ, biblioteka Allegro jest tylko trochê trudniejsza od SVGAlib, ale jej mo¿liwo¶ci s±
znacznie wiêksze. Tutaj pokaza³em tylko u³amek grafiki dwuwymiarowej. Allegro
potrafi te¿ wy¶wietlaæ grafikê trójwymiarow±, wyliczaæ transformacje, zapisywaæ
wy¶wietlane obrazy do pliku oraz odtwarzaæ muzykê (w koñcu to jest biblioteka do gier,
nie tylko graficzna). Jak widzicie, jest jeszcze wiele mo¿liwo¶ci przed Wami do odkrycia.
Mi³ej zabawy!</P>

<br>
<div class="bezdruk">
<A accesskey="1" hreflang="pl" href="../index.htm" name="graf_koniec" id="graf_koniec">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

</BODY></HTML>
