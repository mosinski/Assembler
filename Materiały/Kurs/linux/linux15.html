<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks, czê¶æ 15 - Bloki kontrolne </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Prev"     hreflang="pl" lang="en" href="linux14.html" >
<link rel="Next"     hreflang="pl" lang="en" href="linux16.html" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="kurs, asm, asembler, assembler, if, else, switch, case, for, do,
	 while, linux, linuks">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Tue, Jan 18 2011 17:59:58 CEST">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler pod Linuksem?<BR>
	<h1 class="nag">Czê¶æ 15 - Pêtle i warunki -
		czyli o tym, jak u¿ywaæ	bloków kontrolnych</h1></div>

<P>
Wszystkie jêzyki wysokiego poziomu maj± pewne bloki kontrolne i pêtle, co mo¿e w oczach
niektórych osób stanowiæ przewagê nad asemblerem. Dlatego teraz poka¿ê, jak przepisaæ
te wszystkie struktury z wykorzystaniem asemblera, czêsto uzyskuj±c kod lepszy ni¿ ten
wytworzony przez kompilatory jêzyków wy¿szego poziomu.<BR>
Zanim zaczniemy, dodam, ¿e nie ka¿dy jêzyk wysokiego poziomu posiada opcje kompilacji
warunkowej (co¶ w stylu #ifdef w jêzyku C), ale za to KA¯DY dobry kompilator
jêzyka asembler ma tak± opcjê wbudowan±! Po szczegó³y odsy³am do instrukcji posiadanego
kompilatora.
</P>






<HR>

<h2 class="nag">Bloki decyzyjne (warunkowe) <q lang="en">if/else if/else</q>.</h2>

	<BR><a href="#petle" tabindex="1" class="bezdruk">(przeskocz bloki warunkowe)</a>
<P>
Przet³umaczenie czego¶ takiego na asembler nie jest trudne i opiera siê na instrukcjach
<code>CMP</code> oraz odpowiednich skokach warunkowych. Poka¿ê to na przyk³adzie (bêdê u¿ywa³ sk³adni
jêzyka C, gdy¿ posiada wszystkie struktury, które chcia³bym omówiæ):</P>

	<BR><a href="#linux1501" class="bezdruk">(przeskocz schemat bloku <span lang="en">if/else</span>)</a>
<PRE title="przyk³ad bloku if/else">
	if (a == b)		/* czy a jest równe b? */
	{
		/* czê¶æ 1 */
	}
	else if (a == c)
	{
		/* czê¶æ 2 */
	}
	else
	{
		/* czê¶æ 3 */
	}</PRE>

<P><a name="linux1501" id="linux1501">Powy¿szy kod mo¿na po prostu zast±piæ</a> czym¶ takim
(zak³adam zmienne 32-bitowe):</P>

	<BR><a href="#linux1502" class="bezdruk">(przeskocz asemblerowy schemat bloku <span lang="en">if/else</span>)</a>
<PRE title="kod zamienny w asemblerze dla bloku if/else">
		mov	eax, [a]
		cmp	eax, [b]
		jne	elseif1

		; czê¶æ 1

		jmp	po_if1
	elseif1:
		cmp	eax, [c]	; pamiêtajmy, ¿e [a] ju¿ jest w EAX
		jne	else1

		; czê¶æ 2

		jmp	po_if1
	else1:

		; czê¶æ 3

	po_if1:</PRE>

<P><a name="linux1502" id="linux1502">Na szczególn± uwagê zas³uguje przypadek</a>
 porównywania zmiennej do zera, gdzie zamiast instrukcji
&nbsp;<code>CMP EAX, 0</code> u¿yjemy instrukcji &nbsp;<code>TEST EAX, EAX</code>.<BR>
Je¶li za¶ trafi siê Wam do¶æ prosty kod w stylu:</P>

	<BR><a href="#linux1503" class="bezdruk">(przeskocz przyk³ad <span lang="en">if/else</span>)</a>
<PRE title="drugi przyk³ad bloku if/else">
	if (a == b)		/* czy a jest równe b? */
	{
		d = a;		/* wstaw warto¶æ a do d */
	}
	else if (a == c)
	{
		d = b;
	}
	else
	{
		d = 0;
	}</PRE>

<P><a name="linux1503" id="linux1503">lub wyra¿enie warunkowe</a>, czyli co¶ postaci:</P>
<PRE title="wyra¿enie warunkowe">		d = (a == b)? a : 0;</PRE>

<P>To mo¿ecie (a nawet powinni¶cie) u¿yæ instrukcji warunkowego kopiowania danych <code>CMOV*</code>.
Instrukcje te powoduj± znacznie wydajniejsz± pracê procesora (który ju¿ nie musi co dwie
instrukcje skakaæ i czytaæ nowych instrukcji).
Pierwszy fragment kodu po przet³umaczeniu móg³by wygl±daæ tak:</P>

	<BR><a href="#linux1504" class="bezdruk">(przeskocz t³umaczenie przyk³adu <span lang="en">if/else</span>)</a>
<PRE title="kod w asmie równowa¿ny drugiemu przyk³adowi">
	xor	edx, edx	; domy¶lna warto¶æ, któr± wstawimy
				; do zmiennej D wynosi zero

	mov	eax, [a]
	cmp	eax, [b]
	cmove	edx, eax	; gdy a == b, to do EDX wstaw
				; warto¶æ A, czyli EAX

	cmp	eax, [c]
	cmove	edx, [b]	; gdy a == c, to do EDX wstaw warto¶æ B

	mov	[d], edx	; do D wstaw wynik operacji
				; (A, B lub domy¶lne 0)</PRE>

<P><a name="linux1504" id="linux1504">A drugi</a>:</P>
	<BR><a href="#linux1505" class="bezdruk">(przeskocz t³umaczenie wyra¿enia warunkowego)</a>
<PRE title="kod w asmie równowa¿ny wyra¿eniu warunkowemu">
	xor	edx, edx	; domy¶lna warto¶æ to 0

	mov	eax, [a]
	cmp	eax, [b]	; porównaj A z B

	cmove	edx, eax	; gdy równe, to EDX=[a]

	mov	[d], edx	; do D wstaw wynik operacji</PRE>

<P><a name="linux1505" id="linux1505">Tylko nowoczesne kompilatory</a> jêzyka C potrafi± wyczyniaæ
takie sztuczki.<BR> Podobne instrukcje istniej± tak¿e dla liczb i rejestrów zmiennoprzecinkowych:
<code>FCMOV*</code>.</P>

<HR>










<h2 class="nag"><a name="petle" id="petle">Pêtle.</a></h2>

	<BR><a href="#switch" class="bezdruk">(przeskocz pêtle)</a>

<P>
Z pêtlami jest trochê gorzej, gdy¿ jest ich wiêcej rodzajów.<BR>
Zacznijmy od pêtli o znanej z góry ilo¶ci przej¶æ (powtórzeñ, iteracji), czy pêtli typu</P>
<PRE>	for (wyra¿enia pocz±tkowe; warunek wykonywania; wyra¿enie koñcowe)</PRE>
<P>Na przyk³ad:</P>
	<BR><a href="#linux1506" class="bezdruk">(przeskocz przyk³ad pêtli for)</a>
<PRE title="przyk³ad pêtli for">
	for (i=1; i&lt;10; i=i+1)
	{
		j=j+i;
	}</PRE>
<P><a name="linux1506" id="linux1506">zosta³oby przet³umaczone na</a>:</P>
	<BR><a href="#linux1507" class="bezdruk">(przeskocz t³umaczenie tego przyk³adu)</a>
<PRE title="t³umaczenie pêtli for na asembler">
		mov	ecx, 1		; ECX to zmienna I. i=1
	petla_for:
		cmp	ecx, 10
		jae	koniec_petli	; wychodzimy, gdy i &gt;= 10

		add	eax, ecx	; EAX to zmienna J. j=j+i

		add	ecx, 1		; i=i+1
		jmp	short petla_for
	koniec_petli:</PRE>

<P><a name="linux1507" id="linux1507">Je¶li warunkiem zakoñczenia pêtli</a> jest to, ¿e pewna zmienna
osi±gnie zero, mo¿na stosowaæ instrukcjê <code><span lang="en">LOOP</span></code>. Przyk³ad:
	<BR><a href="#linux1508" class="bezdruk">(przeskocz drug± pêtlê for)</a>
<PRE title="drugi przyk³ad pêtli for">
	for (i=10; i&gt;0; i--)
	{
		j=j+i;
	}</PRE>

<P><a name="linux1508" id="linux1508">mo¿e zostaæ przet³umaczony na 2 sposoby</a>:</P>
	<BR><a href="#linux1509" class="bezdruk">(przeskocz sposoby t³umaczenia)</a>
<PRE title="t³umaczenie drugiego przyk³adu na asm">
	; sposób 1:
		mov	ecx, 10		; ECX to zmienna I. i=1
	petla_for:
		cmp	ecx, 0		; lub: test ecx, ecx
		jbe	koniec_petli	; wychodzimy, gdy i &lt;= 0

		add	eax, ecx	; EAX to zmienna J. j=j+i

		sub	ecx, 1		; i=i-1
		jmp	short petla_for
	koniec_petli:



	; sposób 2:
		mov	ecx, 10		; ECX to zmienna I. i=1
	petla_for:
		add	eax, ecx	; EAX to zmienna J. j=j+i
		loop	petla_for	; zmniejsz ECX o 1 i je¶li ró¿ny od
					;    zera, skocz do: petla_for</PRE>

<P><a name="linux1509" id="linux1509">Pamiêtajmy jednak, ¿e instrukcja</a>
 <code><span lang="en">LOOP</span></code> dzia³a tylko na rejestrze (E)CX, wiêc je¶li chcemy mieæ
 kilka zagnie¿d¿onych pêtli, to przed ka¿d± z nich (rozpoczynaj±c± siê zmian± rejestru ECX)
 musimy zachowaæ ten rejestr (na przyk³ad na stosie), a po zakoñczeniu pêtli musimy przywróciæ
 jego poprzedni± warto¶æ.
</P>
<P>
Sprawa z pêtlami o nieznanej ilo¶ci powtórzeñ nie jest o wiele trudniejsza. Pêtla typu <q>for</q>
jest ca³kowicie równowa¿na pêtli <q lang="en">while</q>. W³a¶nie z tego skorzystamy,
 a kod niewiele bêdzie siê ró¿niæ budow± od poprzedniego przyk³adu.<BR>
Powiedzmy, ¿e mamy tak± pêtlê:</P>
	<BR><a href="#linux1510" class="bezdruk">(przeskocz ten przyk³ad)</a>
<PRE>
	for (i=100; i+1&lt;=n; i=i+2)
	{
		j=j+i+4;
	}</PRE>

<P><a name="linux1510" id="linux1510">Mo¿emy j± zast±piæ równowa¿n± konstrukcj±</a>:</P>
	<BR><a href="#linux1511" class="bezdruk">(przeskocz zamianê for na <span lang="en">while</span>)</a>
<PRE title="pêtla while równowa¿na pêtli for">
	i=100;
	while (i+1 &lt;= n)
	{
		j=j+i+4;
		i=i+2;
	}</PRE>

<P><a name="linux1511" id="linux1511">Otrzymujemy kod</a>:</P>
	<BR><a href="#linux1512" class="bezdruk">(przeskocz t³umaczenie <span lang="en">while</span>)</a>
<PRE title="t³umaczenie pêtli while na asembler">
		mov	ecx, 100	; ECX to zmienna I. i=100
	nasza_petla:
		mov	ebx, ecx
		add	ebx, 1		; EBX = i+1
		cmp	ebx, [n]	; sprawdzamy, czy i+1 &lt;= n
		ja	koniec_while	; wychodzimy, gdy i+1 > n

		add	eax, ecx	; EAX to zmienna J. j=j+i
		add	eax, 4		; j=j+i+4

		add	ecx, 2		; i=i+2
		jmp	short nasza_petla
	koniec_while:</PRE>

<P><a name="linux1512" id="linux1512">Ostatni rodzaj pêtli</a> to pêtle typu
 <q lang="en">do-while</q> (<span lang="en">repeat...until</span>).
 Taka pêtla ró¿ni siê tym od poprzedniczek, ¿e warunek jest sprawdzany po wykonaniu kodu pêtli
(czyli taka pêtla zawsze bêdzie wykonana co najmniej raz). Daje to pewne
mo¿liwo¶ci optymalizacji kodu.<BR>
Popatrzmy na taki przyk³ad:</P>
	<BR><a href="#linux1513" class="bezdruk">(przeskocz przyk³ad <q lang="en">do-while</q>)</a>
<PRE title="pêtla do-while">
	do
	{
		i=i+1;
		j=j-1;
	} while ((i &lt; n) &amp;&amp; (j &gt; 1));</PRE>

<P><a name="linux1513" id="linux1513">Warunek wyj¶cia to: i wiêksze b±d¼ równe n LUB j mniejsze
b±d¼ równe 1.</a><BR>
A teraz popatrzcie, co mo¿na z tym zrobiæ:</P>
	<BR><a href="#linux1514" class="bezdruk">(przeskocz t³umaczenie <q lang="en">do-while</q>)</a>
<PRE title="t³umazcenie do-while na asembler">
	petla_do:
		add	ecx, 1		; ECX to zmienna I. i=i+1
		add	edx, 1		; EDX to zmienna J. j=j+1

		cmp	ecx, [n]
		jae	koniec		; i >= n jest jednym z warunków
					; wyj¶cia. Drugiego nie musimy
					; sprawdzaæ, bo wynik i tak
					; bêdzie prawd±
		cmp	edx, 1
		jbe	koniec		; j &lt;= 1 to drugi warunek wyj¶cia

		jmp	petla_do
	koniec:</PRE>

<P><a name="linux1514" id="linux1514">Mo¿na przepisaæ to w lepszy sposób</a>:</P>
	<BR><a href="#linux1515" class="bezdruk">(przeskocz lepszy sposób)</a>
<PRE title="lepsze t³umazcenie do-while na asembler">
	petla_do:
		add	ecx, 1		; ECX to zmienna I. i=i+1
		add	edx, 1		; EDX to zmienna J. j=j+1

		cmp	ecx, [n]
		jae	koniec		; i &gt;= n jest jednym z warunków
					; wyj¶cia. Drugiego nie musimy
					; sprawdzaæ, bo wynik i tak
					; bêdzie prawd±

					; je¶li nadal tutaj jeste¶my,
					; to z pewno¶ci± i &lt; n.
		cmp	edx, 1
		ja	petla_do	; j &lt;= 1 to drugi warunek
					; wyj¶cia. Je¶li j &gt; 1,
					; to kontynuuj wykonywanie pêtli.
					; Je¶li j &lt; 1, to po prostu
					; opuszczamy pêtlê:
	koniec:</PRE>

<P><a name="linux1515" id="linux1515">Je¶li warunek kontynuacji lub wyj¶cia</a> z pêtli jest
wyra¿eniem z³o¿onym, to:</P>
<UL>
 <LI>je¶li sk³ada siê z alternatyw (dzia³añ typu OR, ||), to na pierwszym miejscu
	sprawdzajcie te warunki, które maj± najwiêksz± szansê byæ prawdziwe. Oszczêdzicie
	w ten sposób czasu na bezsensowne sprawdzanie reszty warunków (wynik i tak bêdzie
	prawd±).</LI>
 <LI>je¶li sk³ada siê z koniunkcji (dzia³añ typu <span lang="en">AND</span>, &amp;&amp;), to na pierwszym miejscu
	sprawdzajcie te warunki, które maj± najwiêksz± szansê byæ fa³szywe. Wynik ca³o¶ci i
	tak bêdzie fa³szem.</LI>
</UL>
<P>Przyk³ady:</P>
<PRE>
	1)   a == 0 || (b &gt; 1 &amp;&amp; c &lt; 2)
	2)   (b &lt; d || a == 1) &amp;&amp; c > 0</PRE>

<P>W przypadku 1 najpierw sprawdzamy, czy <q>a</q> jest równe zero. Je¶li jest, to ca³y warunek jest
prawdziwy. Je¶li nie jest, sprawdzamy najpierw ten z dwóch pozosta³ych, który ma najwiêksz±
szansê bycia fa³szywym (je¶li który¶ jest fa³szywy, to wynik jest fa³szem).<BR>
W przypadku 2 najpierw sprawdzamy, czy <q>c</q> jest wiêksze od zera. Je¶li nie jest, to ca³y warunek
jest fa³szywy. Je¶li jest, to potem sprawdzamy ten z pozosta³ych warunków, który ma
wiêksz± szansê bycia prawdziwym (je¶li który¶ jest prawdziwy, to wynik jest prawd±).</P>

<HR>








<h2 class="nag"><a name="switch" id="switch">Decyzje wielowariantowe</a>
	 (wyra¿enia typu <span lang="en">switch/case</span>)</h2>

	<BR><a href="#koniec" class="bezdruk">(przeskocz decyzje wielowariantowe)</a>
<P>
Fragment kodu:</P>
	<BR><a href="#linux1516" class="bezdruk">(przeskocz schemat <span lang="en">switch/case</span>)</a>
<PRE title="konstrukcja switch-case">
	switch (a)
	{
		case 1: .....
		case 2: .....
		....
		default: .....
	}</PRE>

<P><a name="linux1516" id="linux1516">w prosty sposób rozk³ada siê na</a>
 seriê wyra¿eñ <q lang="en">if</q> i <q lang="en">else if</q>
 (oraz <q lang="en">else</q>, o ile podano
sekcjê <q lang="en">default</q>). Te za¶ ju¿ umiemy przedstawiaæ w asemblerze. Jest jednak jedna ciekawa
sprawa: je¶li warto¶ci poszczególnych przypadków case <em class="wazne">s± zbli¿one</em>
 (co¶ w stylu 1, 2, 3
a nie 1, 20, 45), to mo¿emy pos³u¿yæ siê tablic± skoków (ang. <span lang="en">jump table</span>).
 W tej tablicy przechowywane s± adresy fragmentów kodu, który ma zostaæ wykonany, gdy zajdzie
odpowiedni warunek. Brzmi to trochê pokrêtnie, dlatego szybko poka¿ê przyk³ad.</P>
	<BR><a href="#linux1517" class="bezdruk">(przeskocz przyk³ad <span lang="en">switch/case</span>)</a>
<PRE title="przyk³ad switch-case">
	switch (a)
	{
		case 1:
			j=j+1;
			break;
		case 2:
			j=j+4;
			break;
		case 4:
			j=j+23;
			break;
		default:
			j=j-1;
	}</PRE>

<P><a name="linux1517" id="linux1517">A teraz t³umaczenie</a>:</P>
	<BR><a href="#linux1518" class="bezdruk">(przeskocz t³umaczenie przyk³adu <span lang="en">switch/case</span>)</a>
<PRE title="t³umaczenie switch-case na asembler">
		mov	eax, [a]
		cmp	eax, 1			; je¶li a &lt; 1 lub a &gt; 5,
						; to na pewno default
		jb	sekcja_default

		cmp	eax, 5
		ja	sekcja_default

		jmp	[przypadki + eax*2 - 2]

	przyp1:
		add	dword ptr [j], 1	; NASM/FASM: bez s³owa PTR
		jmp	koniec

	przyp2:
		add	dword ptr [j], 4	; NASM/FASM: bez s³owa PTR
		jmp	koniec

	przyp4:
		add	dword ptr [j], 23	; NASM/FASM: bez s³owa PTR
		jmp	koniec

	sekcja_default:
		sub	dword ptr [j], 1

	koniec:

	....
	przypadki:	dw przyp1, przyp2, sekcja_default, przyp4</PRE>

<P><a name="linux1518" id="linux1518">Kod najpierw sprawdza</a>, czy <q>a</q> ma szansê byæ w
 którym¶ z przypadków (je¶li nie jest, to
oczywi¶cie wykonujemy sekcjê <q lang="en">default</q>). Potem, je¶li a=1, to skacze pod etykietê w<br>
<code>zmienne [przypadki + 1*2 - 2 ] = [przypadki] = przyp1</code>.<br>
 Podobnie, je¶li a=2, skoczymy
do <q>przyp2</q>. Je¶li a=3, skoczymy do sekcji <q lang="en">default</q>, a je¶li a=4, skoczymy do
sekcji <q>przyp4</q>.</P>
<P>
Od razu widaæ wielk± zaletê takiego rozwi±zania: w <em class="wazne">jednej jedynej instrukcji</em>
 wiemy, gdzie
musimy skoczyæ. Jak liczba przypadków bêdzie wzrastaæ, zauwa¿ymy te¿ wadê tego rozwi±zania:
rozmiar tablicy szybko ro¶nie (wynosi on ró¿nicê miêdzy warto¶ci± najwy¿sz± mo¿liw± a
najni¿sz± mo¿liw± pomno¿on± przez 2 bajty). Dlatego to rozwi±zanie jest nieprzydatne dla
mo¿liwych warto¶ci: {1, 20, 45} (42 warto¶ci z 45 by³yby nieu¿ywane, czyli wskazuj±ce na sekcjê
<q lang="en">default</q> - zdecydowane marnotrawienie pamiêci). W takim przypadku lepiej u¿yæ
<q>tradycyjnej</q> metody <span lang="en">if/else if/else</span>.</P>


<hr>
<P>
<a name="koniec" id="koniec">Mam nadziejê, ¿e wiedza</a> zawarta w tej czê¶ci
 kursu umo¿liwi Wam pisanie lepszych i bardziej
z³o¿onych programów ni¿ to by³o do tej pory. Teraz bêdziecie wiedzieæ, co tak w³a¶ciwie
robiê kompilatory, t³umacz±c niektóre wyra¿enia kontrolne. Ta wiedza pomo¿e Wam pisaæ lepsze
programy w jêzykach wy¿szego poziomu (gdy¿ ju¿ teraz wiecie, jak zapisywaæ wyra¿enia
logiczne tak, by dostaæ najbardziej wydajny kod).
</P>

<br><br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="linux14.html">Poprzednia czê¶æ kursu</a> (Alt+3)<br>
<a accesskey="4" hreflang="pl" href="linux16.html">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>



<BR><BR><HR>
<h2 class="nag">Æwiczenia</h2>
<OL>
 <LI>Zaimplementowaæ zdanie:<BR>
	Je¶li EAX jest równy EBX lub ECX nie jest równy EBP, to do EDX wstaw EAX,
	inaczej do ECX wstaw 0.<BR><BR></LI>
 <LI>Zaimplementowaæ zdanie (u¿yæ instrukcji warunkowego przesuwania):<BR>
	Je¶li EAX jest równy EBX lub ECX nie jest równy EBP, to do EDX wstaw EAX,
	inaczej do EDX wstaw 0.<BR><BR></LI>
 <LI>Napisaæ program, który liczy sumê liczb od 10 do dowolnej liczby wpisanej w kodzie/czytanej
	z linii poleceñ.<BR><BR></LI>
 <LI>Zaimplementowaæ zdanie:<BR>
	Dopóki ECX jest wiêksze od 1, zmniejsz ECX o 2.<BR><BR></LI>
 <LI>Zaimplementowaæ zdanie:<BR>
	Zwiêkszaj EAX o 3, dopóki EAX jest mniejsze od 100.</LI>
</OL>

</BODY></HTML>
