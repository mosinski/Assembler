<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks: Programy wielow±tkowe </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<link rel="alternate" type="text/html" href="watki_linux_en.html"
	hreflang="en" lang="en" title="English version">

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Pisanie programów wielow±tkowych pod Linuksem">
<META NAME="Keywords" CONTENT="asm, assembler, asembler, linux, linuks, w±tki, thread">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Tue, Jan 18 2011 18:00:01 CEST">
</HEAD><BODY>

<h1 class="nag">Pisanie programów wielow±tkowych pod Linuksem</h1>

<P>
Asembler, jak wszystkie inne strukturalne jêzyki programowania pozwala pisaæ
 programy, w których ¶cie¿ka wykonywanych instrukcji jest tylko jedna. Mog±
 byæ rozwidlenia i pêtle, ale zawsze wykonuje siê tylko jedna rzecz na raz.</P>
<P>
W±tki pozwalaj± na uruchomienie wielu niezale¿nych ¶cie¿ek, które bêd± wykonywane
 równolegle. Daje to du¿e mo¿liwo¶ci programom, które wykonuj± kilka czynno¶ci
 na raz (na przyk³ad czytanie z jednego pliku i zapisywanie przetworzonych danych do
 drugiego). Zysk jest te¿ w programach sieciowych, a zw³aszcza serwerach. Po
 dodaniu obs³ugi w±tków mo¿liwe jest po³±czenie wiêcej ni¿ jednego klienta w
 danej chwili. Ale przejd¼my wreszcie do szczegó³ów.</P>
<P>
Najpierw omówiê trzy funkcje z biblioteki jêzyka C (¶ci¶le mówi±c, z biblioteki pthreads),
które pozwol± nam zarz±dzaæ w±tkami.</P>
<OL>
 <LI><span lang="en">pthread_create</span> - tworzenie nowego w±tku.
 	<P>Funkcja ta przyjmuje 4 argumenty. Od lewej (ostatni wk³adany na stos) s± to:</P>
  <UL>
   <LI>adres zmiennej typu DWORD, która otrzyma identyfikator nowego w±tku.</LI>
   <LI>atrybuty nowego w±tku, je¶li chcemy co¶ specjalnego. Zero oznacza domy¶lne argumenty.</LI>
   <LI>adres funkcji w±tku. Funkcja ta otrzyma na stosie adres dodatkowych danych,
   	które mo¿na przekazaæ do w±tku.</LI>
   <LI>adres dodatkowych danych, które chcemy przekazaæ do w±tku.</LI>
  </UL><BR></LI>

 <LI><span lang="en">pthread_exit</span> - zakoñczenie bie¿±cego w±tku
 	<P>Funkcja ta koñczy bie¿±cy w±tek. Warto¶æ podana jako jedyny jej argument (adres danych)
 	mo¿e byæ wykorzystana przez w±tki pod³±czone (<span lang="en">pthread_join</span>) do tego w±tku.
 	Po zakoñczeniu wszystkich w±tków, program koñczy dzia³anie z kodem 0.
 	</P></LI>

 <LI><span lang="en">pthread_yield</span> - oddanie czasu procesora innym w±tkom lub procesom
 	<P>Oczywi¶cie, system operacyjny sam te¿ przydziela czas procesora poszczególnym w±tkom,
 	ale wywo³uj±c tê funkcjê mo¿emy powiedzieæ, by skróci³ czas przeznaczony dla tego
 	w±tku i da³ go innym. Przydaje siê, gdy bie¿±cy w±tek
 	chwilowo skoñczy³ pracê (na przyk³ad zabrak³o danych itp.). Funkcja nie przyjmuje
 	¿adnych argumentów.</P></LI>
</OL>
<P>Poni¿ej przedstawiam króciutki program, który poka¿e, jak to wszystko dzia³a. Program ma jeden
 raz wy¶wietliæ napis pierwszy w funkcji g³ównej i 5 razy napis drugi w funkcji w±tku.</P>

	<BR><a href="#watki_linux01" class="bezdruk" tabindex="1">(przeskocz program)</a>
<PRE>
; Przyk³adowy program wielow±tkowy w asemblerze
;
; Autor: Bogdan D., bogdandr (at) op.pl
;
; kompilacja:
; nasm -O999 -f elf -o watki.o watki.asm
; gcc -o watki watki.o -lpthread

section	.text
global	main

; deklaracje funkcji zewnêtrznych
extern	pthread_create
extern	pthread_exit

main:

	mov	eax, 4
	mov	ebx, 1
	mov	ecx, napis1
	mov	edx, napis1_dl
	int	80h			; wy¶wietlamy napis pierwszy

	push	dword 0			; dodatkowe dane
	push	dword watek		; adres funkcji do uruchomienia
	push	dword 0			; atrybuty
	push	dword id_watku		; gdzie zapisaæ ID
	call	pthread_create		; utworzenie nowego w±tku

; Nie nale¿y wychodziæ z programu funkcj± sys_exit (EAX=1), gdy¿
; zakoñczy³oby to wszystkie w±tki programu. Zamiast tego, zamykamy tylko
; w±tek g³ówny.
	push	dword 0
	call	pthread_exit		; zakoñczenie bie¿±cego w±tku

watek:

	mov	dword [t1+timespec.tv_nsec], 0
	mov	dword [t1+timespec.tv_sec], 5		; 5 sekund

	mov	esi, 5			; napis drugi wy¶wietlimy 5 razy
.petla:
	mov     eax, 162		; sys_nanosleep
	mov     ebx, t1			; adres struktury mówi±cej,
					; ile chcemy czekaæ
	mov     ecx, 0
	int     80h			; robimy przerwê...

	mov	eax, 4
	mov	ebx, 1
	mov	ecx, napis2
	mov	edx, napis2_dl
	int	80h			; wy¶wietl napis drugi

	dec	esi
	jnz	.petla			; wykonuj pêtlê, je¶li ESI != 0

	push	dword 0
	call	pthread_exit		; zakoñczenie bie¿±cego w±tku

section .data

napis1		db	&quot;Funkcja glowna.&quot;, 10
napis1_dl	equ	$ - napis1

napis2		db	&quot;Watek.&quot;, 10
napis2_dl	equ	$ - napis2

struc timespec
	.tv_sec:	resd 1
	.tv_nsec:	resd 1
endstruc

t1 		istruc timespec

id_watku	dd	0	; zmienna, która otrzyma ID nowego w±tku</PRE>

<P><a name="watki_linux01" id="watki_linux01">Ale w±tki w programie</a> to nie tylko same zyski.
 Najwiêkszym problemem w programach wielow±tkowych jest <em class="wazne">synchronizacja w±tków</em>.</P>
 <P>
  Po co synchronizowaæ? Po to, ¿eby program nie sprawia³ problemów, gdy dwa
 lub wiêcej w±tków odczytuje i zapisuje tê sam± zmienn± globaln± (na przyk³ad bufor danych).</P>
 <P>Co zrobiæ, by na przyk³ad
 w±tek czytaj±cy przetwarza³ dane dopiero wtedy, gdy inny w±tek dostarczy te dane? Mo¿liwo¶ci jest kilka:</P>
 <UL>
  <LI>flaga - zmienna globalna.
  	<P>Na przyk³ad ustalmy, ¿e je¶li flaga jest równa zero, to bufor mo¿e
  	byæ dowolnie u¿ywany (do zapisu i odczytu). Je¶li flaga jest równa na przyk³ad jeden, to nie wolno
  	wykonywaæ operacji na buforze (bo inny w±tek ju¿ to robi) - nale¿y poczekaæ, a¿ flaga bêdzie
  	równa zero.</P>
  	<P>Zalet± tego rozwi±zania jest prostota jego utworzenia. Popatrzcie:</P>
  	<PRE>
	flaga	db	0
	...
	watek:
	...
	sprawdz_flage:
		cmp	byte [flaga], 1
		je	sprawdz_flage
		mov	byte [flaga], 1
	...	; tutaj nasze operacje
		mov	byte [flaga], 0</PRE>
  </LI>
  <LI>mutex - poczytajcie <A HREF="http://pl.wikipedia.org/wiki/Mutex" hreflang="pl"
  	>pl.wikipedia.org/wiki/Mutex</A></LI>
  <LI>semafor ustawiaj±cy w±tki w kolejkê do danego zasobu. Poczytajcie
  	<A HREF="http://pl.wikipedia.org/wiki/Semafor_%28informatyka%29" hreflang="pl"
  	>pl.wikipedia.org/wiki/Semafor_(informatyka)</A></LI>
 </UL>

<P>Jak widaæ, pisanie programów wielow±tkowych nie jest takie trudne, warto wiêc siê tego nauczyæ.
 Tym bardziej, ¿e zyski s± wiêksze (napisanie po jednej funkcji na ka¿de oddzielne zadanie),
 ni¿ wysi³ek (synchronizacja).</P>







<Hr>
<h2 class="nag"><a name="watki_int80h" id="watki_int80h">Wielow±tkowo¶æ z przerwaniem 80h</a></h2>

<P>
Oczywi¶cie, aby pisaæ programy wielow±tkowe, nie musicie korzystaæ z ¿adnej biblioteki.
 Odpowiednie mechanizmy posiada sam interfejs systemu - przerwanie int 80h.</P>
<P>Skorzystam tutaj
 z funkcji <span class="b">sys_fork</span> (numer 2). Jej jedynym argumentem jest adres struktury
 zawieraj±cej warto¶ci rejestrów dla nowego procesu, ale ten argument jest opcjonalny i mo¿e
 byæ zerem. Funkcja <span class="b">fork</span> zwraca warto¶æ mniejsz± od zera, gdy wyst±pi³ b³±d,
 zwraca zero w procesie
 potomnym, za¶ warto¶æ wiêksz± od zera (PID nowego procesu) - w procesie rodzica. Proces potomny
 zaczyna dzia³anie tu¿ po wywo³aniu funkcji <span class="b">fork</span>, czyli rodzic po wykonaniu
 funkcji fork i potomek
 zaczynaj± wykonywaæ dok³adnie te same instrukcje. Procesy te mo¿na skierowaæ na ró¿ne ¶cie¿ki,
 sprawdzaj±c warto¶æ zwrócon± przez fork w EAX.</P>
<P>
Oto krótki przyk³ad w sk³adni FASMa:</P>

<pre title="Przyk³ad fork">
format ELF executable
entry _start
segment executable

_start:
	mov	eax, 2		; funkcja fork
	xor	ebx, ebx
	int	80h		; wywo³anie

	cmp	eax, 0
	jl	.koniec		; EAX &lt; 0 oznacza b³±d

	; poni¿sze instrukcje wykona zarówno rodzic, jak i potomek:

	cmp	eax, 0
	jg	.rodzic		; EAX &gt; 0 oznacza, ¿e jeste¶my w
				; procesie rodzica

	; tutaj ani EAX &lt; 0, ani EAX &gt; 0, wiêc EAX=0, czyli
	; jeste¶my w procesie potomka
	; kod poni¿ej (wy¶wietlenie i czekanie) wykona tylko potomek

	mov	dword [t1.tv_nsec], 0
	mov	dword [t1.tv_sec], 5	; tyle sekund przerwy bêdziemy robiæ
					; miêdzy wy¶wietlaniem napisów

.petla:
	mov	eax, 4		; funkcja zapisywania do pliku
	mov	ebx, 1		; standardowe wyj¶cie
	mov	ecx, napis2	; co wypisaæ
	mov	edx, napis2_dl	; d³ugo¶æ napisu
	int	80h

	mov     eax, 162	; funkcja sys_nanosleep
	mov     ebx, t1		; tyle czekaæ
	mov     ecx, 0		;ewentualny adres drugiej struktury timespec
	int     80h		;  robimy przerwê...

	jmp	.petla		; i od nowa....

	; kod poni¿ej (wy¶wietlenie i wyj¶cie) wykona tylko rodzic
.rodzic:

	mov	eax, 4		; funkcja zapisywania do pliku
	mov	ebx, 1		; standardowe wyj¶cie
	mov	ecx, napis1	; co wypisaæ
	mov	edx, napis1_dl	; d³ugo¶æ napisu
	int	80h

.koniec:
	mov	eax, 1		; funkcja wyj¶cia z programu
	xor	ebx, ebx
	int	80h

segment readable writeable

napis1		db	"Rodzic", 10
napis1_dl	=	$ - napis1
napis2		db	"Potomek", 10
napis2_dl	=	$ - napis1

struc timespec			; definicja struktury timespec
				; (tylko jako typ danych)
{
	.tv_sec:	rd 1
	.tv_nsec:	rd 1
}

t1 timespec		; tworzymy zmienn± t1 jako ca³± strukturê</pre>




<br><br>
<div class="bezdruk">
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

</BODY></HTML>
