<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks, czê¶æ 6 - MMX i SIMD </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Prev"     hreflang="pl" lang="en" href="linux05.html" >
<link rel="Next"     hreflang="pl" lang="en" href="linux07.html" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >


<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="kurs, asm, asembler, assembler, MMX, SSE, SSE2, SSE3, 3DNow!, linux, linuks">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Mon, Oct 29 2012 17:22:20 CEST">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler pod Linuksem?<BR>
	<h1 class="nag">Czê¶æ 6 - SIMD, czyli jak dzia³a MMX</h1></div>


<P>
- A có¿ to takiego to SIMD ?! - zapytacie.<BR>
Ju¿ odpowiadam.<BR>
SIMD = <span lang="en">Single Instruction, Multiple Data</span> = jedna instrukcja, wiele danych.<BR>
Jest to technologia
umo¿liwiaj±ca jednoczesne wykonywanie tej samej instrukcji na kilku warto¶ciach. Na pewno znany
jest wam co najmniej jeden przyk³ad zastosowania technologii SIMD. Jest to
 <span lang="en">MultiMedia Extensions</span>,
w skrócie MMX u Intela, a 3DNow! u <acronym title="Advanced Micro Devices" lang="en">AMD</acronym>.
Innym mniej znanym zastosowaniem jest SSE, które omówiê pó¼niej.<BR>
Zaczniemy od omówienia, jak w³a¶ciwie dzia³a to ca³e MMX.
</P>






<BR><HR>
<h2 class="nag">MMX / 3DNow!</h2>
<P>
Technologia MMX operuje na 8 rejestrach danych, po 64 bity ka¿dy, nazwanych mm0 ... mm7.
Niestety, rejestry te nie s± <q>prawdziwymi</q> (oddzielnymi) rejestrami - s± czê¶ciami rejestrów koprocesora
 (które, jak pamiêtamy, maj± po 80 bitów ka¿dy).
 Pamiêtajcie wiêc, ¿e <em class="wazne">nie mo¿na naraz wykonywaæ operacji na FPU i MMX/3DNow!</em>.
</P>
<P>
Rejestry 64-bitowe s³u¿± do umieszczania w nich danych spakowanych. Na czym to polega?
Zamiast mieæ na przyk³ad 32 bity w jednym rejestrze, mo¿na mieæ dwa razy po 32. Tak wiêc rejestry mieszcz±
2 podwójne s³owa (dword, 32 bity) lub 4 s³owa (word, 16 bitów) lub a¿ 8 spakowanych bajtów.
</P>
<P>
Zajmijmy siê omówieniem instrukcji operuj±cych na tych rejestrach.<BR>
Instrukcje MMX mo¿na podzieliæ na kilka grup (nie wszystkie instrukcje bêd± tu wymienione):</P>
<UL>
  <LI>instrukcje transferu danych:<BR>
   <UL>
    <LI><code>MOVD mmi, rej32/mem32</code> (i=0,...,7) </LI>
    <LI><code>MOVQ mmi, mmj/mem64</code> (i,j=0,...,7)</LI>
   </UL>
  <BR></LI>
  <LI>instrukcje arytmetyczne:<BR>
   <UL>
    <LI>dodawanie normalne: <code>PADDB</code> (bajty) / <code>PADDW</code> (s³owa) /
	<code>PADDD</code> (dwordy)<BR><BR></LI>
    <LI>dodawanie z nasyceniem ze znakiem: <code>PADDSB</code> (bajty) / <code>PADDSW</code> (s³owa).<BR>
	Je¿eli wynik przekracza 127 lub 32767 (bajty/s³owa), to jest do tej warto¶ci
	zaokr±glany, a NIE jest tak, ¿e nagle zmienia siê na ujemny. Daje to lepszy efekt, na przyk³ad
	w czasie s³uchania muzyki czy ogl±dania filmu. Hipotetyczny przyk³ad: 2 kolory <q>szare</q> z
	dadz± w sumie <q>czarny</q> a nie co¶ po¶rodku skali kolorów.
	<BR><BR></LI>
    <LI>dodawanie z nasyceniem bez znaku: <code>PADDUSB</code> / <code>PADDUSW</code>.<BR>
	Je¿eli wynik przekracza 255 lub 65535, to jest do tej warto¶ci zaokr±glany.<BR><BR></LI>
    <LI>odejmowanie normalne: <code>PSUBB</code> (bajty) / <code>PSUBW</code> (s³owa) /
	<code>PSUBD</code> (dwordy)<BR><BR></LI>
    <LI>odejmowanie z nasyceniem ze znakiem: <code>PSUBSB</code> (bajty) / <code>PSUBSW</code> (s³owa).<BR>
	Je¶li wynik jest mniejszy ni¿ -128 lub -32768 to jest do tej warto¶ci zaokr±glany.
	<BR><BR></LI>
    <LI>odejmowanie z nasyceniem bez znaku: <code>PSUBUSB</code> (bajty) / <code>PSUBUSW</code> (s³owa)<BR>
	Je¶li wynik jest mniejszy ni¿ 0, to staje siê równy 0.<BR><BR></LI>
    <LI>mno¿enie:
      <UL>
       <LI><code>PMULHRWC</code>, <code>PMULHRIW</code>, <code>PMULHRWA</code> - mno¿enie
	spakowanych s³ów, zaokr±glanie, zapisanie tylko starszych 16 bitów wyniku (z 32).</LI>
       <LI><code>PMULHUW</code> - mno¿enie spakowanych s³ów bez znaku, zachowanie starszych 16 bitów</LI>
       <LI><code>PMULHW</code>, <code>PMULLW</code> - mno¿enie spakowanych s³ów bez znaku,
	zapisanie starszych/m³odszych 16 bitów (odpowiednio).</LI>
       <LI><code>PMULUDQ</code> - mno¿enie spakowanych dwordów bez znaku</LI>
     </UL><BR></LI>
    <LI>mno¿enie i dodawanie: <code>PMADDWD</code> - do m³odszego dworda rejestru docelowego idzie suma
	iloczynów 2 najm³odszych s³ów ze sob± i 2 starszych (bity 16-31) s³ów ze sob±.
	Do starszego dworda - suma iloczynów 2 s³ów 32-47 i 2 s³ów 48-63.<BR><BR></LI>
   </UL>
  </LI>
  <LI>instrukcje porównawcze:<BR>
	Zostawiaj± w odpowiednim bajcie/s³owie/dwordzie same jedynki (FFh/FFFFh/FFFFFFFFh) gdy
	wynik porównania by³ prawdziwy, same zera - gdy fa³szywy.
   <UL>
    <LI>na równo¶æ <code>PCMPEQB</code> / <code>PCMPEQW</code> / <code>PCMPEQD</code> (EQ oznacza równo¶æ)</LI>
    <LI>na <q>wiêksze ni¿</q>: <code>PCMPGTPB</code> / <code>PCMPGTPW</code> / <code>PCMPGTPD</code>
	(GT oznacza <span lang="en">greater than</span>, czyli wiêkszy)</LI>
   </UL>
  <BR></LI>
  <LI>instrukcje konwersji:<BR>
   <UL>
    <LI>pakowanie: <code>PACKSSWB</code> / <code>PACKSSDW</code>, <code>PACKUSWB</code> -
	<q>upychaj±</q> s³owa/dwordy do bajtów/s³ów i pozostawiaj± w rejestrze docelowym.</LI>
    <LI>rozpakowania starszych czê¶ci (<span lang="en">unpack high</span>): <code>PUNPCKHBW</code>,
	<code>PUNPCKHWD</code>, <code>PUNPCKHDQ</code> -
	 pobieraj± starsze czê¶ci bajtów/s³ów/dwordów z	jednego i drugiego rejestru, mieszaj±
	 je i zostawiaj± w pierwszym.</LI>
    <LI>rozpakowania m³odszych czê¶ci (<span lang="en">unpack low</span>): <code>PUNPCKLBW</code>,
	<code>PUNPCKLWD</code>, <code>PUNPCKLDQ</code> - jak
	wy¿ej, tylko pobierane s± m³odsze czê¶ci</LI>
   </UL>
  <BR></LI>
  <LI>instrukcje logiczne:<BR>
   <UL>
    <LI><code>PAND</code> (bitowe AND)</LI>
    <LI><code>PANDN</code> (najpierw bitowe NOT pierwszego rejestru, potem jego bitowe AND z drugim rejestrem)</LI>
    <LI><code>POR</code> (bitowe OR)</LI>
    <LI><code>PXOR</code> (bitowe XOR)</LI>
   </UL>
  <BR></LI>
  <LI>instrukcje przesuniêcia (analogiczne do znanych <code>SHL</code>, <code>SHR</code> i
	<code>SAR</code>, odpowiednio):<BR>
   <UL>
    <LI>w lewo: <code>PSLLW</code> (s³owa) / <code>PSLLD</code> (dword-y), <code>PSLLQ</code> (qword)</LI>
    <LI>w prawo, logiczne: <code>PSRLW</code> (s³owa) / <code>PSRLD</code> (dword-y), <code>PSRLQ</code> (qword)</LI>
    <LI>w prawo, arytmetyczne: <code>PSRAW</code> (s³owa)/ <code>PSRAD</code> (dword-y)</LI>
   </UL>
  <BR></LI>
  <LI>instrukcje stanu MMX:<BR>
   <UL>
    <LI><code>EMMS</code> - <span lang="en">Empty MMX State</span> - ustawia rejestry FPU
	jako wolne, umo¿liwiaj±c ich
	u¿ycie. Ta instrukcja musi byæ wykonana za ka¿dym razem, gdy koñczymy pracê z
	MMX i chcemy zacz±æ pracê z FPU.
    </LI>
   </UL>
  <BR></LI>
</UL>
<P>Rzadko która z tych instrukcji traktuje rejestr jako ca³o¶æ, czê¶ciej operuj± one na poszczególnych
warto¶ciach osobno, równolegle.</P>
<P>
Spróbujê teraz podaæ kilka przyk³adów zastosowania MMX.
</P>
<hr>
<P>Przyk³ad 1. Dodawanie dwóch tablic bajtów w pamiêci. Bez MMX mog³oby to wygl±daæ mniej wiêcej tak:</P>
	<BR><a href="#linux0601" tabindex="1" class="bezdruk">(przeskocz dodawanie tablic)</a>

<PRE title="dodawanie elementów dwóch tablic">
; EDX - adres pierwszej tablicy bajtów
; ESI - adres drugiej tablicy bajtów
; EDI - adres docelowej tablicy bajtów
; ECX - liczba bajtów w tablicach. Przyjmiemy, ¿e ró¿na od zera...

	petla:
		mov al, [edx]	; pobierz bajt z pierwszej
		add al, [esi]	; dodaj bajt z drugiej
		mov [edi], al	; zapisz bajt w docelowej
		inc edx		; zwiêksz o 1 indeksy tablic
		inc esi
		inc edi
		loop petla	; dzia³aj, dopóki ECX ró¿ne od 0.</PRE>

<hr>
<P><a name="linux0601" id="linux0601">A z MMX</a>:</P>
	<BR><a href="#linux0602" class="bezdruk">(przeskocz dodawanie tablic z MMX)</a>
<PRE title="dodawanie elementów dwóch tablic z MMX">
	mov ebx, ecx	; EBX = liczba bajtów
	and ebx, 7	; bêdziemy braæ po 8 bajtów - obliczamy
			; wiêc resztê z dzielenia przez 8

	shr ecx, 3	; dzielimy ECX przez 8
petla:
	movq mm0, [edx]	; pobierz 8 bajtów z pierwszej tablicy
	paddb mm0, [esi]; dodaj 8 spakowanych bajtów z drugiej
	movq [edi], mm0	; zapisz 8 bajtów w tablicy docelowej
	add edx, 8	; zwiêksz indeksy do tablic o 8
	add esi, 8
	add edi, 8
	loop petla	; dzia³aj, dopóki ECX ró¿ne od 0.

	test ebx, ebx	; czy EBX = 0?
	jz koniec	; je¶li tak, to ju¿ skoñczyli¶my

	mov ecx, ebx	; ECX = resztka, co najwy¿ej 7 bajtów.
			; te kopiujemy tradycyjnie
petla2:
	mov al, [edx]	; pobierz bajt z pierwszej
	add al, [esi]	; dodaj bajt z drugiej
	mov [edi], al	; zapisz bajt w docelowej
	inc edx		; zwiêksz o 1 indeksy do tablic
	inc esi
	inc edi
	loop petla2	; dzia³aj, dopóki ECX ró¿ne od 0
koniec:

	emms		; wyczy¶æ rejestry MMX, by FPU mog³o z nich korzystaæ</PRE>

<P><a name="linux0602" id="linux0602">Podobnie bêd± przebiegaæ operacje</a> <code>PAND</code>,
<code>POR</code>, <code>PXOR</code>, <code>PANDN</code>.</p>

<P>Przy du¿ych ilo¶ciach danych, sposób drugi bêdzie wykonywa³ oko³o 8 razy mniej instrukcji ni¿
pierwszych, bo dodaje na raz 8 bajtów. I o to w³a¶nie chodzi³o.
</P>
<hr>
<P>Przyk³ad 2. Kopiowanie pamiêci.<BR>
Bez MMX:</P>
	<BR><a href="#linux0603" class="bezdruk">(przeskocz kopiowanie pamiêci)</a>

<PRE title="tradycyjne kopiowanie pamiêci">
; DS:ESI - ¼ród³o
; ES:EDI - cel
; ECX - liczba bajtów
	mov ebx, ecx	; EBX = liczba bajtów
	and ebx, 3	; EBX = reszta z dzielenia liczby bajtów przez 4
	shr ecx, 2	; ECX = liczba bajtów dzielona przez 4

	cld		; kierunek: do przodu
	rep movsd	; dword z DS:ESI idzie pod ES:EDI, EDI:=EDI+4,
			; ESI:=ESI+4, dopóki ECX jest ró¿ny od 0
	mov ecx, ebx	; ECX = liczba pozosta³ych bajtów
	rep movsb	; resztkê kopiujemy po bajcie</PRE>

<hr>
<P><a name="linux0603" id="linux0603">Z MMX</a>:</P>
	<BR><a href="#linux0604" class="bezdruk">(przeskocz kopiowanie pamiêci z MMX)</a>
<PRE title="kopiowanie pamiêci z MMX">
		mov ebx, ecx	; EBX = liczba bajtów
		and ebx, 7	; EBX = reszta z dzielenia liczby bajtów
				; przez 8

		shr ecx, 3	; ECX = liczba bajtów dzielona przez 8
	petla:
		movq mm0, [esi]	; MM0 = 8 bajtów z tablicy pierwszej
		movq [edi], mm0	; kopiujemy zawarto¶æ MM0 pod [EDI]
		add esi, 8	; zwiêkszamy indeksy tablic o 8
		add edi, 8
		loop petla	; dzia³aj, dopóki ECX ró¿ne od 0

		mov ecx, ebx	; ECX = liczba pozosta³ych bajtów
		cld		; kierunek: do przodu
		rep movsb	; resztkê kopiujemy po bajcie

		emms		; wyczy¶æ rejestry MMX</PRE>

<P><a name="linux0604" id="linux0604">lub, dla solidniejszych porcji danych</a>:</P>
	<BR><a href="#linux0605" class="bezdruk">(przeskocz kolejne kopiowanie pamiêci)</a>
<PRE title="kopiowanie du¿ych porcji danych">
		mov ebx, ecx	; EBX = liczba bajtów
		and ebx, 63	; EBX = reszta z dzielenia liczby bajtów
				; przez 64
		shr ecx, 6 	; ECX = liczba bajtów dzielona przez 64
	petla:
		; kopiuj 64 bajty spod [ESI] do rejestrów MM0, ... MM7
		movq mm0, [esi]
		movq mm1, [esi+8]
		movq mm2, [esi+16]
		movq mm3, [esi+24]
		movq mm4, [esi+32]
		movq mm5, [esi+40]
		movq mm6, [esi+48]
		movq mm7, [esi+56]

		; kopiuj 64 bajty z rejestrów MM0, ... MM7 do [EDI]
		movq [edi   ], mm0
		movq [edi+8 ], mm1
		movq [edi+16], mm2
		movq [edi+24], mm3
		movq [edi+32], mm4
		movq [edi+40], mm5
		movq [edi+48], mm6
		movq [edi+56], mm7

		add esi, 64	; zwiêksz indeksy do tablic o 64
		add edi, 64
		loop petla	; dzia³aj, dopóki ECX ró¿ne od 0

		mov ecx, ebx	; ECX = liczba pozosta³ych bajtów
		cld		; kierunek: do przodu
		rep movsb	; resztkê kopiujemy po bajcie

		emms		; wyczy¶æ rejestry MMX</PRE>
<BR>
<hr>
<P><a name="linux0605" id="linux0605">Przyk³ad 3.</a> <q>Rozmno¿enie</q> jednego bajtu na ca³y rejestr MMX.</P>
	<BR><a href="#linux0606" class="bezdruk">(przeskocz rozmna¿anie bajtu)</a>
<PRE title="rozmno¿enie bajtu na ca³y rejestr">
; format ELF executable		; tylko dla FASMa
; entry _start

; FASM: segment readable executable
section .text

global _start			; FASM: usun±æ tê linijkê

_start:

	movq mm0, [wart1]	; mm0 = 00 00 00 00 00 00 00 33
				;  (33h = kod ASCII cyfry 3)

	punpcklbw mm0, mm0	; do najm³odszego s³owa w³ó¿ najm³odszy bajt
				; mm0 i najm³odszy bajt mm0 (czyli ten sam)
				; mm0 = 00 00 00 00 00 00 33 33

	punpcklwd mm0, mm0	; do najm³odszego dworda w³ó¿ dwa razy
				; najm³odsze s³owo mm0
				; mm0 = 00 00 00 00 33 33 33 33

	punpckldq mm0, mm0	; do najm³odszego (i jedynego) qworda w³ó¿ 2x
				; najm³odszy dword mm0 obok siebie
				; mm0 = 33 33 33 33 33 33 33 33

	movq [wart2], mm0

	emms			; wyczy¶æ rejestry MMX

	mov	eax, 4
	mov	ebx, 1
	mov	ecx, wart2
	mov	edx, 9		; warto¶æ2 + znak nowej linii
	int	80h		; wy¶wietl

	mov	eax, 1
	xor	ebx, ebx
	int	80h

; FASM: segment readable writeable
section .data

wart1:	db	&quot;3&quot;
	times 7 db 0			; trójka i 7 bajtów zerowych

wart2:	times	8	db	2	; 8 bajtów o warto¶ci 2 != 33h

nowa_linia	db	0ah</PRE>

<P>
<a name="linux0606" id="linux0606">Kompilujemy, uruchamiamy</a>
 i ... rzeczywi¶cie na ekranie pojawia siê upragnione osiem trójek!</P>
<P>
Technologia MMX mo¿e byæ u¿ywana w wielu celach, ale jej najbardziej korzystn± cech± jest w³a¶nie
równoleg³o¶æ wykonywanych czynno¶ci, dziêki czemu mo¿na oszczêdziæ czas procesora.
</P>








<BR><BR>
<HR>
<h2 class="nag">Technologia SSE</h2>
<div class="c">Streaming SIMD Extensions (SSE), Pentium III lub lepszy oraz najnowsze procesory AMD</div>
<div class="c">Streaming SIMD Extensions 2 (SSE 2), Pentium 4 lub lepszy oraz AMD64</div>
<div class="c">Streaming SIMD Extensions 3 (SSE 3), Xeon lub lepszy oraz AMD64</div>

<P>
Krótko mówi±c, SSE jest dla MMX tym, czym FPU jest dla CPU. To znaczy, SSE przeprowadza
równoleg³e operacje na liczbach u³amkowych.<BR>
SSE operuje ju¿ na ca³kowicie osobnych rejestrach nazwanych xmm0, ..., xmm7 po 128 bitów ka¿dy.
W trybie 64-bitowym dostêpne jest dodatkowych 8 rejestrów: xmm8, ..., xmm15.<BR>
Prawie ka¿da operacja zwi±zana z danymi w pamiêci musi mieæ te dane ustawione na 16-bajtowej
granicy, czyli jej adres musi siê dzieliæ przez 16. Inaczej generowane jest przerwanie (wyj±tek).
</P>
<P>
SSE 2 ró¿ni siê od SSE kilkoma nowymi instrukcjami konwersji u³amek-liczba ca³kowita oraz tym,
¿e mo¿e operowaæ na liczbach u³amkowych rozszerzonej precyzji (64 bity).</P>
<P>
U AMD czê¶ciowo 3DNow! operuje na u³amkach, ale co najwy¿ej na dwóch gdy¿ s± to rejestry
odpowiadaj±ce MMX, a wiêc 64-bitowe. 3DNow! Pro jest odpowiednikiem SSE w procesorach AMD.
Odpowiedniki SSE2 i SSE3 pojawi³y siê w AMD64.</P>

<P>
Instrukcje SSE (nie wszystkie bêd± wymienione):</P>
<UL>
  <LI>Przemieszczanie danych:
   <UL>
    <LI><code>MOVAPS</code> - <span lang="en">move aligned packed single precision floating point values</span>
    	 - przemie¶æ u³o¿one
	(na granicy 16 bajtów) spakowane u³amki pojedynczej precyzji (4 sztuki po 32 bity)</LI>
    <LI><code>MOVUPS</code> - <span lang="en">move unaligned</span> (nieu³o¿one) <span lang="en">packed single
     precision floating point values</span></LI>
    <LI><code>MOVSS</code> - <span lang="en">move scalar</span> (1 sztuka, najm³odsze 32 bity rejestru)
     <span lang="en">single precision floating point value</span></LI>
   </UL><BR></LI>
  <LI>Arytmetyczne:
   <UL>
    <LI><code>ADDPS</code> - <span lang="en">add packed single precision floating point values</span> =
     dodawanie czterech u³amków do czterech</LI>
    <LI><code>ADDSS</code> - <span lang="en">add scalar single precision floating point values</span> =
     dodawanie jednego u³amka do innego</LI>
    <LI><code>MULPS</code> - mno¿enie spakowanych u³amków, równolegle, 4 pary</LI>
    <LI><code>MULSS</code> - mno¿enie jednego u³amka przez inny</LI>
    <LI><code>DIVPS</code> - dzielenie spakowanych u³amków, równolegle, 4 pary</LI>
    <LI><code>DIVSS</code> - dzielenie jednego u³amka przez inny</LI>
    <LI>obliczanie odwrotno¶ci u³amków, ich pierwiastków, odwrotno¶ci pierwiastków, znajdowanie
	warto¶ci najwiêkszej i najmniejszej</LI>
   </UL><BR></LI>
  <LI>Logiczne:
   <UL>
    <LI><code>ANDPS</code> - logiczne AND spakowanych warto¶ci (ale oczywi¶cie tym bardziej zadzia³a
	dla jednego u³amka w rejestrze)</LI>
    <LI><code>ANDNPS</code> - AND NOT (najpierw bitowe NOT pierwszego rejestru, potem jego bitowe AND z
    	 drugim rejestrem) dla spakowanych</LI>
    <LI><code>ORPS</code> - OR dla spakowanych</LI>
    <LI><code>XORPS</code> - XOR dla spakowanych</LI>
   </UL><BR></LI>
  <LI>Instrukcje porównania: <code>CMPPS</code>, <code>CMPSS</code>, <code>(U)COMISS</code></LI>
  <LI>Instrukcje tasowania i rozpakowywania. Podobne dzia³anie jak odpowiadaj±ce instrukcje MMX.
   </LI>
  <LI>Instrukcje konwersji z u³amków na liczby ca³kowite i na odwrót.</LI>
  <LI>Instrukcje operuj±ce na liczbach ca³kowitych 64-bitowych (lub 128-bitowych w SSE 2)</LI>
</UL>
<P>W wiêkszo¶ci przypadków instrukcje dodane w SSE 2 ró¿ni± siê od powy¿szych ostatni± liter±, któr±
jest D, co oznacza <q lang="en">double precision</q>, na przyk³ad <code>MOVAPD</code>.
</P>
<Hr>
<P>No i krótki przyk³adzik. Inna wersja procedury do kopiowania pamiêci. Tym razem z SSE.</P>
	<BR><a href="#linux0607" class="bezdruk">(przeskocz kopiowanie pamiêci z SSE)</a>
<PRE title="kopiowanie pamiêci z SSE">
; Tylko je¶li ESI i EDI dzieli siê przez 16! Inaczej u¿ywaæ MOVUPS.
		mov ebx, ecx	; EBX = liczba bajtów
		and ebx, 127	; EBX = reszta z dzielenia liczby bajtów
				; przez 128
		shr ecx, 7	; ECX = liczba bajtów dzielona przez 128
	petla:
		; kopiuj 128 bajtów spod [ESI] do rejestrów XMM0, ... XMM7
		movaps xmm0, [esi]
		movaps xmm1, [esi+16]
		movaps xmm2, [esi+32]
		movaps xmm3, [esi+48]
		movaps xmm4, [esi+64]
		movaps xmm5, [esi+80]
		movaps xmm6, [esi+96]
		movaps xmm7, [esi+112]

		; kopiuj 128 bajtów z rejestrów XMM0, ... XMM7 do [EDI]
		movaps [edi    ], xmm0
		movaps [edi+16 ], xmm1
		movaps [edi+32 ], xmm2
		movaps [edi+48 ], xmm3
		movaps [edi+64 ], xmm4
		movaps [edi+80 ], xmm5
		movaps [edi+96 ], xmm6
		movaps [edi+112], xmm7

		add esi, 128	; zwiêksz indeksy do tablic o 128
		add edi, 128
		loop petla	; dzia³aj, dopóki ECX ró¿ne od 0

		mov ecx, ebx	; ECX = liczba pozosta³ych bajtów
		cld		; kierunek: do przodu
		rep movsb	; resztkê kopiujemy po bajcie</PRE>

<P><a name="linux0607" id="linux0607">Nie jest to idea³, przyznajê</a>. Mo¿na by³o na przyk³ad u¿yæ instrukcji
 wspieraj±cych pobieranie danych z pamiêci: <code><span lang="en">PREFETCH</span></code>.
</P>
<hr>
<P>A teraz co¶ innego: rozdzielanie danych. Przypu¶æmy, ¿e z jakiego¶ urz±dzenia (lub pliku)
czytamy bajty w postaci XYXYXYXYXY..., a my chcemy je rozdzieliæ na dwie tablice, zawieraj±ce tylko
XXX... i YYY... (oczywi¶cie bajty mog± mieæ ró¿ne warto¶ci, ale idea jest taka, ¿e co drugi
chcemy mieæ w drugiej tablicy). Oto, jak mo¿na tego dokonaæ z u¿yciem SSE2.
 <em class="wazne">To jest tylko fragment programu</em>.</P>
	<BR><a href="#linux0608" class="bezdruk">(przeskocz rozdzielanie bajtów)</a>
<PRE>
	mov	eax, 4			; funkcja zapisu do pliku
	mov	ebx, 1			; na stdout (ekran)
	mov	ecx, dane_pocz
	mov	edx, dane_pocz_dl
	int	80h

	mov	eax, 4			; funkcja zapisu do pliku
	mov	ebx, 1			; na stdout (ekran)
	mov	ecx, dane
	mov	edx, dane_dl
	int	80h			; wypisz dane pocz±tkowe


; FASM: "movaps		xmm0, dqword [dane]"
	movaps		xmm0, [dane]
	movaps		xmm1, xmm0
		; XMM1=XMM0 = X1Y1 X2Y2 X3Y3 X4Y4 X5Y5 X6Y6 X7Y7 X8Y8

		; XXM* musz± zawieraæ tylko po jednym bajcie w ka¿dym s³owie
	psllw		xmm0, 8
		; XMM0 = Y1 0 Y2 0 Y3 0 Y4 0 Y5 0 Y6 0 Y7 0 Y8 0
	psrlw		xmm0, 8
		; XMM0 = 0 Y1 0 Y2 0 Y3 0 Y4 0 Y5 0 Y6 0 Y7 0 Y8
	psrlw		xmm1, 8
		; XMM1 = 0 X1 0 X2 0 X3 0 X4 0 X5 0 X6 0 X7 0 X8

	packuswb	xmm0, xmm0
		; XMM0 = Y1Y2 Y3Y4 Y5Y6 Y7Y8 Y1Y2 Y3Y4 Y5Y6 Y7Y8

	packuswb	xmm1, xmm1
		; XMM1 = X1X2 X3X4 X5X6 X7X8 X1X2 X3X4 X5X6 X7X8


; FASM: "movq	qword [dane2], xmm0"
	movq	[dane2], xmm0	; dane2 ani dane1 ju¿ nie maj± adresu
				; podzielnego przez 16,
				; wiêc nie mo¿na u¿yæ MOVAPS
				; a my i tak chcemy tylko 8 bajtów
; FASM: "movq	qword [dane1], xmm1"
	movq	[dane1], xmm1

	mov	eax, 4			; funkcja zapisu do pliku
	mov	ebx, 1			; na stdout (ekran)
	mov	ecx, dane_kon
	mov	edx, dane_kon_dl
	int	80h

	mov	eax, 4			; funkcja zapisu do pliku
	mov	ebx, 1			; na stdout (ekran)
	mov	ecx, dane1
	mov	edx, dane1_dl
	int	80h			; wypisz pierwsze dane koñcowe

	mov	eax, 4			; funkcja zapisu do pliku
	mov	ebx, 1			; na stdout (ekran)
	mov	ecx, dane2
	mov	edx, dane2_dl
	int	80h			; wypisz drugie dane koñcowe

	mov	eax, 1
	xor	ebx, ebx
	int	80h



section .data
	; FASM: segment readable writeable

align	16			; dla SSE

dane		db	&quot;ABCDEFGHIJKLMNOP&quot;, 10
	; FASM: "=" zamiast "equ"
dane_dl		equ	$ - dane

dane1		db	0, 0, 0, 0, 0, 0, 0, 0, 10, 9
	; FASM: "=" zamiast "equ"
dane1_dl	equ	$ - dane1

dane2		db	0, 0, 0, 0, 0, 0, 0, 0, 10
	; FASM: "=" zamiast "equ"
dane2_dl	equ	$ - dane2

dane_pocz db &quot;Program demonstrujacy SSE. Dane na poczatku: &quot;, 10, 9
	; FASM: "=" zamiast "equ"
dane_pocz_dl	equ	$ - dane_pocz

dane_kon	db	&quot;Dane na koncu: &quot;, 10, 9
	; FASM: "=" zamiast "equ"
dane_kon_dl	equ	$ - dane_kon</PRE>

<BR>
<Hr>
<P>
<a name="linux0608" id="linux0608">Po szczegó³owy opis</a> wszystkich instrukcji odsy³am, jak zwykle do
<A class="intel_link" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" hreflang="en">Intela</A>
i <A class="amd_link" href="http://developer.amd.com/Resources/documentation/guides/Pages/default.aspx" hreflang="en">AMD</A>.

</P>
<P>
Instrukcje typu SIMD wspomagaj± szybkie przetwarzanie multimediów: d¼wiêku, obrazu. Omówienie
ka¿dej instrukcji w detalu jest niemo¿liwe i niepotrzebne, gdy¿ szczegó³owe opisy s± zamieszczone
w ksi±¿kach Intela lub AMD.
</P>
Mi³ej zabawy.

<br><br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="linux05.html">Poprzednia czê¶æ kursu</a> (Alt+3)<br>
<a accesskey="4" hreflang="pl" href="linux07.html">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>



<BR><BR><HR>
<h2 class="nag">Æwiczenia</h2>
<OL>
 <LI>Z dwóch zmiennych typu qword wczytaj do dwóch dowolnych rejestrów MMX (które najlepiej od razu
	skopiuj do innych), po czym wykonaj wszystkie mo¿liwe dodawania i odejmowania. Wynik
	ka¿dego zapisz w oddzielnej zmiennej typu qword.<BR><BR></LI>
 <LI>Wykonaj operacje logiczne OR, AND i XOR na 64 bitach na raz (wczytaj je do rejestru MMX,
	wynik zapisz do pamiêci).<BR><BR></LI>
 <LI>Wczytajcie do rejestru MMX warto¶æ szesnastkow± 30 31 30 31 30 31 30 31, po czym
	wykonajcie ró¿ne operacje rozpakowania i pakowania, zapiszcie i wy¶wietlcie wynik jak
	ka¿dy normalny ci±g znaków.<BR><BR></LI>
 <LI>Wczytajcie do rejestrów XMM po 4 liczby u³amkowe dword, wykonajcie dodawania i odejmowania,
	po czym sprawd¼cie wynik koprocesorem.</LI>


</OL>

</BODY></HTML>
