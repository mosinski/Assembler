<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks, czê¶æ 2 - Pamiêæ </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Prev"     hreflang="pl" lang="en" href="linux01.html" >
<link rel="Next"     hreflang="pl" lang="en" href="linux03.html" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="kurs, asm, asembler, assembler, pamiêæ, RAM, zmienne,
	stos, przerwania, procedury, db, dw, dd, dp, df dq, dt, adresowanie, nasm, fasm,
	segment, offset, tablice, linuks, linux">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="Kwrite">
<meta http-equiv="Last-Modified" content="Mon, Oct 29 2012 17:22:19 CEST">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler pod Linuksem?<BR>
	<h1 class="nag">Czê¶æ 2 - Pamiêæ, czyli gdzie upychaæ co¶, co siê nie mie¶ci w procesorze</h1>
	</div>

<P>Poznali¶my ju¿ rejestry procesora. Jak widaæ, jest ich ograniczona liczba i nie maj± one
zbyt du¿ego rozmiaru. Rejestry ogólnego przeznaczenia s± co najwy¿ej 32-bitowe (czterobajtowe).
Dlatego czêsto programista musi niektóre zmienne umieszczaæ w pamiêci. Przyk³adem tego by³
napis, który wy¶wietlali¶my w poprzedniej czê¶ci artyku³u. By³ on zadeklarowany dyrektyw± DB,
co oznacza <q lang="en">declare byte</q>.
 Ta dyrektywa niekoniecznie musi deklarowaæ dok³adnie 1 bajt. Tak jak
widzieli¶my, mo¿na ni± deklarowaæ napisy lub kilka bajtów pod rz±d. Teraz omówimy rodzinê
dyrektyw s³u¿±cych w³a¶nie do rezerwowania pamiêci.</P>
<P>
Ogólnie, zmienne mo¿na deklarowaæ jako bajty (dyrektyw± DB, co¶ jak <span lang="en">char</span> w jêzyku C),
 s³owa (<span lang="en">word</span> = 16 bitów = 2 bajty, co¶ jak <span lang="en">short</span> w C) dyrektyw± DW,
 podwójne s³owa DD (<span lang="en">double word = dword</span> = 32bity = 4 bajty, jak
  <span lang="en">long</span> w C), potrójne s³owa pword = 6 bajtów - PW,
 poczwórne s³owa DQ (<span lang="en">quad word = qword</span> = 8 bajtów, typ <span lang="en">long long</span>),
  tbyte = 10 bajtów - DT (typ <span lang="en">long double</span> w C).</P>
<P>
Sekcja kodu jest tylko do odczytu, wiêc zmienne, które chcemy móc rzeczywi¶cie zmieniæ,
<em class="wazne">musimy umie¶ciæ w sekcji danych</em>.
 Od tej pory umawiamy siê wiêc, ¿e ka¿da zmienna znajduje siê w
 obszarze <q lang="en">section .data</q> (dla NASMa) lub <q lang="en">segment readable writeable</q>
 (dla FASMa).</P>
<P>
 Przyk³ady:</P>
	<BR><a href="#linux0201" tabindex="1" class="bezdruk">(przeskocz przyk³ady)</a>

<PRE title="przyk³ady deklaracji zmiennych">
	section .data
	; FASM: segment readable writeable

	dwa		db 2
	szesc_dwojek	db 2, 2, 2, 2, 2, 2 ; tablica sze¶ciu bajtów
	litera_g	db &quot;g&quot;
	_ax		dw 4c00h	; dwubajtowa liczba ca³kowita
	alfa		dd 12348765h	; czterobajtowa liczba ca³kowita

	;liczba_a	dq 1125		; o¶miobajtowa liczba ca³kowita.
					; FASM przyjmie, NASM
					; starszy ni¿ wersja 2.00 nie.

					; dla NASMa zamienimy to na
					; postaæ równowa¿n±: 2 razy
					; po 4 bajty:
	liczba_a	dd 1125, 0

	liczba_e	dq 2.71		; liczba zmiennoprzecinkowa
					; podwójnej precyzji (8 bajtów),

				; dziesiêciobajtowa liczba ca³kowita:
	;duza_liczba  	dt 6af4aD8b4a43ac4d33h
				; FASM ani NASM tego nie przyjmie.
				; Zrobimy to tak:
	duza_liczba	dd 43ac4d33h, 0f4aD8b4ah; czemu z zerem z przodu?
						; Czytaj dalej
			db 6ah

	pi		dt 3.141592	; FASM i NASM

	;nie_init	db ?	; nie zainicjalizowany bajt.
				; Warto¶æ nieznana. NASM ani FASM tak
				; tego nie przyjmie. Nale¿y u¿yæ:

	nie_init	resb 1		; NASM
	;nie_init	rb 1		; FASM

	napis1		db &quot;NaPis1.&quot;
	xxx		db 1
			db 2
			db 3
			db 4</PRE>

<P><a name="linux0201" id="linux0201">Zwróæcie uwagê na sposób rozbijania</a>
 du¿ych liczb na poszczególne bajty: najpierw deklarowane
s± m³odsze bajty, a potem starsze (na przyk³ad <q>dd 11223344h</q> = <q>db 44h, 33h, 22h, 11h</q>). To
dzia³a, gdy¿ procesory Intela i
<acronym title="Advanced Micro Devices" lang="en">AMD</acronym>
(i wszystkie inne klasy x86) s± procesorami typu
<q lang="en">little-endian</q>, co znaczy, ¿e najm³odsze bajty danego ci±gu bajtów s± umieszczane przez
procesor w najni¿szych adresach pamiêci. Dlatego my te¿ tak deklarujemy nasze zmienne.</P>

<P>
Ale z kolei takie co¶:</P>
<PRE>	beta	db aah</PRE>
    <P>nie podzia³a. Dlaczego?
     <em class="wazne">KA¯DA liczba musi zaczynaæ siê od cyfry.</em> Jak to obej¶æ? Tak:</P>
<PRE>	beta	db 0aah</PRE>
<P>czyli poprzedziæ zerem.</P>

<P>Nie podzia³a równie¿ to:</P>
<PRE>	0gamma	db 	9</PRE>

<P>Dlaczego? Etykiety (dotyczy to tak danych, jak i kodu programu)
 <em class="wazne">nie mog± zaczynaæ siê od cyfr</em>.</P>
<p>
Zapisanie kilku warto¶ci po dyrektywie Dx (DB, DW, DD, i tak dalej) automatycznie
tworzy tablicê elementów odpowiedniego rozmiaru o tych warto¶ciach, z których ka¿da nastêpna
jest tu¿ po poprzedniej w pamiêci.
Na przyk³ad, nastêpuj±ca dyrektywa tworzy tak naprawdê tablicê sze¶ciu bajtów o warto¶ci 2, a nie
próbuje z sze¶ciu dwójek utworzyæ warto¶æ, któr± potem umie¶ci w pojedynczym bajcie:
</p>
<pre>
	szesc_dwojek	db 2, 2, 2, 2, 2, 2</pre>
<P>
A co, je¶li chcemy zadeklarowaæ zmienn±, powiedzmy, sk³adaj±c± siê z 234 bajtów równych zero?
Trzeba je wszystkie napisaæ?
<BR>
Ale¿ sk±d! Nale¿y u¿yæ operatora <span lang="en">TIMES</span>. Odpowied¼ na pytanie brzmi:</P>
<PRE title="deklaracja tablic w sk³adni NASM">
	section .data

	zmienna		TIMES	 234	db	0
	nazwa			liczba   typ    co zduplikowaæ</PRE>

<P>lub, w sk³adni FASMa:</P>
<PRE title="deklaracja tablic w sk³adni FASM">
	segment readable writeable

	; 234 razy zarezerwuj bajt warto¶ci 0:
	zmienna2:	times	 234	db	0</PRE>

<P>Rezerwacja obszaru bez okre¶lania jego warto¶ci wygl±da³aby mniej wiêcej tak:</P>
<PRE>
	section .data
	; FASM: segment readable writeable

	zmienna		resb	234		; NASM
	zmienna2	rb	234		; FASM</PRE>

<P>A co, je¶li chcemy mieæ dwuwymiarow± tablicê podwójnych s³ów o wymiarach 25 na 34?<BR>
Robimy dla NASMa na przyk³ad tak:</P>
<PRE>
	section .data

	Tablica		times	25*34	dd	0</PRE>

<P>a dla FASMa:</P>
<PRE>
	segment readable writeable

	; 25*34 razy zarezerwuj dword warto¶ci 0:
	Tablica2:	times	25*34	dd 	0</PRE>

<P>Do obs³ugi takich tablic przydadz± siê bardziej skomplikowane sposoby adresowania zmiennych. O
tym za moment.</P>
<P>
Zmiennych trzeba te¿ umieæ u¿ywaæ.<BR>
Do uzyskania adresu danej zmiennej u¿ywa siê nazwy tej zmiennej, tak
jak widzieli¶my wcze¶niej. Zawarto¶æ zmiennej otrzymuje siê poprzez umieszczenie jej nazwy
w nawiasach kwadratowych. Oto przyk³ad:</P>
<PRE title="przyk³ady deklaracji i dostêpu do zmiennych">
	section .data
	; FASM: segment readable writeable

	rejestr_eax	dd	1
	rejestr_bx	dw	0
	rejestr_cl	db	0
	...
		mov	[rejestr_bx], bx
		mov	cl, [rejestr_cl]
		mov	eax, [rejestr_eax]
		int	80h</PRE>

<P>Zauwa¿cie zgodno¶æ rozmiarów zmiennych i rejestrów.<BR>
Mo¿emy jednak mieæ problem w skompilowaniu czego¶ takiego:</P>
<PRE>	mov	[jakas_zmienna], 2</PRE>
<P>Dlaczego? Kompilator wie, ¿e gdzie¶ zadeklarowali¶my <q>jakas_zmienna</q>, ale nie wie, czy by³o to</P>
<PRE>	jakas_zmienna	db	0</PRE>
<P>czy</P>
<PRE>	jakas_zmienna	dw	22</PRE>
<P>czy mo¿e</P>
<PRE>	jakas_zmienna	dd	&quot;g&quot;</PRE>

<P>Chodzi o to, aby pokazaæ, jaki rozmiar ma obiekt docelowy. Nie bêdzie problemów, gdy napiszemy:</P>
<PRE title="dobry przyk³ad wpisywania liczb do zmiennych">	mov	word [jakas_zmienna], 2</PRE>
<P>I to obojêtnie, czy zmienna by³a bajtem (wtedy nastêpny bajt bêdzie równy 0), czy s³owem
(wtedy bêdzie ono mia³o warto¶æ 2) czy mo¿e podwójnym s³owem lub czym¶ wiêkszym (wtedy 2
pierwsze bajty zostan± zmienione, a pozosta³e nie). Dzieje siê tak dlatego, ¿e zmienne zajmuj±
kolejne bajty w pamiêci, najm³odszy bajt w komórce o najmniejszym adresie. Na przyk³ad:</P>
<PRE>	xxx	dd	8</PRE>
<P>jest równowa¿ne:</P>
<PRE>	xxx	db	8,0,0,0</PRE>
<P>oraz:</P>
<PRE>
	xxx	db	8
		db	0
		db	0
		db	0</PRE>

<P>
Te przyk³ady nie s± jedynymi sposobami adresowania zmiennych (poprzez nazwê).
   Na procesorach 32-bitowych (od 386) odnoszenie siê do pamiêci mo¿e odbywaæ siê wg schematu:</P>
<BR>
    <span class="b" style="font-size: 200%;">[    zmienna + rej_baz + rej_ind * skala +- liczba    ]</span>
<br>
   <P>gdzie:</P>
<UL>
 <LI><q>zmienna</q> oznacza nazwê zmiennej i jest to liczba obliczana przez kompilator lub linker</LI>
 <LI>rej_baz (rejestr bazowy) = jeden z rejestrów EAX, EBX, ECX, EDX, ESI,
 	EDI, EBP, ESP</LI>
 <LI>rej_ind (rejestr indeksowy) = jeden z rejestrów EAX, EBX, ECX, EDX, ESI,
 	EDI, EBP (bez ESP)</LI>
 <LI>mno¿nik (scale) = 1, 2, 4 lub 8 (gdy nie jest podany, przyjmuje siê 1)</LI>
</UL>
<P>Przyk³ady:</P>
<PRE title="przyk³ady 32-bitowego adresowania">
	mov	al, [ nazwa_zmiennej+2 ]
	mov	[ edi-23 ], cl
	mov	dl, [ ebx + esi*2 + nazwa_zmiennej+18 ]</PRE>


<P>

   Na procesorach 64-bitowych odnoszenie siê do pamiêci mo¿e odbywaæ siê wg schematu:</P>
<BR>
    <span class="b" style="font-size: 200%;">[    zmienna + rej_baz + rej_ind * skala +- liczba    ]</span>
<br>
   <P>gdzie:</P>
<UL>
 <LI><q>zmienna</q> oznacza nazwê zmiennej i jest to liczba obliczana przez kompilator lub linker</LI>
 <LI>rej_baz (rejestr bazowy) = jeden z rejestrów RAX, RBX, RCX, RDX, RSI,
 	RDI, RBP, RSP, R8, ..., R15, a nawet RIP (ale wtedy nie mo¿na u¿yæ ¿adnego
	rejestru indeksowego)</LI>
 <LI>rej_ind (rejestr indeksowy) = jeden z rejestrów RAX, RBX, RCX, RDX, RSI,
 	RDI, RBP, R8, ..., R15 (bez RSP i RIP)</LI>
 <LI>mno¿nik (scale) = 1, 2, 4 lub 8 (gdy nie jest podany, przyjmuje siê 1)</LI>
</UL>
<P>Dwie zasady:</P>
<ul>
<li> miêdzy nawiasami kwadratowymi nie mo¿na mieszaæ rejestrów ró¿nych rozmiarów</li>
<li> w trybie 64-bitowym nie mo¿na do adresowania u¿ywaæ rejestrów cz±stkowych: R*D, R*W, R*B.</li>
</ul>
<P>Przyk³ady:</P>
<PRE title="przyk³ady 64-bitowego adresowania">
	mov	al, [ nazwa_zmiennej+2 ]
	mov	[ rdi-23 ], cl
	mov	dl, [ rbx + rsi*2 + nazwa_zmiennej+18 ]
	mov	rax, [rax+rbx*8-34]
	mov	rax, [ebx]
	mov	r8d, [ecx-11223344]
	mov	cx, [r8]</PRE>



<P>
A teraz inny przyk³ad: spróbujemy wczytaæ 5 elementów o numerach 1, 3, 78, 25, i 200 (pamiêtajmy, ¿e
liczymy od zera) z tablicy <q>zmienna</q> (tej o 234 bajtach, zadeklarowanej wcze¶niej)
do kilku rejestrów 8-bitowych. Operacja nie jest trudna i wygl±da po prostu tak:</P>
<PRE title="przyk³ad dostêpu do tablicy">
	mov	al, [ zmienna + 1 ]
	mov	ah, [ zmienna + 3 ]
	mov	cl, [ zmienna + 78 ]
	mov	ch, [ zmienna + 25 ]
	mov	dl, [ zmienna + 200 ]</PRE>

<P>Oczywi¶cie, kompilator nie sprawdzi za Was, czy takie elementy tablicy rzeczywi¶cie istniej± -
o to musicie zadbaæ sami.</P>
<P>W powy¿szym przyk³adzie rzuca siê w oczy, ¿e ci±gle u¿ywamy s³owa <q>zmienna</q>, bo wiemy, gdzie
jest nasza tablica. Je¶li tego nie wiemy (dynamiczne przydzielanie pamiêci), lub z
innych przyczyn nie chcemy ci±gle pisaæ <q>zmienna</q>, mo¿emy pos³u¿yæ siê bardziej z³o¿onymi
sposobami adresowania. Po chwili zastanowienia bez problemu stwierdzicie, ¿e powy¿szy kod
mo¿na bez problemu zast±piæ czym¶ takim i te¿ bêdzie dzia³aæ:</P>
<PRE title="dostêp do tablicy z u¿yciem rejestru">
	mov	ebx, zmienna
	mov	al, [ ebx + 1 ]
	mov	ah, [ ebx + 3 ]
	mov	cl, [ ebx + 78 ]
	mov	ch, [ ebx + 25 ]
	mov	dl, [ ebx + 200 ]</PRE>

<P>Teraz trudniejszy przyk³ad: spróbujmy dobraæ siê do kilku elementów dwuwymiarowej tablicy dwordów
zadeklarowanej wcze¶niej (tej o rozmiarze 25 na 34). Mamy 25 wierszy po 34 elementy ka¿dy.
Aby do EAX wpisaæ pierwszy element pierwszego wiersza, piszemy oczywi¶cie tylko:</P>
<PRE>	mov	eax, [Tablica]</PRE>

<P>Ale jak odczytaæ 23 element 17 wiersza? Otó¿, sprawa nie jest taka trudna, jakby siê mog³o
wydawaæ. Ogólny schemat wygl±da tak (zak³adam, ¿e ostatni wska¼nik zmienia siê najszybciej,
potem przedostatni itd. - pamiêtamy, ¿e rozmiar elementu wynosi 4):</P>
<PRE>	Tablica[17][23] = [ Tablica + (17*d³ugo¶æ wiersza + 23)*4 ]</PRE>

<P>No to piszemy:</P>
<PRE title="dostêp do tablicy w pêtli">
	mov	ebx, Tablica
	mov	esi, 17
   jakas_petla:
	imul	esi, 34		; ESI=ESI*34=17 * d³ugo¶æ wiersza
	add	esi, 23		; ESI=ESI+23=17 * d³ugo¶æ wiersza + 23
	mov	eax, [ ebx + esi*4 ]	; mno¿ymy numer elementu przez
					; rozmiar elementu
	...</PRE>

<P>Mo¿na by³o to zrobiæ po prostu tak:</P>
<PRE>	mov	eax, [ Tablica + (17*34 + 23)*4 ]</PRE>

<P>ale poprzednie rozwi±zanie (na rejestrach) jest wprost idealne do pêtli, w której robimy co¶
z coraz to innym elementem tablicy.</P>
<P>
Podobnie (<q>(numer_wiersza*d³ugo¶æ_wiersza1 + numer_wiersza*d³ugo¶æ_wiersza2 + ...
)*rozmiar_elementu</q>)
adresuje siê tablice wielowymiarowe. Schemat jest nastêpuj±cy:</P>
<PRE title="adresowanie z³o¿onych tablic">
	Tablica[d1][d2][d3][d4]	   - 4 wymiary o d³ugo¶ciach wierszy
						 d1, d2, d3 i d4

	Tablica[i][j][k][m] = [ Tablica + (i*d2*d3*d4+j*d3*d4+k*d4+m)*
				*rozmiar_elementu ]</PRE>

<P>Teraz powiedzmy, ¿e mamy tak± tablicê:</P>
<PRE>	dword tab1[24][78][13][93]</PRE>
<P>Aby dobraæ siê do elementu tab1[5][38][9][55], piszemy:</P>
<PRE>	mov	eax, [ tab1 + (5*78*13*93 + 38*13*93 + 9*93 + 55)*4 ]</PRE>

<P>
Pytanie: do jakich segmentów siê to odnosi? Przecie¿ mamy kilka rejestrów segmentowych, które
mog± wskazywaæ na zupe³nie co innego.<BR>
Odpowied¼:<BR>
Na rejestrach 32-bitowych mamy:</P>
<OL>
 <LI>je¶li pierwszym w kolejno¶ci rejestrem jest EBP lub ESP, u¿ywany jest SS</LI>
 <LI>w pozosta³ych przypadkach u¿ywany jest DS</LI>
</OL>
<P>W systemach 64-bitowych segmenty odchodz± w zapomnienie.</P>
<br>
Domy¶lne ustawianie mo¿na zawsze obej¶æ u¿ywaj±c przedrostków, na przyk³ad
<PRE title="uzycie segmentów innych ni¿ domy¶lne">
	mov	ax, [ss:si]
	mov	[gs:eax+ebx*2-8], cx</PRE>

<BR>




<HR>
<h2 class="nag">Organizacja pamiêci w Linuksie</h2>

<P>
W systemie Linux ka¿dy program dostaje swoj± w³asn± przestrzeñ, nie jest mo¿liwe zapisywanie zmiennych
 lub kodu innych programów (z wyj±tkami, na przyk³ad debugery). Teoretycznie rozmiar owej przestrzeni wynosi
 tyle, ile mo¿na zaadresowaæ w ogóle ca³ym procesorem, czyli 2^32 = 4
 <abbr title="gigabajt">GB</abbr> na procesorach 32-bitowych.
 Obszar ten jest jednak od góry trochê ograniczony przez sam system, ale nie bêdziemy siê tym zajmowaæ.
</P>
<P>
Struktura programu po uruchomieniu jest do¶æ prosta: ca³y kod, dane i stos (o tym za chwilê) znajduj± siê
 w jednym segmencie, rozci±gaj±cym siê na ca³± wspomnian± przestrzeñ. Na moim systemie wykonywanie zaczyna siê
 pod adresem 08048080h w tej przestrzeni.</P>
	<BR><a href="#linux0202" class="bezdruk">(przeskocz ilustracjê pamiêci programu w Linuksie)</a>
<PRE title="uk³ad programu w Linuksie" class="asciiart">
		+-----------------------+
		|	BFFFFFFF    	|
		|    Stos, argumenty   	|
		+-     zm. lokalne     -+
		|	 .....    	|
		+-	 .....	       -+
		|  Dane, zm. globalne   |
		|      (statyczne)	|
		+-	 .....	       -+
		| 	 kod		|
		+-	 .....	       -+
		|	08048080h    	|
       CS=DS=SS +-----------------------+</PRE>

<P>
<a name="linux0202" id="linux0202">Najni¿ej w pamiêci znajduje siê kod, za nim dane</a>, a na
koñcu - stos.</P>
<P>Jak w takim razie realizowana jest ochrona kodu przed zapisem?<BR>
W samym procesorze istnieje mechanizm stronicowania, który umo¿liwia przyznanie odpowiednich praw
 do danych stron pamiêci (zwykle strona ma 4<abbr title="kilobajt">kB</abbr>).
 Tak wiêc, nasz du¿y segment jest podzielony na strony z kodem, danymi i stosem.</P>





<BR><HR>
<h2 class="nag">Stos</h2>
<P>
Przysz³a pora na omówienie, czym jest stos.<BR>
Otó¿, stos jest po prostu kolejnym segmentem pamiêci.
 S± na nim umieszczane dane tymczasowe, na przyk³ad
<em class="wazne">adres powrotny z funkcji, jej parametry wywo³ania, jej zmienne lokalne</em>.
S³u¿y te¿ do zachowywania zawarto¶ci rejestrów.<BR>
Obs³uga stosu jest jednak zupe³nie inna.</P>
<P>
Po pierwsze, stos jest <q>budowany</q> od góry na dó³! Rysunek bêdzie bardzo pomocny:</P>
	<BR><a href="#linux0203" class="bezdruk">(przeskocz rysunek stosu)</a>
<PRE title="rysunek stosu" class="asciiart">

	Adres
			SS
		+-------------------+
	100h	|		    |
		+-------------------+	&lt;----- ESP = 100h
	0FEh	|		    |
		+-------------------+
	0FCh	|		    |
		+-------------------+
	0FAh	|		    |
		+-------------------+
	0F8h	|		    |
		+-------------------+
	0F6h	|		    |
	...		....</PRE>

<P><a name="linux0203" id="linux0203">Na tym rysunku ESP=100h</a>,
 czyli ESP wskazuje na komórkê o adresie 100h w segmencie SS.</P>
<P>Dane na stosie umieszcza siê instrukcj± <code><span lang="en">PUSH</span></code>
a zdejmuje instrukcj± <code>POP</code>.
 <code><span lang="en">PUSH</span></code> jest równowa¿ne parze instrukcji:</P>
<PRE>
	sub	esp, ..	   ; odejmowana liczba zale¿y od
			   ; rozmiaru obiektu w bajtach
	mov	[ss:esp], ..</PRE>

<P>a <code>POP</code>:</P>
<PRE>
	mov	.., [ss:esp]
	add	esp, ..</PRE>

<P>Tak wiêc, po wykonaniu instrukcji <code><span lang="en">PUSH</span> AX</code>
i <code><span lang="en">PUSH</span> DX</code> powy¿szy stos bêdzie wygl±da³ tak:</P>
	<BR><a href="#linux0204" class="bezdruk">(przeskocz ilustracjê dzia³ania <span lang="en">PUSH</span>)</a>
<PRE title="operacje na stosie: PUSH" class="asciiart">
	Stos po wykonaniu  PUSH AX i PUSH DX, czyli
		sub	esp, 2
		mov	[ss:esp], ax
		sub	esp, 2
		mov	[ss:esp], dx

			SS
		+-------------------+
	100h	|		    |
		+-------------------+
	0FEh	|	AX	    |
		+-------------------+
	0FCh	|	DX	    |
		+-------------------+	&lt;----- ESP = 0FCh
	...		....</PRE>

<P><a name="linux0204" id="linux0204">SP=0FCh, pod [SP] znajduje siê warto¶æ DX</a>, a pod
[SP+2] - warto¶æ AX.
A po wykonaniu instrukcji <code>POP EBX</code> (tak, mo¿na zdj±æ dane do innego rejestru, ni¿
ten, z którego pochodzi³y):</P>
	<BR><a href="#linux0205" class="bezdruk">(przeskocz ilustracjê dzia³ania POP)</a>
<PRE title="operacje na stosie: POP" class="asciiart">
	Stos po wykonaniu POP EBX, czyli
		mov	ebx, [ss:esp]
		add	esp, 4

			SS
		+-------------------+
	100h	|		    |
		+-------------------+	&lt;----- ESP = 100h
	0FEh	|	AX	    |
		+-------------------+
	0FCh	|	DX	    |
		+-------------------+
	...		....</PRE>

<P><a name="linux0205" id="linux0205">Teraz ponownie SP=100h</a>.
Zauwa¿cie, ¿e dane s± tylko kopiowane ze stosu, a nie z niego usuwane. Ale w ¿adnym przypadku nie
mo¿na na nich ju¿ polegaæ. Dlaczego? Zobaczycie zaraz.<BR>
Najpierw bardzo wa¿na uwaga, która jest wnioskiem z powy¿szych rysunków.<BR>
Dane (które chcemy z powrotem odzyskaæ w niezmienionej postaci) po³o¿one na stosie instrukcj±
<code><span lang="en">PUSH</span></code> nale¿y zdejmowaæ kolejnymi instrukcjami <code>POP</code>
 <em class="wazne">W ODWROTNEJ KOLEJNO¦CI</em> ni¿ by³y k³adzione.
Zrobienie czego¶ takiego:</P>
<PRE>
	push	eax
	push	edx
	pop	eax
	pop	edx</PRE>

<P><em class="wazne">nie przywróci rejestrom ich dawnych warto¶ci!</em></P>






<BR><HR>
<h2 class="nag">Przerwania i procedury a stos</h2>
<P>
U¿ywali¶my ju¿ instrukcji przerwania, czyli <code>INT</code>. Przy okazji omawiania stosu nadesz³a pora, aby
powiedzieæ, co ta instrukcja w ogóle robi. Otó¿, <code>INT</code> jest (w przybli¿eniu) równowa¿ne temu
pseudo-kodowi:</P>
<PRE title="dzia³anie instrukcji INT">
	pushfd			; w³ó¿ na stos rejestr stanu procesora
				; czyli flagi
	push	cs		; segment, w którym aktualnie pracujemy
	push	eip_next	; adres instrukcji po INT
	jmp	procedura_obslugi_przerwania</PRE>

<P>Ka¿da procedura obs³ugi przerwania (<span lang="en">Interrupt Service Routine</span>, ISR)
 koñczy siê instrukcj± <code>IRET</code> (<span lang="en">interrupt return</span>),
 która odwraca powy¿szy kod, czyli z
ISR procesor wraca do dalszej obs³ugi naszego programu.</P>
<P>
Jednak oprócz instrukcji <code>INT</code> przerwania mog± byæ wywo³ane w inny sposób - przez sprzêt. Tutaj
w³a¶nie pojawiaj± siê <acronym lang="en" title="Interrupt Request">IRQ</acronym>.
 Do urz±dzeñ wywo³uj±cych przerwania IRQ nale¿± miêdzy innymi karta d¼wiêkowa,
modem, zegar, kontroler dysku twardego, itd...</P>
<P>
Bardzo istotn± rolê gra zegar, utrzymuj±cy aktualny czas w systemie. Jak napisa³em w jednym z
artyku³ów, tyka on z czêstotliwo¶ci± ok. 18,2 Hz. Czyli ok. 18 razy na sekundê wykonywane s± 3
<code><span lang="en">PUSH</span></code>e a po nich 3 <code>POP</code>y.
 Nie zapominajmy o push i pop wykonywanych w samej ISR tylko po to,
aby zachowaæ modyfikowane rejestry. Ka¿dy <code><span lang="en">PUSH</span></code> zmieni to,
co jest poni¿ej ESP.</P>

<P><em class="wazne">Dlatego w³a¶nie ¿adne dane poni¿ej ESP nie mog± byæ uznawane za wiarygodne.</em></P>
<P>
Gdzie za¶ znajduj± siê adresy procedur obs³ugi przerwañ?<BR>
W pamiêci, w Tabeli Deskryptorów Przerwañ (<span lang="en">Interrupt Descriptor Table</span>, IDT), do której
dostêp ma wy³±cznie system operacyjny. Na pojedynczy deskryptor przerwania sk³ada siê oczywi¶cie
adres procedury obs³ugi przerwania, jej deskryptor, prawa dostêpu do niej i kilka innych
informacji, które z punktu widzenia programisty nie s± (na razie) istotne.</P>

<P>
Mniej skomplikowana jest instrukcja <code><span lang="en">CALL</span></code>,
 która s³u¿y do wywo³ywania zwyk³ych procedur, na przyk³ad:</p>
<pre>
	call proc1		; wywo³anie proste
	call [adres_proc1]	; wywo³anie procedury, której adres
				; jest w zmiennej adres_proc1
	...
proc1:
	...
	ret</pre>
<p> W zale¿no¶ci od rodzaju procedury
(<span lang="en">near</span> - zwykle w tym samym pliku/programie, far - na przyk³ad w innym pliku/segmencie),
instrukcja <code><span lang="en">CALL</span></code> wykonuje takie co¶:</P>
<PRE title="dzia³anie instrukcji CALL">
	push	cs i kilka innych rzeczy ; tylko je¶li FAR
	push	eip_next	; adres instrukcji po CALL</PRE>

<P>Procedura mo¿e zawieraæ dowolne (nawet niesymetryczne ilo¶ci instrukcji
<code><span lang="en">PUSH</span></code> i <code>POP</code>), ale
pod koniec ESP musi byæ taki sam, jak by³ na pocz±tku, czyli wskazywaæ na prawid³owy adres powrotu,
który ze stosu jest zdejmowany instrukcj± <code>RET</code> (lub <code>RETF</code>). Dlatego
nieprawid³owe jest takie co¶:</P>
<PRE title="nieprawid³owa procedura">
	zla_procedura:
		push	eax
		push	ebx
		add	eax, ebx
		ret</PRE>

<P>gdy¿ w chwili wykonania instrukcji <code>RET</code> na wierzchu stosu jest EBX, a nie adres powrotny! B³±d
stosu jest przyczyn± wielu trudnych do znalezienia usterek w programie.
<BR> Jak to poprawiæ bez zmiany sensu? Na przyk³ad tak:</P>
<PRE title="prawid³owa procedura">
	moja_procedura:
		push	eax
		push	ebx
		add	eax, ebx
		add	esp, 8
		ret</PRE>

<P>Teraz ju¿ wszystko powinno byæ dobrze. ESP wskazuje na dobry adres powrotny. Dopuszczalne jest
te¿ takie co¶:</P>
<PRE title="kolejna prawid³owa procedura">
	proc1:
		push	eax
		cmp	eax, 0		; czy EAX jest zerem?
		je	koniec1		; je¶li tak, to koniec1

		pop	ebx
		ret
	koniec1:
		pop	ecx
		ret</PRE>

<P>ESP ci±gle jest dobrze ustawiony przy wyj¶ciu z procedury mimo, i¿ jest 1
<code><span lang="en">PUSH</span></code> a 2 <code>POP</code>y.<BR>
Po prostu ZAWSZE nale¿y robiæ tak, aby ESP wskazywa³ na poprawny adres powrotny, niezale¿nie od
sposobu.
W sk³ad tego wchodzi definiowanie procedur pod g³ównym programem (po ostatnich instrukcjach
zamykaj±cych program).
Dlaczego? Niektóre (najprostsze)
formaty plików wykonywalnych nie pozwalaj± na okre¶lenie pocz±tku programu i takie programy
s± wykonywane po prostu z góry na dó³. Je¶li u góry kodu umie¶ci siê procedury, zostan± one wykonane,
po czym instrukcja <code>RET</code> (lub <code>RETF</code>) spowoduje zamkniêcie programu
(w najlepszym przypadku) lub wej¶cie procesora na nieprawid³owe lub losowe instrukcje w pamiêci.
</P>







<hr>
<h2 class="nag">Alokacja zmiennych lokalnych procedury</h2>
<P>
Nie musi siê to Wam od razu przydaæ, ale przy okazji stosu omówiê, gdzie znajduj± siê
 zmienne lokalne funkcji (na przyk³ad takich w jêzyku C) oraz jak rezerwowaæ na nie miejsce.</P>
<P>
Gdy program wykonuje instrukcjê <code><span lang="en">CALL</span></code>, na stosie umieszczany jest adres
 powrotny (o czym ju¿ wspomnia³em). Jako ¿e nad nim mog± byæ jakie¶ dane wa¿ne dla programu
 (na przyk³ad zachowane rejestry, inne adresy powrotne),
 nie wolno tam nic zapisywaæ. Ale pod adresem powrotnym jest du¿o miejsca i to tam w³a¶nie
 programy umieszczaj± swoje zmienne lokalne.</P>
<P>Samo rezerwowanie miejsca jest do¶æ proste: liczymy, ile ³±cznie bajtów nam potrzeba na
 w³asne zmienne i tyle w³a¶nie odejmujemy od rejestru ESP, robi±c tym samym miejsce na stosie, które
 nie bêdzie zamazane przez instrukcje <code>INT</code> i <code><span lang="en">CALL</span></code>
(gdy¿ one zamazuj± tylko to, co jest pod ESP).</P>
<P>Na przyk³ad, je¶li nasze zmienne zajmuj± 8 bajtów (np.dwa DWORDy lub dwie 32-bitowe zmienne
 typu "int" w jêzyku C), to odejmujemy te 8 od ESP i nasz nowy stos wygl±da tak:</P>

<pre title="rezerwacja miejsca na zmienne lokalne" class="asciiart">
			SS
		+-------------------+
	100h	|  adres powrotny   |
		+-------------------+	&lt;----- stary ESP = 100h
	0FEh	|	wolne	    |
		+-------------------+
	0FCh	|	wolne	    |
		+-------------------+
	0FAh	|	wolne	    |
		+-------------------+
	0F8h	|	wolne	    |
		+-------------------+	&lt;----- ESP = 0F8h</pre>

<P>ESP wynosi 0F8h, nad nim jest 8 bajtów wolnego miejsca, po czym adres powrotny i inne stare dane.
</p>
<p>
Nie trzeba podawaæ typów zmiennych lokalnych, ich liczby ani ich nazywaæ - wystarczy obliczyæ ich
³±czny rozmiar i ten rozmiar odj±æ od ESP. To, gdzie która zmienna faktycznie w pamiêci siê
znajdzie (lub inaczej: który obszar pamiêci bêdzie przypisany której zmiennej), zale¿y
ca³kowicie od programisty - na przyk³ad [ESP] mo¿e przechowywaæ pierwsz± zmienn±, a [ESP+4]
- drug±, ale mo¿e byæ te¿ ca³kiem na odwrót.</P>
<p>
Miejsce ju¿ mamy, korzystanie z niego jest proste - wystarczy odwo³ywaæ siê do
 [ESP], [ESP+2], [ESP+4], [ESP+6]. Ale stanowi to pewien problem, bo po ka¿dym wykonaniu
 instrukcji <code><span lang="en">PUSH</span></code>, te cyferki siê zmieniaj± (bo przecie¿ adresy siê
 nie zmieniaj±, ale ESP siê zmienia). Dlatego w³a¶nie do adresowania zmiennych lokalnych
 czêsto u¿ywa siê innego rejestru ni¿ ESP. Jako ¿e domy¶lnym segmentem dla EBP jest segment stosu,
 wybór pad³ w³a¶nie na ten rejestr (oczywi¶cie, mo¿na u¿ywaæ dowolnego innego, tylko trzeba
 dostawiaæ SS: z przodu, co kosztuje za ka¿dym razem 1 bajt).</P>
<P>
Aby móc naj³atwiej dostaæ siê do swoich zmiennych lokalnych, wiêkszo¶æ funkcji na pocz±tku
 zrównuje EBP z ESP, potem wykonuje rezerwacjê miejsca na zmienne lokalne, a dopiero potem
 - zachowywanie rejestrów itp. (czyli swoje <code><span lang="en">PUSH</span></code>e). Wygl±da to tak:</P>
<pre>
	push	ebp		; zachowanie starego EBP
	mov	ebp, esp	; EBP = ESP

	sub	esp, xxx	; rezerwacja miejsca na zmienne lokalne
	push	rej1		; tu ESP siê zmienia, ale EBP ju¿ nie
	push	rej2
	...

	...
	pop	rej2		; tu ESP znów siê zmienia, a EBP - nie
	pop	rej1

	mov	esp, ebp	; zwalnianie zmiennych lokalnych
				;   mo¿na te¿ (ADD ESP,xxx)
	pop	ebp

	ret</pre>

<p>
Niektóre kompilatory umo¿liwiaj± deklaracjê procedury z parametrami, zmiennymi lokalnymi i ich typami:
</p>
<pre>
	proc2 proc a:DWORD,b:DWORD
		LOCAL c:DWORD
		LOCAL d:DWORD
		LOCAL e:DWORD
		...
		ret
	proc2 endp</pre>
<p>
Mo¿na wtedy odwo³ywaæ siê do parametrów i zmiennych lokalnych przez ich nazwy, zamiast przez wyra¿enia
typu [ESP+nnn] i [ESP-nnn].
</p>
<P>Przy instrukcji <code>MOV ESP, EBP</code> napisa³em, ¿e zwalnia ona zmienne lokalne.
 Zmienne te oczywi¶cie dalej s± na stosie, ale teraz s± ju¿ poni¿ej ESP, a niedawno
 napisa³em: <em class="wazne">¿adne dane poni¿ej ESP nie mog± byæ uznawane za wiarygodne.</em>
</P>
<P>
Po piêciu pierwszych instrukcjach nasz stos wygl±da tak:</P>
<pre title="EBP i ESP po prologu" class="asciiart">
			   SS
		+-----------------------+
		|    adres powrotny	|
		+-----------------------+
		|       stary EBP	|
		+-----------------------+	&lt;----- EBP
		|      xxx bajtów	|
		|			|
		|			|
		+-----------------------+
		|  	  rej1		|
		+-----------------------+
		|	  rej2		|
		+-----------------------+	&lt;----- ESP</pre>

<P>Rejestr EBP wskazuje na star± warto¶æ EBP, za¶ ESP - na ostatni element w³o¿ony na stos.<br>
I widaæ teraz, ¿e zamiast odwo³ywaæ siê do zmiennych lokalnych poprzez <code>[ESP+liczba]</code> przy ci±gle
 zmieniaj±cym siê ESP, o wiele wygodniej odwo³ywaæ siê do nich przez <code>[EBP-liczba]</code>
 (zauwa¿cie: minus), bo EBP pozostaje niezmienione.</P>
<P>
Czêsto na przyk³ad w disasemblowanych programach widaæ instrukcje typu <code> <span lang="en">AND</span> ESP, NOT 16</code>
 (lub <code> <span lang="en">AND</span> ESP, ~16</code> w sk³adni NASM). Jedynym celem takich instrukcji jest
 wyrównanie ESP do pewnej po¿±danej granicy, na przyk³ad 16 bajtów (wtedy <code><span lang="en">AND</span></code>
 z warto¶ci± NOT 16, czyli FFFFFFF0h), ¿eby dostêp do zmiennych lokalnych trwa³ krócej.
 Gdy adres
 zmiennej na przyk³ad czterobajtowej jest nieparzysty, to potrzeba dwóch dostêpów do pamiêci, ¿eby j± ca³±
 pobraæ (bo mo¿na pobraæ 32 bity z na raz w procesorze 32-bitowym i tylko z adresu podzielnego przez 4).
</P>
<P>
Ogó³ danych: adres powrotny, parametry funkcji, zmienne lokalne i zachowane rejestry nazywany jest
 czasem <span class="b">ramk± stosu</span> (ang. <span lang="en">stack frame</span>).<br>
  Rejestr
 EBP jest czasem nazywany wska¼nikiem ramki, gdy¿ umo¿liwia od dostêp do wszystkich istotnych danych poprzez
 sta³e przesuniêcia (offsety, czyli te liczby dodawane i odejmowane od EBP): zmienne
 lokalne s± pod <code>[EBP-liczba]</code>, parametry funkcji przekazane z zewn±trz -
 pod <code>[EBP+liczba]</code>, za¶ pod <code>[EBP]</code> jest stara warto¶æ EBP. Je¶li wszystkie
 funkcje w programie zaczynaj± siê tym samym prologiem: <code>PUSH EBP / MOV EBP, ESP</code>, to
 po wykonaniu instrukcji <code>MOV EBP, [EBP]</code> w EBP znajdzie siê wska¼nik ramki ...
 procedury wywo³uj±cej. Je¶li znamy jej strukturê, mo¿na w ten sposób dostaæ siê do jej
 zmiennych lokalnych.</P>

<Hr>
<P>
Zainteresowanych szczegó³ami adresowania lub instrukcjami odsy³am do
<A class="intel_link" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" hreflang="en">Intela</A>
i
<A class="amd_link" href="http://developer.amd.com/Resources/documentation/guides/Pages/default.aspx" hreflang="en">AMD</A></P>


<P>Nastêpnym razem o podstawowych instrukcjach jêzyka asembler.</P>

<blockquote>- Ilu programistów potrzeba, aby wymieniæ ¿arówkê?<BR>
- Ani jednego. To wygl±da na problem sprzêtowy.</blockquote>

<br><br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="linux01.html">Poprzednia czê¶æ kursu</a> (Alt+3)<br>
<a accesskey="4" hreflang="pl" href="linux03.html">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

<BR><BR><HR>
<h2 class="nag">Æwiczenia</h2>
<OL>
 <LI>Zadeklaruj tablicê 12 zmiennych maj±cych po 10 bajtów:
  <OL class="alfa">
   <LI>zainicjalizowan± na zera (pamiêtaj o ograniczeniach kompilatora)</LI>
   <LI>niezainicjalizowan±</LI>
  </OL>
 <BR></LI>

 <LI>Zadeklaruj tablicê 12 s³ów (16-bitowych) o warto¶ci BB (szesnastkowo), po czym do
	ka¿dego z tych s³ów wpisz warto¶æ FF szesnastkowo (bez ¿adnych pêtli).
	Mo¿na (a nawet trzeba) u¿yæ wiêcej ni¿ 1 instrukcji.
	 Pamiêtaj o odleg³o¶ciach miêdzy
	poszczególnymi elementami tablicy. Naucz siê ró¿nych sposobów adresowania: liczba
	(nazwa zmiennej + numer), baza (rejestr bazowy + liczba), baza + indeks (rejestr
	bazowy + rejestr indeksowy).<BR><BR></LI>

 <LI>Zadeklaruj dwuwymiarow± tablicê bajtów o warto¶ci 0 o wymiarach 13 wierszy na 5 kolumn,
	 po czym do elementu numer 3 (przedostatni) w wierszu o numerze 12 (ostatni) wpisz
	 warto¶æ FF. Spróbuj u¿yæ ró¿nych sposobów adresowania.
	</LI>
</OL>

</BODY></HTML>
