<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks, czê¶æ 3 - Instrukcje </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Prev"     hreflang="pl" lang="en" href="linux02.html" >
<link rel="Next"     hreflang="pl" lang="en" href="linux04.html" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="kurs, asm, asembler, assembler, instrukcje, skoki, warunki,
	arytmetyka, logika, bity, porty, ³añcuchy znaków, flagi, linux, linuks">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="Kwrite">
<meta http-equiv="Last-Modified" content="Mon, Oct 29 2012 17:22:19 CEST">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler pod Linuksem?<BR>
	<h1 class="nag">Czê¶æ 3 - Podstawowe instrukcje, czyli poznajemy dialekt procesora</h1></div>

<P>
Poznali¶my ju¿ rejestry, omówili¶my pamiêæ. Pora zacz±æ na nich operowaæ.<Br>
 Zanim jednak zaczniemy,
proszê Was o to, aby¶cie tej listy te¿ <em class="wazne">NIE uczyli siê na pamiêæ</em>.
Instrukcji jest du¿o, a próba zrozumienia ich wszystkich na raz mo¿e spowodowaæ niez³y chaos. Co najwy¿ej
przejrzyjcie tê listê kilka razy, aby wiedzieæ mniej-wiêcej, co ka¿da instrukcja robi.
</P>
<P>
Instrukcje procesora mo¿na podzieliæ na kilka grup:</P>
<UL>
 <LI>instrukcje przemieszczania danych</LI>
 <LI>instrukcje arytmetyki binarnej</LI>
 <LI>instrukcje arytmetyki dziesiêtnej</LI>
 <LI>instrukcje logiczne</LI>
 <LI>operacje na bitach i bajtach</LI>
 <LI>instrukcje przekazuj±ce kontrolê innej czê¶ci programu (steruj±ce wykonywaniem programu)</LI>
 <LI>instrukcje operuj±ce na ³añcuchach znaków</LI>
 <LI>instrukcje kontroli flag</LI>
 <LI>instrukcje rejestrów segmentowych</LI>
 <LI>inne</LI>
</UL>
<P>Zacznijmy je po kolei omawiaæ (nie omówiê wszystkich).</P>
<OL>
 <LI>instrukcje przemieszczania danych.<BR>
	<P>Tutaj zaliczymy ju¿ wielokrotnie u¿ywane <CODE>MOV</CODE> oraz kilka innych:
	<CODE>XCHG</CODE> &nbsp;, <CODE lang="en">PUSH</CODE> i <CODE>POP</CODE>.</P></LI>
 <LI>arytmetyka binarna.<BR>
	<CODE>add do_czego,co</CODE>&nbsp; - dodaj<BR>
	<CODE><span lang="en">sub</span> od_czego,co</CODE> &nbsp;- odejmij<BR>
	<CODE><span lang="en">inc</span> co¶ / dec co¶</CODE> &nbsp;- zwiêksz/zmniejsz co¶ o 1<BR>
	<CODE>cmp co, z_czym</CODE> &nbsp;- porównaj. Wykonuje dzia³anie odejmowania <q>co minus z_czym</q>,
		ale nie zachowuje wyniku, tylko ustawia flagi.<BR>
	<P>Wynikiem mo¿e byæ ustawienie lub wyzerowanie jednej lub wiêcej flag - zaznaczenie
		wyst±pienia jednego z warunków. G³ówne warunki to:</P>
  <UL>
   <LI>A - <span lang="en">above</span> - <q>ponad</q> (dla liczb traktowanych jako liczby bez
   	 znaku): <q>co &gt; z_czym</q>
	<BR><a href="#linux0301" tabindex="1" class="bezdruk">(przeskocz przyk³ad u¿ycia warunku A)</a>
	<PRE title="przyk³ad u¿ycia warunku A">
		cmp al,bl
		ja al_wieksze_od_bl	; ja - &nbsp;jump if above</PRE>
	</LI>
   <LI><a name="linux0301" id="linux0301">B - <span lang="en">below</span> - <q>poni¿ej</q> (bez znaku)</a>: co &lt; z_czym</LI>
   <LI>G - <span lang="en">greater</span> - <q>wiêcej ni¿</q> (ze znakiem): co &gt; z_czym</LI>
   <LI>L - <span lang="en">lower</span> - <q>mniej ni¿</q> (ze znakiem): co &lt; z_czym</LI>
   <LI>O - <span lang="en">overflow</span> - przepe³nienie (ze znakiem, na przyk³ad przebicie 32767 w górê)
   	 ostatniej operacji. Niekoniecznie u¿ywane przy cmp.</LI>
   <LI>C - <span lang="en">carry</span> - przepe³nienie (bez znaku, czyli przebicie na przyk³ad 65535 w górê)
	<BR><a href="#linux0302" class="bezdruk">(przeskocz przyk³ad u¿ycia warunku C)</a>
	<PRE title="przyk³ad warunków">
		add al,bl
		jc blad_przepelnienia	; jc - &nbsp;jump if carry</PRE>
	</LI>
   <LI><a name="linux0302" id="linux0302">E lub Z - <span lang="en">equal</span> (równy) lub zero</a>.
   	 Te dwa warunki s± równowa¿ne.
	<BR><a href="#linux0303" class="bezdruk">(przeskocz przyk³ady u¿ycia warunków równo¶ci)</a>
	<PRE title="inny przyk³ad warunków">
		cmp ax,cx
		je ax_rowne_cx
		...
		sub bx,dx
		jz bx_rowne_dx	</PRE>
	</LI>
   <LI><a name="linux0303" id="linux0303">NE/NZ - przeciwieñstwo poprzedniego</a>: <span lang="en">not equal/not zero</span>.</LI>
   <LI>NA - <span lang="en">not above</span>, czyli <q>nie ponad</q> - mniejsze lub równe (ale dla liczb bez znaku)</LI>
   <LI>NB - <span lang="en">not below</span>, czyli <q>nie poni¿ej</q> - wiêksze lub równe (dla liczb bez znaku)</LI>
   <LI>NG - <span lang="en">not greater</span>, czyli <q>nie wiêcej</q> - mniejsze lub równe (ale dla liczb ze znakiem)</LI>
   <LI>NL - <span lang="en">not lower</span>, czyli <q>nie mniej</q> - wiêksze lub równe (dla liczb ze znakiem)</LI>
   <LI>NC - <span lang="en">no carry</span></LI>
   <LI>AE/BE - <span lang="en">above or equal</span> (<q>ponad lub równe</q>),
   		<span lang="en">below or equal</span> (<q>poni¿ej lub równe</q>)</LI>
   <LI>NO - <span lang="en">no overflow</span></LI>
  </UL><BR><BR></LI>
 <LI>arytmetyka dziesiêtna
  <UL>
   <LI><code>NEG</code> - zmienia znak.</LI>
   <LI><code>MUL</code>, <code>IMUL</code> - mno¿enie, mno¿enie ze znakiem (które uwzglêdnia liczby ujemne)
	<BR><a href="#linux0304" class="bezdruk">(przeskocz przyk³ady instrukcji mno¿enia)</a>
	<PRE title="przyk³ady instrukcji mno¿enia">
		mul cl		; AX = AL*CL
		mul bx		; DX:AX = AX*BX
		mul esi		; EDX:EAX = EAX*ESI
		mul rdi		; RDX:RAX = RAX*RDI

		imul eax	; EDX:EAX = EAX*EAX
		imul ebx,ecx,2	; EBX = ECX*2
		imul ebx,ecx	; EBX = EBX*ECX
		imul si,5	; SI = SI*5	</PRE>
	<P>Zapis <q>rej1 : rej2</q> oznacza, ¿e starsza czê¶æ wyniku znajdzie siê w pierwszym rejestrze
	podanej pary (DX, EDX, RDX), a m³odsza - w drugim (AX, EAX, RAX), gdy¿ wynik mno¿enia dwóch
	liczb o d³ugo¶ci n bitów ka¿da wymaga 2n bitów.
	</P></LI>
   <LI><a name="linux0304" id="linux0304"><code>DIV</code>, <code>IDIV</code> - dzielenie</a>,
	dzielenie ze znakiem (i jednoczesne obliczanie reszty z dzielenia).
	<BR><a href="#linux0305" class="bezdruk">(przeskocz przyk³ady instrukcji dzielenia)</a>
	<PRE title="przyk³ady instrukcji dzielenia">
		div cl	; AL = (AX div CL), AH = (AX mod CL)
		div bx	; AX = (DX:AX div BX),
			; DX = (DX:AX mod BX)
		div edi	; EAX = (EDX:EAX div EDI),
			; EDX = (EDX:EAX mod EDI)
		div rsi	; RAX = (RDX:RAX div RSI),
			; RDX = (RDX:RAX mod RSI)</PRE>
	<P>Zapis <q>rej1 : rej2</q> oznacza, ¿e starsza czê¶æ dzielnej jest oczekiwana w pierwszym
	rejestrze podanej pary (DX, EDX, RDX), a m³odsza - w drugim (AX, EAX, RAX). Je¶li liczba
	mie¶ci siê w rejestrze dla m³odszej czê¶ci, rejestr starszy nale¿y wyzerowaæ. S³owo "div"
	w powy¿szych zapisach oznacza iloraz, a mod - resztê z dzielenia (modulo).
	</P></LI>
  </UL></LI>
 <LI><a name="linux0305" id="linux0305">Instrukcje bitowe (logiczne)</a>.
	<UL>
	 <LI><code><span lang="en">AND</span></code></LI>
	 <LI><code>OR</code></LI>
	 <LI><code>XOR</code></LI>
	 <LI><code>NOT</code></LI>
	 <LI><code>TEST</code></LI>
	</UL>
 	<P>Instrukcja <code>TEST</code> dzia³a tak samo jak <code><span lang="en">AND</span></code> z tym,
	¿e nie zachowuje nigdzie wyniku, tylko ustawia flagi. Pokrótce wyt³umaczê te instrukcje:</P>
	<BR><a href="#linux0306" class="bezdruk">(przeskocz dzia³anie instrukcji logicznych)</a>
	<PRE title="dzia³anie instrukcji bitowych (logicznych)">
		0 AND 0 = 0	0 OR 0 = 0	0 XOR 0 = 0
		0 AND 1 = 0	0 OR 1 = 1	0 XOR 1 = 1
		1 AND 0 = 0	1 OR 0 = 1	1 XOR 0 = 1
		1 AND 1 = 1	1 OR 1 = 1	1 XOR 1 = 0
		NOT 0 = 1
		NOT 1 = 0</PRE>

	<P><a name="linux0306" id="linux0306">Przyk³ady zastosowania</a>:</P>
	<BR><a href="#linux0307" class="bezdruk">(przeskocz przyk³ady instrukcji logicznych)</a>
	<PRE title="przyk³ady u¿ycia instrukcji bitowych">
		and ax,1	; wyzeruje wszystkie bity z
				; wyj±tkiem bitu numer 0.
		or ebx,1111b	; ustawia (w³±cza) 4 dolne bity.
				; Reszta bez zmian.
		xor cx,cx	; CX = 0
		not dh		; DH ma 0 tam, gdzie mia³ 1
				; i na odwrót	</PRE>
	</LI>
 <LI><a name="linux0307" id="linux0307">Instrukcje przesuniêcia bitów.</a>
  <OL>
   <LI><code>SAL</code>, <code>SHL</code> - <span lang="en">shift left</span>.<BR>
	bit7 = bit6, bit6 = bit5, ... , bit1 = bit0, bit0 = 0.<BR><BR></LI>
   <LI><code>SHR</code> - <span lang="en">shift logical right</span><BR>
	bit0 = bit1, bit1 = bit2, ... , bit6 = bit7, bit7 = 0<BR><BR></LI>
   <LI><code>SAR</code> - <span lang="en">shift arithmetic right</span><BR>
	bit0 = bit1, bit1 = bit2, ... , bit6 = bit7, <em class="wazne">bit7 = bit7</em>
		 (bit znaku zachowany!)<BR> Najstarszy bit w rejestrze nazywa siê czasem
		 w³a¶nie bitem znaku.
	<BR><BR></LI>
   <LI><code>ROL</code> - <span lang="en">rotate left</span><BR>
	bit7 = bit6, ... , bit1 = bit0, bit0 = stary bit7<BR><BR></LI>
   <LI><code>RCL</code> - <span lang="en">rotate through carry left</span><BR>
	<span lang="en">carry flag</span> CF = bit7, bit7 = bit6, ... , bit1 = bit0, bit0 = stara CF<BR><BR></LI>
   <LI><code>ROR</code> - <span lang="en">rotate right</span><BR>
	bit0 = bit1, ... , bit6 = bit7, bit7 = stary bit0<BR><BR></LI>
   <LI><code>RCR</code> - <span lang="en">rotate through carry right</span><BR>
	CF = bit0, bit0 = bit1, ... , bit6 = bit7, bit7 = stara CF<BR><BR></LI>
  </OL>
	<P>Przy pomocy <code>SHL</code> mo¿na przeprowadzaæ szybkie mno¿enie, a dziêki <code>SHR</code>
	- szybkie dzielenie. Na przyk³ad, <code>SHL AX,1</code> jest równowa¿ne przemno¿eniu AX przez 2,
	<code>SHL AX,5</code> - przez 2^5, czyli 32. <code>SHR BX,4</code> dzieli BX przez 16.</P></LI>

 <LI>Instrukcje steruj±ce wykonywaniem programu.<BR>
  <UL>
   <LI>Skoki warunkowe (patrz: warunki powy¿ej): <code>JA</code>=<code>JNBE</code>,
	<code>JAE</code>=<code>JNB</code>, <code>JNA</code>=<code>JBE</code>,
	<code>JNAE</code>=<code>JB</code>, <code>JG</code>=<code>JNLE</code>
   	 (<span lang="en">jump if greater</span> - dla liczb
	ze znakiem) = <span lang="en">jump if not lower or equal</span>, <code>JNG</code>=<code>JLE</code>,
	<code>JGE</code>=<code>JNL</code>, <code>JNGE</code>=<code>JL</code>, <code>JO</code>,
	<code>JNO</code>, <code>JC</code>, <code>JNC</code>, <code>JS</code>
	(<span lang="en">jump if sign</span> czyli bit7 wyniku jest równy 1), <code>JNS</code>,
	<code>JP</code>=<code>JPE</code> (<span lang="en">jump if parity equal</span> =
	liczba bitów równych jeden jest parzysta), <code>JNP</code>=<code>JPO</code>.</LI>

   <LI>Skoki bezwarunkowe: <code>JMP</code>, <code>JMP SHORT</code>, <code>JMP FAR</code></LI>
   <LI>Uruchomienia procedur: <code><span lang="en">CALL [NEAR/FAR]</span></code> </LI>
   <LI>Powrót z procedury: <code>RET</code>, <code>RETF</code>.
   <LI>Przerwania: <code>INT</code>, <code>INTO</code> (wywo³uje przerwanie INT4 w razie przepe³nienia),
   	 <code><span lang="en">BOUND</span></code> (int 5)</LI>
   <LI>Instrukcje pêtli: <code><span lang="en">LOOP</span></code>. Sk³adnia:
	<q><code><span lang="en">LOOP</span> gdzie¶</code></q>.
   	 Je¶li CX jest ró¿ny od 0, to skacz <q>gdzie¶</q>.</LI>
  </UL><BR>
 <LI>Operacje na ³añcuchach znaków.
  <OL>
   <LI><code>LODS[B/W/D/Q]</code> - <span lang="en">Load Byte/Word/Dword/Qword</span><BR>
	MOV AL/AX/EAX/RAX , DS:[SI/ESI/RSI]<BR>
	ADD SI,1/2/4/8		; <code>ADD</code>, gdy flaga kierunku DF = 0,
				<code><span lang="en">SUB</span></code> gdy DF = 1<BR><BR></LI>

   <LI><code>STOS[B/W/D/Q]</code> - <span lang="en">Store Byte/Word/Dword/Qword</span><BR>
	MOV ES:[DI/EDI/RDI], AL/AX/EAX/RAX<BR>
	ADD DI,1/2/4/8		; <code>ADD</code>/<code><span lang="en">SUB</span></code> jak wy¿ej<BR><BR></LI>

   <LI><code>MOVS[B/W/D/Q]</code> - <span lang="en">Move Byte/Word/Dword/Qword</span><BR>
	MOV ES:[DI/EDI/RDI], DS:[SI/ESI/RSI]	; to nie jest instrukcja!<BR>
	ADD DI,1/2/4/8		; <code>ADD</code>/<code><span lang="en">SUB</span></code> jak wy¿ej<BR>
	ADD SI,1/2/4/8		<BR><BR></LI>

   <LI><code>CMPS[B/W/D/Q]</code> - <span lang="en">Compare Byte/Word/Dword/Qword</span><BR>
	CMP DS:[SI/ESI/RSI], ES:[DI/EDI/RDI]	; to nie jest instrukcja!<BR>
	ADD SI,1/2/4/8		; <code>ADD</code>/<code><span lang="en">SUB</span></code> jak wy¿ej<BR>
	ADD DI,1/2/4/8		<BR><BR></LI>

   <LI><code>SCAS[B/W/D/Q]</code> - <span lang="en">Scan Byte/Word/Dword/Qword</span><BR>
	skanuje ³añcuch bajtów/s³ów/podwójnych s³ów/poczwórnych s³ów
	pod ES:[DI/EDI/RDI] w poszukiwaniu, czy jest tam
	warto¶æ wskazana przez AL/AX/EAX/RAX.<BR><BR></LI>
  </OL>
   <P>Do ka¿dej z powy¿szych instrukcji mo¿na z przodu dodaæ przedrostek <code>REP</code>
   (<span lang="en">repeat</span>), co spowoduje, ¿e bêdzie ona wykonywana, a¿ CX stanie siê zerem,
   albo <code>REPE/REPZ</code> albo <code>REPNE/REPNZ</code> co spowoduje,
   ¿e bêdzie ona wykonywana, dopóty CX nie jest zerem i jednocze¶nie flaga ZF (flaga zera) bêdzie równa
   odpowiednio 1 lub 0.</P></LI>

 <LI>Instrukcje wej¶cia/wyj¶cia do portów.<BR>
  S± one bardziej szczegó³owo opisane w <a href="linux07.html" hreflang="pl">czê¶ci
   po¶wiêconej portom</a>, ale podam tu skrót:
  <UL>
   <LI><code>IN</code><BR>
	<code>IN AL/AX/EAX, port/DX</code><BR>
	<P>Pobierz z portu 1/2/4 bajty i w³ó¿ do AL/AX/EAX (od najm³odszego). Je¶li numer portu jest
		mniejszy lub równy 255, mo¿na go
		podaæ bezpo¶rednio. Je¶li wiêkszy - trzeba u¿yæ DX.</P>
   <!--
   	<BR><BR>
	IN AL, port/DX.<BR>
	Pobierz z portu bajt i w³ó¿ do AL. Je¶li numer portu jest mniejszy lub równy 255, mo¿na go
		podaæ bezpo¶rednio. Je¶li wiêkszy - trzeba u¿yæ DX.<BR><BR>

	IN AX, port/DX<BR>
	Jest równowa¿ne:<BR>
	IN AL, port/DX<BR>
	IN AH, port+1/DX+1<BR><BR>

	IN EAX, port/DX - pobierz 4 bajty - pierwszy z <q>port</q> do AL, drugi - z <q>port+1</q> do AH,
	 trzeci - z <q>port+2</q> do bitów 23-16 EAX, czwarty - z <q>port+3</q> do bitów 31-24 EAX.
	 -->
	</LI>

   <LI><code>OUT</code><BR>
	<code>OUT port/DX, AL/AX/EAX</code><BR>
	Uwagi jak przy instrukcji <code>IN</code>.</LI>
  </UL><BR><BR></LI>
 <LI>Instrukcje flag<BR>
  <UL>
   <LI><code>STC</code>/<code>CLC</code> - <span lang="en">set carry / clear carry</span>.
	Do flagi CF wstaw 1 lub 0, odpowiednio.<BR><BR></LI>
   <LI><code>STD</code>/<code>CLD</code>. Ustaw DF = 1, DF = 0, odpowiednio.<BR><BR></LI>
   <LI><code>STI</code>/<code>CLI</code>. <span lang="en">Interrupt Flag</span> IF := 1, IF := 0, odpowiednio.
   	 Gdy IF=0, przerwania sprzêtowe s± blokowane.<BR><BR></LI>
   <LI>Przenoszenie flag<BR>
	<code><span lang="en">PUSH</span>F</code> / <code><span lang="en">PUSH</span>FD</code>
	/ <code><span lang="en">PUSH</span>FQ</code>
	- umie¶æ flagi na stosie (16, 32 i 64 bity flag, odpowiednio)<BR>
	<code>POPF</code> / <code>POPFD</code> / <code>POPFQ</code> - zdejmij flagi ze stosu
	(16/32/64 bity flag)<BR>
	<code>SAHF</code> / <code>LAHF</code> - zapisz AH w pierwszych 8 bitach flag / zapisz
	pierwsze 8 bitów flag w AH.<BR>
	<BR><BR></LI>
  </UL></LI>

 <LI>Instrukcja <code>LEA</code> - <span lang="en">Load Effective Address</span>.<BR>
	Wykonanie:
	<PRE title="sk³adnia LEA">		lea	rej, [pamiêæ]</PRE>
	jest równowa¿ne:
	<BR><a href="#linux0308" class="bezdruk">(przeskocz pseudo-kod LEA)</a>
	<PRE title="kod równowazne LEA">
		mov	rej, pamiêæ		; NASM/FASM</PRE>

	<a name="linux0308" id="linux0308">Po co wiêc osobna instrukcja?</a> Otó¿, <code>LEA</code>
	przydaje sie w wielu sytuacjach do obliczania z³o¿onych adresów. Kilka przyk³adów:
	<OL>
	 <LI>Jak w 1 instrukcji sprawiæ, ¿e EAX = EBP-12 ?<BR>
		Odpowied¼: <CODE>lea  eax, [ebp-12]</CODE>
	 </LI>
	 <LI> Niech EBX wskazuje na tablicê o 20 elementach o rozmiarze 8 ka¿dy. Jak do ECX
		zapisaæ adres jedenastego elementu, a do EDX elementu o numerze EDI?<BR>
		Odpowied¼:  <CODE>lea  ecx, [ebx + 11*8]</CODE> oraz <CODE>lea edx,[ebx+edi*8]</CODE>
	  </LI>
	 <LI>Jak w 1 instrukcji sprawiæ, ¿e ESI = EAX*9?<BR>
		Odpowied¼: <CODE>lea esi, [eax + eax*8]</CODE>
	  </LI>
	</OL>
 </LI>
</OL>
<P>Pomin±³em mniej wa¿ne instrukcje operuj±ce na rejestrach segmentowych i klika innych instrukcji.
Te, które tu poda³em, wystarczaj± absolutnie na napisanie wiêkszo¶ci programów, które mo¿na
zrobiæ.<BR><BR>
Wszystkie informacje przedstawione w tej czê¶ci pochodz± z tego samego ¼ród³a:
<A class="intel_link" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" hreflang="en">Intel</A>
i  <A class="amd_link" href="http://developer.amd.com/Resources/documentation/guides/Pages/default.aspx" hreflang="en"><acronym title="Advanced Micro Devices" lang="en">AMD</acronym></A>

</P>
<blockquote>Byle g³upiec potrafi napisaæ kod, który zrozumie komputer. Dobry programista pisze taki kod,
który zrozumie cz³owiek.</blockquote>

<br><br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="linux02.html">Poprzednia czê¶æ kursu</a> (Alt+3)<br>
<a accesskey="4" hreflang="pl" href="linux04.html">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

<BR><BR><HR>
<h2 class="nag">Æwiczenia</h2>
<OL>
 <LI>Zapisz instrukcje: do rejestru AX dodaj 5, od rejestru SI odejmij 178.<BR><BR></LI>
 <LI>Nie u¿ywaj±c cyfry jeden napisz jedn± instrukcjê, która zmniejszy rejestr DX o jeden.<BR><BR></LI>
 <LI>Przemnó¿ warto¶æ rejestru EDI przez 2 na przynajmniej dwa ró¿ne sposoby po jednej instrukcji.
	Postaraj siê nie u¿ywaæ instrukcji (I)MUL.<BR><BR></LI>
 <LI>W jednej instrukcji podziel warto¶æ rejestru BP przez 8.<BR><BR></LI>
 <LI>Nie u¿ywaj±c instrukcji MOV spraw, by DX mia³ warto¶æ 0 (na przynajmniej 3 sposoby, ka¿dy
	po jednej instrukcji).<BR><BR></LI>
 <LI>Nie u¿ywaj±c instrukcji przesuwania bitów SH* ani mno¿enia *MUL przemnó¿ EBX przez 8. Mo¿esz
	u¿yæ wiêcej ni¿ 1 instrukcji.<BR><BR></LI>
 <LI>W dwóch instrukcjach spraw, by EDI równa³ siê 7*ECX. Postaraj siê nie u¿ywaæ instrukcji (I)MUL.</LI>

</OL>

</BODY></HTML>
