<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks: Programy sieciowe </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<link rel="alternate" type="text/html" href="siec_linux_en.html"
	hreflang="en" lang="en" title="English version">

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Pisanie programów sieciowych pod Linuksem">
<META NAME="Keywords" CONTENT="asm, assembler, asembler, linux, liunks, sieæ, net, accept, bind,
	connect, listen, socket, recv, send, RFC">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Tue, Jan 18 2011 17:59:59 CEST">
</HEAD><BODY>

<h1 class="nag">Pisanie programów sieciowych pod Linuksem</h1>

<P>
Linux jest systemem typowo sieciowym. Nawet niektóre us³ugi systemowe dzia³aj± jako serwery sieciowe,
 umo¿liwiaj±c dostêp maszynom z zewn±trz. A ja bez niepotrzebnego zag³êbiania siê w porty,
 protoko³y i inne szczegó³y dotycz±ce sieci, poka¿ê teraz, jak napisaæ prosty,
 w³asny serwerek i klienta do niego.</P>
<P>
Komunikacja w sieci odbywa siê z wykorzystaniem wielu ró¿nych elementów. Podstawowym pojêciem jest
 gniazdo (ang. <span lang="en">socket</span>). Jest to logiczne (czyli nie istniej±ce fizyczne)
 urz±dzenie bêd±ce podstawow± bramk±, przez któr± przep³ywaj± informacje.
 Gniazdko tworzy siê funkcj± <span lang="en" class="b">socket</span> (z biblioteki jêzyka C,
 tak jak wszystkie pó¼niejsze). Przyjmuje ona 3 argumenty (patrz: man 2 <span lang="en">socket</span>):</P>
<OL>
 <LI>domena - okre¶la typ po³±czenia. My wykorzystamy warto¶æ PF_INET=2, oznaczaj±c±
 	protoko³y internetowe (<acronym lang="en" title="Internet Protocol">IP</acronym>v4)</LI>
 <LI>typ gniazda - okre¶la, czy gniazdo jest datagramowe, strumieniowe,
 	surowe (<span lang="en">raw</span>) itp. My wykorzystamy gniazdo strumieniowe
 	SOCK_STREAM=1 i protokó³ <span lang="en">TCP</span> (<span lang="en">Transmission Control Protocol</span>),
 	który gwarantuje wiarygodne, dwustronne po³±czenie.</LI>
 <LI>protokó³, je¶li nie jest on jednoznacznie wyznaczony. U nas <span lang="en">TCP</span>
 	jest jednoznacznie wyznaczony przez typ gniazda (strumieniowe),
 	wiêc ten argument przyjmuje warto¶æ 0.</LI>
</OL>
<P>Je¶li utworzenie gniazda nie uda³o siê, funkcja <span lang="en">socket</span> zwróci warto¶æ -1.
 Je¶li siê uda³o, zwróci liczbê ca³kowit± - deskryptor otwartego gniazda
 (podobnie, jak w plikach). Po zakoñczeniu pracy gniazdo mo¿na zamkn±æ
 funkcj± <span class="b">close</span>.</P>
<P>
Od chwili utworzenia gniazda dalszy kod w serwera i klienta ró¿ni± siê, wiêc omówiê je po kolei.</P>






<HR>
<h2 class="nag">Serwer</h2>
	<BR><a href="#klient" class="bezdruk" tabindex="1">(przeskocz opis serwera)</a>

<P>
Jak wiemy, zadaniem serwera jest nas³uchiwanie po³±czeñ od klientów. Aby to osi±gn±æ, nale¿y wykonaæ
 nastêpuj±ce kroki.</P>

<OL>

 <LI>Przypisanie gniazda do adresu.
  <P>W chwili utworzenia, gniazdo nie jest jeszcze przypisane do adresu, a przecie¿ trzeba jako¶ okre¶liæ,
  na jakim adresie i porcie nas³uchuje nasz serwer. S³u¿y do tego funkcja
  <span class="b">bind</span>. Przyjmuje ona nastêpuj±ce argumenty (patrz: man 2 bind):</P>
  <OL>
   <LI>gniazdo, które utworzyli¶my funkcj± <span lang="en">socket</span></LI>
   <LI>adres struktury <span class="b">sockaddr</span>, któr± zaraz siê zajmiemy</LI>
   <LI>d³ugo¶æ tej¿e struktury</LI>
  </OL>
  <P>Choæ definicja funkcji bind mówi o strukturze sockaddr, to funkcji tej
  podaje siê odpowiednio rzutowany wska¼nik do
  struktury <span class="b">sockaddr_in</span>. Ta struktura wygl±da tak:</P>
	<BR><a href="#siec_linux01" class="bezdruk">(przeskocz strukturê sockaddr_in)</a>
  <PRE>
	  struc sockaddr_in
		.sin_family resw 1	; rodzina adresów
		.sin_port   resw 1	; numer portu
		.sin_addr   resd 1	; adres
		            resb 8	; dope³nienie do 16 bajtów
	  endstruc</PRE>
  <P><a name="siec_linux01" id="siec_linux01">Do pola sin_family wpisujemy</a> AF_INET=2,
   oznaczaj±ce rodzinê adresów internetowych.</P>
  <P>Do pola sin_port wpisujemy numer portu, na którym bêdzie nas³uchiwa³ nasz serwer.
   Ale uwaga - nie bezpo¶rednio! Najpierw numer portu musi zostaæ przet³umaczony na
    sieciowy porz±dek bajtów funkcj± <span class="b">htons</span> (patrz: man htons).
   Dopiero wynik funkcji, której podajemy numer portu, wpisujemy w to pole.
    Programy bez uprawnieñ administratora mog± korzystaæ tylko z portów o numerach powy¿ej 1023.</P>
  <P>Do pola sin_addr wpisujemy warto¶æ INADDR_ANY=0, co oznacza, ¿e chcemy nas³uchiwaæ
   na dowolnym adresie.</P>
  <P>W przypadku b³êdu, bind zwraca -1.
 </P></LI>

 <LI>W³±czenie nas³uchiwania na danym gnie¼dzie.
  <P>Aby w³±czyæ nas³uchiwanie na danym gnie¼dzie, nale¿y u¿yæ funkcji <span class="b" lang="en">listen</span>.
   Przyjmuje ona dwa argumenty (patrz: man 2 listen):</P>
  <OL>
   <LI>gniazdo, utworzone funkcj± <span lang="en">socket</span> z adresem przypisanym funkcj± bind</LI>
   <LI>maksymaln± liczbê klientów oczekuj±cych w kolejce na obs³ugê</LI>
  </OL>
  <P>W przypadku b³êdu, <span lang="en">listen</span> zwraca -1.</P>
  <P>Je¶li funkcja <span lang="en">listen</span> siê powiedzie, to mo¿na z
   serwerem przej¶æ w tryb demona (o tym w <a href="tsr_tut_linux.html" hreflang="pl">kursie
	o pisaniu programów rezydentnych</a>).</P>
 </LI>
</OL>

<P>Po w³±czeniu nas³uchiwania na gnie¼dzie mo¿emy zacz±æ przyjmowaæ po³±czenia od klientów.
 Przyjêcie po³±czenia odbywa siê funkcj± <span class="b" lang="en">accept</span>.
 Przyjmuje ona trzy argumenty (patrz: man 2 <span lang="en">accept</span>):</P>
 <OL>
  <LI>nas³uchuj±ce gniazdo</LI>
  <LI>zero lub adres struktury sockaddr (lub tej samej sockaddr_in, któr± podali¶my
  	dla bind). Struktura ta	otrzyma dane o kliencie (na przyk³ad jego adres)</LI>
  <LI>adres zmiennej zawieraj±cej d³ugo¶æ struktury z parametru numer 2</LI>
 </OL>
 <P>Gdy klient ju¿ siê po³±czy³, <span lang="en">accept</span> zwraca deskryptor
  nowego gniazda, które bêdzie s³u¿yæ do komunikacji z klientem.</P>








<BR><HR>
<h2 class="nag"><a name="klient" id="klient">Klient</a></h2>
	<BR><a href="#rozmowa" class="bezdruk">(przeskocz opis klienta)</a>

<P>
W porównaniu z serwerem, w kliencie jest mniej pracy. Po utworzeniu gniazda do
 po³±czenia siê z serwerem wystarczy jedna funkcja - <span class="b" lang="en">connect</span>.
  Przyjmuje ona trzy argumenty (patrz: man 2 <span lang="en">connect</span>):</P>
 <OL>
  <LI>gniazdo utworzone funkcj± <span lang="en">socket</span></LI>
  <LI>adres struktury sockaddr</LI>
  <LI>d³ugo¶æ tej¿e struktury</LI>
 </OL>
 <P>Tutaj tak¿e zamiast struktury sockaddr przekazujemy adres struktury sockaddr_in.
  Jednak trzeba j± trochê inaczej wype³niæ.</P>
 <P>Pola sin_family i sin_port wype³niamy tak samo, jak dla bind. W koñcu chcemy siê
  po³±czyæ do tego samego portu, na którym nas³uchuje serwer.</P>
 <P>Pole sin_addr wype³niamy adresem IP serwera. Oczywi¶cie nie wprost jako ³añcuch znaków,
  ale odpowiednio przerobionym. Do przerobienia ³añcucha znaków 127.0.0.1
  (oznaczaj±cego zawsze bie¿±cy komputer dla niego samego) na w³a¶ciw± postaæ
  pos³u¿y nam funkcja <span class="b">inet_aton</span>. Przyjmuje ona 2 argumenty (patrz: man inet_aton):</P>
  <OL>
   <LI>adres ³añcucha znaków z adresem w zapisie dziesiêtnym kropkowym (ttt.xxx.yyy.zzz)</LI>
   <LI>adres struktury in_addr, która otrzyma wynik</LI>
  </OL>
  <P>Struktura in_addr jest jedyn± sk³adow± pola sin_addr w naszej strukturze
   sockaddr_in i to adres tego w³a¶nie pola podajemy funkcji inet_aton.</P>
<P>
Po poprawnym wykonaniu po³±czenia funkcj± <span lang="en">connect</span>,
 mo¿na przyst±piæ do wymiany danych.</P>








<BR><HR>
<h2 class="nag"><a name="rozmowa" id="rozmowa">Wymiana danych</a></h2>
	<BR><a href="#przyklad" class="bezdruk">(przeskocz wymianê danych)</a>

<P>
Po dokonaniu po³±czenia obie strony - klient i serwer - maj± gotowe gniazda,
 którymi mog± siê komunikowaæ. Do wymiany danych s³u¿± dwie podstawowe funkcje:
 <span class="b">send</span> i <span class="b">recv</span>. Obie przyjmuj± dok³adnie te same cztery
 parametry (patrz: man 2 send, man 2 recv):</P>
 <OL>
  <LI>gniazdo, które jest po³±czone z klientem/serwerem</LI>
  <LI>adres bufora odbiorczego/nadawczego</LI>
  <LI>d³ugo¶æ tego bufora</LI>
  <LI>specjalne flagi, je¶li jest taka potrzeba. U nas bêdzie to zero.</LI>
 </OL>







<BR><HR>
<h2 class="nag"><a name="przyklad" id="przyklad">Przyk³ad</a></h2>

<P>
Po przebrniêciu przez t³ trudn± teoriê mo¿emy wreszcie przyst±piæ do pisania programów.
 Wiem, ¿e sucha teoria nie umo¿liwi natychmiastowego napisania programów serwera
 i klienta (jest wiele pu³apek, na które trzeba zwróciæ uwagê),
 dlatego prezentujê tutaj przyk³adowe programy serwera i klienta (sk³adnia NASMa).</P>
<P>Serwer:</P>
	<BR><a href="#siec_linux02" class="bezdruk">(przeskocz program serwera)</a>
<PRE>
; Program serwera
;
; autor: Bogdan D., bogdandr (at) op.pl
;
; kompilacja:
; nasm -O999 -f elf -o serwer.o serwer.asm
; gcc -o serwer serwer.o

section	.text
global	main		; bêdziemy korzystaæ z biblioteki C, wiêc
			; funkcja g³ówna musi siê nazywaæ &quot;main&quot;

; definicje kilku przydatnych sta³ych
%define PF_INET		2
%define AF_INET		PF_INET
%define SOCK_STREAM	1
%define INADDR_ANY	0

%define	NPORTU		4242
%define	MAXKLIENT	5	; maksymalna liczba klientów

; zewnêtrzne funkcje z biblioteki C, z których bêdziemy korzystaæ
extern	daemon
extern	socket
extern	listen
extern	accept
extern	bind
extern	htons
extern	recv
extern	send
extern	close

main:
	push	dword 0
	push	dword SOCK_STREAM
	push	dword AF_INET
	call	socket			; tworzymy gniazdo:
					;socket(AF_INET,SOCK_STREAM,0);
	add	esp, 12			; usuwamy argumenty ze stosu

	cmp	eax, 0			; EAX &lt; 0 oznacza b³±d
	jl	.sock_blad

	mov	[gniazdo], eax		; zachowujemy deskryptor gniazda

	push	word NPORTU
	call	htons			; przerabiamy numer portu na
					; w³a¶ciwy format
					; htons(NPORTU);
	add	esp, 2

			; wpisujemy przerobiony numer portu:
	mov	[adres+sockaddr_in.sin_port], ax
			; rodzina adresów internetowych:
	mov	word [adres+sockaddr_in.sin_family], AF_INET
			; akceptujemy ka¿dy adres
	mov	dword [adres+sockaddr_in.sin_addr], INADDR_ANY

	push	dword sockaddr_in_size
	push	dword adres
	push	dword [gniazdo]
	call	bind			; przypisujemy gniazdo do adresu:
				; bind(gniazdo,&amp;adres,sizeof(adres));
	add	esp, 12

	cmp	eax, 0
	jl	.bind_blad

	push	dword MAXKLIENT
	push	dword [gniazdo]
	call	listen			; w³±czamy nas³uchiwanie:
					; listen(gniazdo,MAXKLIENT);
	add	esp, 8

	cmp	eax, 0
	jl	.list_blad

	push	dword 1
	push	dword 1
	call	daemon			; przechodzimy w tryb demona
	add	esp, 8			; usuniecie argumentów ze stosu

	mov	dword [rozmiar], sockaddr_in_size

.czekaj:
	push	dword rozmiar		; [rozmiar] zawiera rozmiar
					; struktury sockaddr_in
	push	dword adres
	push	dword [gniazdo]
	call	accept			; czekamy na po³±czenie
				; accept(gniazdo,&amp;adres,&amp;rozmiar)
	add	esp, 12
	cmp	eax, 0
	jl	.czekaj

	mov	[gniazdo_kli], eax	; gdy accept siê uda³o,
					; zwraca nowe gniazdo klienta

.rozmowa:
	push	dword 0
	push	dword buf_d
	push	dword bufor
	push	dword [gniazdo_kli]
	call	recv			; odbieramy dane;
			; recv(gniazdo_kli,&amp;bufor,sizeof(bufor),0);
	add	esp, 16

	cmp	eax, 0			; je¶li b³±d, to czekamy ponownie
	jl	.rozmowa

	cmp	byte [bufor], &quot;Q&quot;	; ustalamy, ¿e Q koñczy transmisjê
	je	.koniec

	mov	ecx, buf_d
	mov	edi, bufor
	xor	eax, eax
	cld
	rep	stosb			; czy¶cimy bufor

	push	dword 0
	push	dword 2
	push	dword ok
	push	dword [gniazdo_kli]
	call	send			; wysy³amy dane
					; (na cokolwiek odpowiadamy &quot;OK&quot;)
					; send(gniazdo_kli,&amp;ok,2,0);
	add	esp, 16

	jmp	.rozmowa		; i czekamy od nowa

.koniec:
	push	dword 0
	push	dword buf_d
	push	dword bufor
	push	dword [gniazdo_kli]
	call	send			; wysy³amy Q, które jest w buforze
	add	esp, 16

	push	dword [gniazdo_kli]
	call	close			; zamykamy gniazdo klienta
	add	esp, 4

; je¶li chcemy, aby serwer nas³uchiwa³ kolejnych po³±czeñ, piszemy tu:
;;; 	jmp	.czekaj
; serwera nie da siê wtedy inaczej zamkn±æ ni¿ przez zabicie procesu

	push	dword [gniazdo]
	call	close			; zamykamy gniazdo g³ówne serwera
	add	esp, 4

	mov	eax, 1
	xor	ebx, ebx
	int	80h			; wychodzimy z programu


; obs³uga b³êdów:

.sock_blad:
	mov	eax, 4
	mov	ebx, 1
	mov	ecx, blad_socket
	mov	edx, blad_socket_d
	int	80h			; wy¶wietlenie napisu

	mov	eax, 1
	mov	ebx, 1
	int	80h			; wyj¶cie z programu z
					; odpowiednim kodem b³êdu

.bind_blad:
	mov	eax, 4
	mov	ebx, 1
	mov	ecx, blad_bind
	mov	edx, blad_bind_d
	int	80h

	push	dword [gniazdo]
	call	close			; zamykamy gniazdo

	mov	eax, 1
	mov	ebx, 2
	int	80h

.list_blad:
	mov	eax, 4
	mov	ebx, 1
	mov	ecx, blad_listen
	mov	edx, blad_listen_d
	int	80h

	push	dword [gniazdo]
	call	close			; zamykamy gniazdo

	mov	eax, 1
	mov	ebx, 3
	int	80h


section .data

					; deskryptory gniazd:
gniazdo		dd	0
gniazdo_kli	dd	0

bufor		times	20	db	0	; bufor odbiorczo-nadawczy
buf_d		equ	$ - bufor		; d³ugo¶æ bufora

						; komunikaty b³êdów:
blad_socket	db	&quot;Problem z socket!&quot;, 10
blad_socket_d	equ	$ - blad_socket

blad_bind	db	&quot;Problem z bind!&quot;, 10
blad_bind_d	equ	$ - blad_bind

blad_listen	db	&quot;Problem z listen!&quot;, 10
blad_listen_d	equ	$ - blad_listen

ok		db	&quot;OK&quot;		; to, co wysy³amy

struc sockaddr_in

	.sin_family	resw	1		; rodzina adresów
	.sin_port	resw	1		; numer portu
	.sin_addr	resd	1		; adres

			resb	8		; dope³nienie do 16 bajtów
endstruc

adres		istruc	sockaddr_in		; adres jako zmienna, która
						; jest struktur±
rozmiar		dd	sockaddr_in_size	; rozmiar struktury</PRE>

<P><a name="siec_linux02" id="siec_linux02">Klient</a>:</P>
	<BR><a href="#siec_linux03" class="bezdruk">(przeskocz program klienta)</a>
<PRE>
; Program klienta
;
; autor: Bogdan D., bogdandr (at) op.pl
;
; kompilacja:
; nasm -O999 -f elf -o klient.o klient.asm
; gcc -o klient klient.o

section	.text
global	main		; bêdziemy korzystaæ z biblioteki C, wiêc
			; funkcja g³ówna musi siê nazywaæ &quot;main&quot;

; definicje kilku przydatnych sta³ych
%define PF_INET		2
%define AF_INET		PF_INET
%define SOCK_STREAM	1
%define INADDR_ANY	0

%define	NPORTU		4242

; zewnêtrzne funkcje z biblioteki C, z których bêdziemy korzystaæ
extern	socket
extern	connect
extern	htons
extern	recv
extern	send
extern	close
extern	inet_aton

main:
	push	dword 0
	push	dword SOCK_STREAM
	push	dword AF_INET
	call	socket			; tworzymy gniazdo:
					; socket(AF_INET,SOCK_STREAM,0);
	add	esp, 12			; usuwamy argumenty ze stosu

	cmp	eax, 0			; EAX &lt; 0 oznacza b³±d
	jle	.sock_blad

	mov	[gniazdo], eax		; zachowujemy deskryptor gniazda

					; rodzina adresów internetowych:
	mov	word [adres+sockaddr_in.sin_family], AF_INET

	push	dword (adres + sockaddr_in.sin_addr)
	push	dword localhost
	call	inet_aton		; przerabiamy adres 127.0.0.1 na
					; w³a¶ciwy format
	add	esp, 8
	test	eax, eax		; EAX = 0 oznacza, ¿e adres
					; by³ nieprawid³owy
	jz	.inet_blad

	push	word NPORTU
	call	htons			; przerabiamy numer portu
					; na w³a¶ciwy format
	add	esp, 2
				; wpisujemy przerobiony numer portu:
	mov	word [adres+sockaddr_in.sin_port], ax

	push	dword sockaddr_in_size
	push	dword adres
	push	dword [gniazdo]
	call	connect			; ³±czymy siê z serwerem:
				; connect(gniazdo,&amp;adres,sizeof(adres));
	add	esp, 12

	cmp	eax, 0
	jne	.conn_blad

.rozmowa:
	mov	eax, 3
	mov	ebx, 0
	mov	ecx, bufor
	mov	edx, buf_d
	int	80h			; wczytujemy dane ze
					; standardowego wej¶cia

	push	dword 0
	push	dword buf_d
	push	dword bufor
	push	dword [gniazdo]
	call	send			; wysy³amy to, co wczytali¶my:
				; send(gniazdo,&amp;bufor,sizeof(bufor),0);
	add	esp, 16

	cmp	eax, 0
	jl	.send_blad

	mov	ecx, buf_d
	mov	edi, bufor
	xor	eax, eax
	cld
	rep	stosb			; czy¶cimy bufor

.odbieraj:
	push	dword 0
	push	dword buf_d
	push	dword bufor
	push	dword [gniazdo]
	call	recv			; odbieramy dane od serwera:
				; recv(gniazdo,&amp;bufor,sizeof(bufor),0);
	add	esp, 16

	cmp	eax, 0
	jl	.odbieraj

	mov	eax, 4
	mov	ebx, 1
	mov	ecx, odebrano
	mov	edx, odebrano_dl
	int	80h			; wypisujemy, co odebrali¶my

	cmp	byte [bufor], &quot;Q&quot;		; &quot;Q&quot; koñczy transmisjê
	jne	.rozmowa

	push	dword [gniazdo]
	call	close			; zamykamy gniazdo
	add	esp, 4

	mov	eax, 1
	xor	ebx, ebx
	int	80h			; wychodzimy z programu


; sekcja obs³ugi b³êdów


.sock_blad:
	mov	eax, 4
	mov	ebx, 1
	mov	ecx, blad_socket
	mov	edx, blad_socket_d
	int	80h			; wy¶wietlenie napisu

	mov	eax, 1
	mov	ebx, 1
	int	80h			; wyj¶cie z programu z
					; odpowiednim kodem b³êdu

.conn_blad:
	mov	eax, 4
	mov	ebx, 1
	mov	ecx, blad_connect
	mov	edx, blad_connect_d
	int	80h

	push	dword [gniazdo]
	call	close			; zamykamy gniazdo

	mov	eax, 1
	mov	ebx, 2
	int	80h

.inet_blad:
	mov	eax, 4
	mov	ebx, 1
	mov	ecx, blad_inet
	mov	edx, blad_inet_d
	int	80h

	push	dword [gniazdo]
	call	close			; zamykamy gniazdo

	mov	eax, 1
	mov	ebx, 3
	int	80h

.send_blad:
	mov	eax, 4
	mov	ebx, 1
	mov	ecx, blad_send
	mov	edx, blad_send_d
	int	80h

	push	dword [gniazdo]
	call	close			; zamykamy gniazdo

	mov	eax, 1
	mov	ebx, 4
	int	80h

.recv_blad:
	mov	eax, 4
	mov	ebx, 1
	mov	ecx, blad_recv
	mov	edx, blad_recv_d
	int	80h

	push	dword [gniazdo]
	call	close			; zamykamy gniazdo

	mov	eax, 1
	mov	ebx, 5
	int	80h

section .data

gniazdo		dd	0			; deskryptor gniazda

odebrano	db	&quot;Serwer: &quot;
bufor		times	20	db	0	; bufor nadawczo-odbiorczy
buf_d		equ	$ - bufor		; d³ugo¶æ bufora
		db	10			; przej¶cie do nowej linii
odebrano_dl	equ	$ - odebrano

						; komunikaty b³êdów
blad_socket	db	&quot;Problem z socket!&quot;, 10
blad_socket_d	equ	$ - blad_socket

blad_connect	db	&quot;Problem z connect!&quot;, 10
blad_connect_d	equ	$ - blad_connect

blad_inet	db	&quot;Problem z inet_aton!&quot;, 10
blad_inet_d	equ	$ - blad_inet

blad_send	db	&quot;Problem z send!&quot;, 10
blad_send_d	equ	$ - blad_send

blad_recv	db	&quot;Problem z recv!&quot;, 10
blad_recv_d	equ	$ - blad_recv


localhost	db	&quot;127.0.0.1&quot;, 0		; adres, z którym
						; bêdziemy siê ³±czyæ

struc sockaddr_in

	.sin_family	resw	1		; rodzina adresów
	.sin_port	resw	1		; numer portu
	.sin_addr	resd	1		; adres

			resb	8		; dope³nienie do 16 bajtów
endstruc

adres		istruc	sockaddr_in		; adres jako zmienna,
						; która jest struktur±</PRE>
<P>
<a name="siec_linux03" id="siec_linux03">Jako ¿e programy te korzystaj±</a> z biblioteki jêzyka C,
 ich kompilacja musi wygl±daæ trochê inaczej ni¿ zwykle:</P>
<PRE>
	nasm -f elf -o plik.o plik.asm
	gcc -o plik plik.o</PRE>
<P>Po kompilacji najpierw oczywi¶cie uruchamiamy serwer poleceniem
 <CODE>./serwer</CODE> (program serwera sam przejdzie w t³o). Mo¿ecie sprawdziæ,
 co siê stanie, je¶li dwa razy spróbujecie uruchomiæ serwer lub uruchomicie klienta
bez uruchomionego serwera.</P>
<P>Oczywi¶cie, serwer mo¿e te¿ byæ klientem innego serwera (na przyk³ad po odebraniu danych
 przerabiaæ je i przekazywaæ dalej).</P>





<BR><HR>
<h2 class="nag"><a name="siec_int80h" id="siec_int80h">Funkcje sieciowe przerwania int 80h</a></h2>
	<BR><a href="#siec_x64" class="bezdruk">(przeskocz int 80h)</a>

<P>
Korzystanie z sieci jest oczywi¶cie mo¿liwe tak¿e bez po¶rednictwa biblioteki jêzyka C. W koñcu
 ka¿da tak istotna funkcja przecie¿ musi byæ zaprogramowana jako czê¶æ j±dra.</P>
<P>Interfejs sieciowy j±dra to jedna funkcja - sys_socketcall (numer 102). Przyjmuje ona dwa
 argumenty. Pierwszy (w EBX) to funkcja, któr± chcemy uruchomiæ. Ka¿da wspomniana wcze¶niej
 funkcja z biblioteki C ma swój numer. S± to: dla <span lang="en">socket</span> - 1, dla bind - 2,
 <span lang="en">connect</span> - 3, <span lang="en">listen</span> - 4,
 <span lang="en">accept</span> - 5, send - 9, recv - 10. Funkcja <span lang="en">close</span>
 jest t± sam±, której u¿ywa siê do zamykania plików (a wiêc EBX=[gniazdo], EAX=6, int 80h).</P>
<P>
Drugim argumentem (w ECX) jest adres reszty argumentów, które podaliby¶my funkcji z biblioteki C.
 Mo¿na je bez przeszkód w tej samej kolejno¶ci, co wcze¶niej, umie¶ciæ na stosie, po czym wykonaæ
 instrukcjê <code>mov ecx, esp</code>. Z reszt±, tak to w³a¶nie robi biblioteka C
 (plik sysdeps/unix/sysv/linux/i386/socket.S w ¼ród³ach glibc, tam jednak jest "ecx+4", gdy¿
 nale¿y przeskoczyæ jeszcze adres powrotny z funkcji). Mo¿na te dane
 umie¶ciæ oczywi¶cie w swojej sekcji danych i podaæ ich adres, ale dane te musz± byæ jedna po
 drugiej dok³adnie w takiej kolejno¶ci, w jakiej znajdowa³yby na stosie (czyli
 <em class="wazne">od lewej do prawej</em> na wzrastaj±cych adresach). Po prostu po kolei,
 wed³ug deklaracji C, od lewej do prawej.</P>
<P>
Do omówienia zostaj± jeszcze funkcje pomocnicze - htons i inet_aton.</P>
<P>
Funkcja <span class="b">htons</span> jest do¶æ prosta w budowie (plik sysdeps/i386/htons.S
 w ¼ród³ach glibc), jej tre¶æ mie¶ci siê w takim oto makrze (zak³adaj±c, ¿e argument jest w EAX):</P>
<pre title="makro htons">
	%macro htons 0
		and	eax, 0FFFFh
		ror	ax, 8
	%endm</pre>

<P>Czyli po prostu zeruje górn± po³owê EAX i zamienia zawarto¶æ rejestrów AH i AL miêdzy sob±.</P>

<P>Funkcja <span class="b">inet_aton</span> (plik resolv/inet_addr.c w ¼ród³ach glibc) jest
 trochê trudniejsza. Wolê znacznie wszystko skróciæ i powiedzieæ, ¿e adres nale¿y
 za³adowaæ do rejestru EAX <span class="b">binarnie</span>, czyli na przyk³ad z 127.0.0.1
 dostajemy EAX=7F000001h, a z 192.168.0.2 - EAX=C0A80002h. Potem trzeba odwróciæ kolejno¶æ bajtów.
 Najlepiej od pocz±tku skorzystaæ z nastêpuj±cego makra:</P>
<pre title="makro adr2bin">
	%macro adr2bin 4

		mov	al, %4
		shl	eax, 8
		mov	al, %3
		shl	eax, 8
		mov	al, %2
		shl	eax, 8
		mov	al, %1
	%endm

	; u¿ycie:
		adr2bin	127, 0, 0, 1	   ; dla adresu 127.0.0.1
		adr2bin	192, 168, 45, 243  ; dla adresu 192.168.45.243</pre>

<P>którego wynik (EAX) zapisujemy do pierwszych czterech bajtów pola sin_addr struktury
 sockaddr_in (co normalnie funkcja inet_aton robi³a automatycznie).</P>
<P>
To ca³e odwracanie bierze siê z tego, ¿e porz±dek bajtów w protokole TCP jest typu big-endian,
 a procesory zgodne z Intelem s± typu little-endian.</P>
<P>O tym, jak pisaæ demony korzystaj±c wy³±cznie z przerwania int 80h, napisa³em w
<a href="tsr_tut_linux.html" hreflang="pl">kursie o pisaniu programów rezydentnych</a>.</P>






<BR><HR>
<h2 class="nag"><a name="siec_x64" id="siec_x64">Funkcje sieciowe w systemie 64-bitowym</a></h2>
	<BR><a href="#koniec" class="bezdruk">(przeskocz system 64-bitowy)</a>

<P>
Obs³uga sieci ró¿ni siê nieco na systemach 64-bitowych w porównaniu z systemami 32-bitowymi.
Nie tylko zmienia siê numer funkcji, ale teraz poszczególne operacje sieciowe maj± swoje
w³asne funkcje systemowe. S± to: <span lang="en">socket</span> - 41, <span lang="en">connect</span> - 42,
<span lang="en">accept</span> - 43, <span lang="en">sendto</span> - 44,
<span lang="en">recvfrom</span> - 45, <span lang="en">bind</span> - 49,
<span lang="en">listen</span> - 50.
Reszta parametrów jest przekazywana nie na stosie, a
w kolejnych rejestrach, zgodnie z interfejsem systemu 64-bitowego (kolejno w rejestrach:
RDI, RSI, RDX, R10, R8, R9). Samo wywo³anie systemu nastêpuje instrukcj±
<span class="b" lang="en">syscall</span>,
a nie poprzez przerwanie 80h.</P>
<P>
Przyk³adowe wywo³ania funkcji wygl±daj± wiêc nastêpuj±co:</P>
<pre>
	mov	rax, 41			; socket
	mov	rdi, AF_INET
	mov	rsi, SOCK_STREAM
	mov	rdx, IPPROTO_TCP
	syscall

	mov	rax, 42			; connect
	mov	rdi, [socket]
	mov	rsi, sock_struc
	mov	rdx, sockaddr_in_size
	syscall

	mov	rax, 44			; sendto
	mov	rdi, [socket]
	mov	rsi, buf
	mov	rdx, buf_ile
	mov	r10, 0
	syscall

	mov	rax, 49			; bind
	mov	rdi, [socket]
	mov	rsi, sock_struc
	mov	rdx, sockaddr_in_size
	syscall

	mov	rax, 50			; listen
	mov	rdi, [socket]
	mov	rsi, MAXKLIENT
	syscall

	mov	rax, 43			; accept
	mov	rdi, [socket]
	mov	rsi, sock_struc
	mov	rdx, sockaddr_in_size
	syscall

	mov	rax, 45			; recvfrom
	mov	rdi, [socket_client]
	mov	rsi, buf
	mov	rdx, buf_ile
	mov	r10, 0
	syscall

	...
struc sockaddr_in
	.sin_family:	resw 1
	.sin_port:	resw 1
	.sin_addr:	resd 1
			resb 8
endstruc

sock_struc istruc sockaddr_in</pre>

<P>Funkcje htons i inet_aton s± takie same, jak dla systemów 32-bitowych (bo przecie¿ kolejno¶æ
bajtów przesy³anych w sieci siê nie zmienia).</P>

<br>
<HR>



<P><a name="koniec" id="koniec">Warto jeszcze wspomnieæ o dwóch sprawach</a>.
 Pierwsza to programy strace i ltrace. Pozwalaj± one na ¶ledzenie, których funkcji
 systemowych i kiedy dany program u¿ywa. Je¶li co¶ Wam nie dzia³a, wy³±czcie tryb
 demona w serwerze, po czym uruchomcie
 <code>strace ./serwer</code> i patrzcie, na których wywo³aniach funkcji s± jakie¶ problemy.
 Podobnie mo¿ecie oczywi¶cie zrobiæ
 z klientem, na przyk³ad na drugim terminalu. Po szczegó³y odsy³am do stron manuala.</P>
<P>
Drug± sprawa jest dla tych z Was, którzy powa¿nie my¶l± o pisaniu aplikacji sieciowych.
 Jest to zbiór norm RFC (<span lang="en">Request For Comment</span>). Opisuj± one wszystkie publicznie
 u¿ywane protoko³y, na przyk³ad <acronym lang="en" title="HyperText Transfer Protocol">HTTP</acronym>,
 <acronym lang="en" title="Simple Mail Transfer Protocol">SMTP</acronym> czy
 <acronym lang="en" title="Post Office Protocol">POP</acronym>3:
 <A HREF="http://www.rfc-editor.org/" hreflang="en">rfc-editor.org</A>.</P>

<br>
<div class="bezdruk">
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

</BODY></HTML>
