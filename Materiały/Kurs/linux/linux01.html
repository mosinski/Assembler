<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks, czê¶æ 1 - Podstawy </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Prev"     hreflang="pl" lang="en" href="bsd.html" >
<link rel="Next"     hreflang="pl" lang="en" href="linux02.html" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="kurs, asm, asembler, assembler, rejestry, program, kompilatory,
	system dwójkowy, system szesnastkowy, bit, bajt, binarny, hex, org, nasm, fasm, linux, linuks">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="Kwrite">
<meta http-equiv="Last-Modified" content="Mon, Oct 29 2012 17:22:19 CEST">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler pod Linuksem?<BR>
	<h1 class="nag">Czê¶æ 1 - Podstawy, czyli czym to siê je</h1></div>

<P>
Wyobra¼cie sobie, jakby to by³o móc programowaæ maszynê bezpo¶rednio - <q>rozmawiaæ</q> z
procesorem bez po¶rednictwa struktur wysokiego poziomu, na przyk³ad takich jak spotykamy w jêzyku C.
Bezpo¶rednie operowanie na procesorze umo¿liwia przecie¿ pe³n± kontrolê jego dzia³añ! Bez
zbêdnych instrukcji i innych <q>¶mieci</q> spowalniaj±cych nasze programy.</P>
<P>
Czy ju¿ czujecie chêæ pisania najkrótszych i najszybszych programów na ¶wiecie?<BR>
Programów, których czasem w ogóle NIE MO¯NA napisaæ w innych jêzykach? Brzmi wspaniale, prawda?</P>
<P>
Tylko pomy¶lcie o tym, co powiedzieliby znajomi, gdyby¶cie siê im pochwalili. Widzicie ju¿ te
ich zdumione miny?</P>
<P>
Mi³a perspektywa, prawda? No, ale do¶æ ju¿ gadania. Zabierajmy siê do rzeczy!</P>

<P>Zacznijmy od krótkiego wprowadzenia:
</P>
<HR>
 <h2 class="nag">Niedziesiêtne systemy liczenia.</h2>
 <BR>
  <OL>
   <LI>Dwójkowy (binarny)<BR>
    <P>Najprostszy dla komputera, gdzie co¶ jest albo w³±czone, albo wy³±czone. System ten operuje na
    liczbach zwanych <span class="b">bitami</span> (bit = <span lang="en">binary digit</span>
    = cyfra dwójkowa). Bit przyjmuje jedn± z dwóch warto¶ci: 0 lub 1.<BR>
    Na <span class="b">bajt</span> sk³ada siê 8 bitów.
    	 Jednym bajtem mo¿na przedstawiæ wiêc 2^8=256 mo¿liwo¶ci.</P>
    <P>Przeliczenie liczby zapisanej w systemie dwójkowym na dziesiêtny jest proste. Podobnie
	jak w systemie dziesiêtnym, ka¿d± cyfrê mno¿ymy przez odpowiedni± potêgê podstawy
	(podstawa wynosi 2 w systemie dwójkowym, 10 w systemie dziesiêtnym).</P>
    <P>Oto przyk³ad (daszek ^ oznacza potêgowanie):<BR>
	 1010 1001 dwójkowo =<BR>
	 1*(2^7) + 0*(2^6) + 1*(2^5) + 0*(2^4) + 1*(2^3) + 0*(2^2) + 0*(2^1) + 1*(2^0) = <BR>
	 128 + 32 + 8 + 1 =<BR>
	 169 dziesiêtnie (lub <q>dec</q>, od <q lang="en">decimal</q>).</P>

    <P>Dzia³anie odwrotne te¿ nie jest trudne: nasz± liczbê dzielimy ci±gle (do chwili
	uzyskania ilorazu równego 0) przez 2, po czym zapisujemy reszty z dzielenia wspak:</P>
	<BR><a href="#linux0101" tabindex="1" class="bezdruk">(przeskocz konwersjê liczby dziesiêtnej na dwójkow±)</a>
	<PRE title="dziesiêtny na binarny" class="asciiart">
	169	|
	 84	| 1
	 42	| 0
	 21	| 0
	 10	| 1
	  5	| 0
	  2	| 1
	  1	| 0
	  0	| 1</PRE>
	<P><a name="linux0101" id="linux0101">Wspak dostajemy</a>: 1010 1001, czyli wyj¶ciow± liczbê.
	</P></LI>




   <LI>Szesnastkowy (heksadecymalny, w skrócie hex)<BR>
    <P>Jako ¿e system dwójkowy ma mniej cyfr ni¿ dziesiêtny, do przedstawienia wzglêdnie ma³ych
    liczb trzeba u¿yæ du¿o zer i jedynek. Jako ¿e bajt ma 8 bitów, podzielono go na dwie równe,
    czterobitowe czê¶ci. Teraz bajt mo¿na ju¿ reprezentowaæ dwoma znakami, a nie o¶mioma. Na ka¿dy
    taki znak sk³ada siê 2^4=16 mo¿liwo¶ci. St±d wziê³a siê nazwa <q>szesnastkowy</q>.<BR>
    Powsta³ jednak problem: cyfr jest tylko 10, a trzeba mieæ 16. Co zrobiæ?<BR>
    Postanowiono liczbom 10-15 przyporz±dkowaæ odpowiednio znaki A-F.<BR>
    Na przyk³ad<BR>
    Liczba 255 dziesiêtnie = 1111 1111 binarnie = FF szesnastkowo (1111 bin = 15 dec = F hex)<BR>
    Liczba 150 dziesiêtnie = 1001 0110 binarnie = 96 szesnastkowo.</P>

    <P>Nale¿y zauwa¿yæ ¶cis³y zwi±zek miêdzy systemem dwójkowym i szesnastkowym:
	1 cyfra szesnastkowa to 4 bity, co umo¿liwia b³yskawiczne przeliczanie miêdzy obydwoma
	systemami: wystarczy <q>t³umaczyæ</q> po 4 bity (1 cyfrê hex) na raz i zrobione.
	</P>
    <P>Przeliczenie liczby zapisanej w systemie szesnastkowym na dziesiêtny jest równie proste,
	jak t³umaczenie z dwójkowego na dziesiêtny. Ka¿d± cyfrê mno¿ymy przez odpowiedni±
	 potêgê podstawy (podstawa wynosi 16 w systemie szesnastkowym).</P>
    <P>Oto przyk³ad:<BR>
	 10A szesnastkowo =<BR>
	 1*16^2 + 0*16^1 + A*16^0 =<BR>
	 256 + 0 + 10 =<BR>
	 266 dziesiêtnie.</P>

    <P>Dzia³anie odwrotne te¿ nie jest trudne: nasz± liczbê dzielimy ci±gle (do chwili
	uzyskania ilorazu równego 0) przez 16, po czym zapisujemy reszty z dzielenia wspak:</P>
	<BR><a href="#linux0102" class="bezdruk">(przeskocz konwersjê liczby dziesiêtnej na szesnastkow±)</a>
	<PRE title="dziesiêtny na szesnastkowy" class="asciiart">
	 266	|
	 16	| 10
	  1	| 0
	  0	| 1</PRE>
	<a name="linux0102" id="linux0102">Wspak dostajemy kolejno</a>: 1, 0, 10, czyli 10A, czyli wyj¶ciow± liczbê.
	<P>

	Podczas pisania programów, liczby w systemie szesnastkowym oznacza siê przez dodanie
	na koñcu litery <span class="b">h</span> (lub z przodu <span class="b">0x</span>),
	a liczby w systemie dwójkowym - przez dodanie litery <span class="b">b</span> na koñcu.<BR>
	 Tak wiêc, 101 oznacza dziesiêtn± liczbê o warto¶ci 101, 101b oznacza liczbê 101 w
	systemie dwójkowym (czyli 5 w systemie dziesiêtnym), a 101h lub 0x101 oznacza liczbê
	101 w systemie szesnastkowym (czyli 257 dziesiêtnie).</P>


	</LI></OL><BR>

<HR>
<h2 class="nag">Jêzyk asembler i rejestry procesora</h2>


 <P>Co to jest asembler?<BR>

   Asembler jest to jêzyk programowania, nale¿±cy do jêzyków niskiego poziomu.
   Znaczy to tyle, ¿e jednej komendzie asemblera odpowiada dok³adnie jeden rozkaz procesora.
   Asembler operuje na rejestrach procesora.</P>

   <P>A co to jest rejestr procesora?<BR>

   Rejestr procesora to zespó³ uk³adów elektronicznych, mog±cy przechowywaæ informacje (taka
   w³asna pamiêæ wewnêtrzna procesora).<BR>

   Zaraz podam Wam podstawowe rejestry, na których
   bêdziemy operowaæ. Wiem, ¿e ich liczba mo¿e przeraziæ, ale od razu mówiê, aby¶cie
    <em class="wazne">NIE uczyli
   siê tego wszystkiego na pamiêæ</em>! Najlepiej zrobicie, czytaj±c poni¿sz± listê tylko 2 razy, a
   potem wracali do niej, gdy jakikolwiek rejestr pojawi siê w programach, które
   bêdê pó¼niej prezentowa³ w ramach tego kursu.<BR>

   Oto lista interesuj±cych nas rejestrów:</P>
 <OL>
   <LI> ogólnego u¿ytku:<BR><BR>
    <UL>
     <LI>akumulator:<BR>
     			 RAX (64 bity) = EAX (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 EAX (32 bity) = AX (m³odsze 16 bitów) + starsze 16 bitów,<BR>
                     AX = AH (starsze 8 bitów) + AL (m³odsze 8 bitów)<BR>
	Rejestr ten s³u¿y do wykonywania dzia³añ matematycznych, ale czêsto w tym
	rejestrze bêdziemy mówiæ systemowi operacyjnemu,
	co od niego chcemy.
	<BR><BR></LI>
     <LI>bazowy:<BR>
     			 RBX (64 bity) = EBX (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 EBX (32 bity) = BX (m³odsze 16 bitów) + starsze 16 bitów,<BR>
                 BX = BH (starsze 8 bitów) + BL (m³odsze 8 bitów)<BR>
	Ten rejestr jest u¿ywany na przyk³ad przy dostêpie do tablic.
	<BR><BR></LI>
     <LI>licznik:<BR>
     			 RCX (64 bity) = ECX (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 ECX (32 bity) = CX (m³odsze 16 bitów) + starsze 16 bitów,<BR>
                  CX = CH (starsze 8 bitów) + CL (m³odsze 8 bitów)<BR>
	Tego rejestru u¿ywamy na przyk³ad do okre¶lania ilo¶ci powtórzeñ pêtli.
	<BR><BR></LI>
     <LI>rejestr danych:<BR>
     			 RDX (64 bity) = EDX (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 EDX (32 bity) = DX (m³odsze 16 bitów) + starsze 16 bitów,<BR>
                         DX = DH (starsze 8 bitów) + DL (m³odsze 8 bitów)<BR>
	W tym rejestrze na przyk³ad przechowujemy adresy ró¿nych zmiennych.
	<BR><BR></LI>


     <LI>rejestry dostêpne <span class="b">tylko w trybie 64-bitowym</span>:<BR>
     	<UL>
	 <LI>8 rejestrów 8-bitowych: R8B, R9B, ..., R15B (lub R8L, R9L, ..., R15L)</LI>
	 <LI>8 rejestrów 16-bitowych: R8W, R9W, ..., R15W</LI>
	 <LI>8 rejestrów 32-bitowych: R8D, R9D, ..., R15D</LI>
	 <LI>8 rejestrów 64-bitowych: R8, R9, ..., R15</LI>
	</UL><BR><BR></LI>


     <LI>rejestry indeksowe:
      <UL>
       <LI>indeks ¼ród³owy:<BR>
       			 RSI (64 bity) = ESI (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 ESI (32 bity) = SI (m³odsze 16 bitów) + starsze 16 bitów,<BR>
			 SI (16 bitów) = SIL (m³odsze 8 bitów) + starsze 8 bitów
			  <span class="b">(tylko tryb 64-bit)</span>
			 <BR><BR></LI>
       <LI>indeks docelowy:<BR>
       			 RDI (64 bity) = EDI (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 EDI (32 bity) = DI (m³odsze 16 bitów) + starsze 16 bitów,<BR>
			 DI (16 bitów) = DIL (m³odsze 8 bitów) + starsze 8 bitów
			  <span class="b">(tylko tryb 64-bit)</span>
			 </LI>
      </UL>
	Rejestry indeksowe najczê¶ciej s³u¿± do operacji na d³ugich ³añcuchach danych, w tym
	napisach i tablicach.
	<BR><BR></LI>
     <LI>rejestry wska¼nikowe:
      <UL>
       <LI>wska¼nik bazowy:<BR>
       			 RBP (64 bity) = EBP (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 EBP (32 bity) = BP (m³odsze 16 bitów) + starsze 16 bitów.<BR>
			 BP (16 bitów) = BPL (m³odsze 8 bitów) + starsze 8 bitów
			  <span class="b">(tylko tryb 64-bit)</span> <BR>
	Najczê¶ciej s³u¿y do dostêpu do zmiennych lokalnych danej funkcji.
	<BR><BR></LI>
       <LI>wska¼nik stosu:<BR>
       			 RSP (64 bity) = ESP (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 ESP (32 bity) = SP (m³odsze 16 bitów) + starsze 16 bitów.<BR>
			 SP (16 bitów) = SPL (m³odsze 8 bitów) + starsze 8 bitów
			  <span class="b">(tylko tryb 64-bit)</span> <BR>
	S³u¿y do dostêpu do stosu (o tym nieco pó¼niej).
	<BR><BR></LI>
       <LI>wska¼nik instrukcji:<BR>
       			 RIP (64 bity) = EIP (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 EIP (32 bity) = IP (m³odsze 16 bitów) + starsze 16 bitów.<BR>
	Mówi procesorowi, sk±d ma pobieraæ instrukcje do wykonywania.
	</LI>
      </UL></LI>
    </UL><BR>
      <LI>rejestry segmentowe (wszystkie 16-bitowe) - tych najlepiej
       <span class="b">nie dotykaæ</span> w Linuksie:
	<BR><BR>
   <UL>
    <LI>segment kodu CS - mówi procesorowi, gdzie znajduj± siê dla niego instrukcje.</LI>
    <LI>segment danych DS - ten najczê¶ciej pokazuje na miejsce, gdzie trzymamy nasze
	zmienne.</LI>
    <LI>segment stosu SS - dziêki niemu wiemy, w którym segmencie jest nasz stos. O tym,
	czym w ogóle jest stos, powiem w nastêpnej czê¶ci.</LI>
    <LI>segment dodatkowy ES - zazwyczaj pokazuje na to samo, co DS - na nasze zmienne. </LI>
    <LI>FS i GS - nie maj± specjalnego przeznaczenia. S± tu
	na wypadek, gdyby zabrak³o nam innych rejestrów segmentowych.</LI>
   </UL><BR>
  <LI>rejestr stanu procesora: FLAGI (16-bitowe), E-FLAGI (32-bitowe) lub R-FLAGI (64-bitowe).<BR>
  	S³u¿± one przede wszystkim do badania
	wyniku ostatniego przekszta³cenia (na przyk³ad czy nie wyst±pi³o przepe³nienie, czy wynik jest
	zerem, itp.). Najwa¿niejsze flagi to
	 CF (<span lang="en">carry flag</span> - flaga przeniesienia),
	 OF (<span lang="en">overflow flag</span> - flaga przepe³nienia),
	 SF (<span lang="en">sign flag</span> - flaga znaku),
	 ZF (<span lang="en">zero flag</span> - flaga zera),
	 IF (<span lang="en">interrupt flag</span> - flaga przerwañ),
	 PF (<span lang="en">parity flag</span> - flaga parzysto¶ci),
	 DF (<span lang="en">direction flag</span> - flaga kierunku).<BR><BR></LI>
 </OL>

   <P>U¿ycie litery R przed symbolem rejestru, na przyk³ad RCX, oznacza rejestr 64-bitowy,
    <span class="b">dostêpny tylko
   na procesorach 64-bitowych</span>.</P>
<P>
   U¿ycie litery E przed symbolem rejestru, na przyk³ad EAX, oznacza rejestr 32-bitowy,
    <span class="b">dostêpny tylko
   na procesorach rodziny 80386 lub lepszych</span>. Nie dotyczy to rejestru ES.</P>

   <P>Napisy</P> <blockquote>RAX = EAX+starsze 32 bity;  EAX=AX+ starsze 16 bitów;  AX=AH+AL</blockquote>
    <P>oznaczaj±:</P>
    <BR><a href="#linux0103" class="bezdruk">(przeskocz rozwiniêcie rejestru RAX)</a>
<PRE title="RAX, EAX, AX oraz AH i AL" class="asciiart">
				RAX (64 bity)
				     |                 EAX (32b)
    00000000000000000000000000000000 | 0000000000000000 | 00000000 | 00000000
       		   32b	     	     |	      16b       |        AX(16b)
                       		     | 		        |  AH(8b)  |   AL(8b)</PRE>
   <P><a name="linux0103" id="linux0103">Napisy</a></P>
    <blockquote>RSI = ESI+starsze 32 bity;  ESI = SI + starsze 16 bitów; SI = SIL+starsze 8 bitów
   	</blockquote> <P>oznaczaj±:</P>
    <BR><a href="#linux0104" class="bezdruk">(przeskocz rozwiniêcie rejestru RSI)</a>
<PRE title="RSI, ESI, SI oraz SIL" class="asciiart">
				RSI (64 bity)
				     |               ESI (32b)
    00000000000000000000000000000000 | 0000000000000000 | 00000000 | 00000000
       		   32b		     |	     16b        |        SI(16b)
                       		     |		        |   8b     |  SIL(8b)</PRE>
	<P>

	<a name="linux0104" id="linux0104">Jedna wa¿na uwaga</a>
	 - miêdzy nazwami rejestrów mo¿e pojawiæ siê dwukropek w dwóch ró¿nych znaczeniach:</P>
	<UL>
	<LI>zapis <q>DX : AX</q> (lub 2 dowolne zwyk³e rejestry) bêdzie oznaczaæ liczbê,
	której starsza czê¶æ znajduje siê w rejestrze po lewej stronie (DX), a m³odsza - w
	tym z prawej (AX). Warto¶æ liczby wynosi DX*65536 + AX.<BR></LI>
	<LI>zapis <q>CS : SI</q> (rejestr segmentowy + dowolny zwyk³y) bêdzie najczê¶ciej oznaczaæ wska¼nik
	do jakiego¶ obiektu w pamiêci (o pamiêci opowiem nastêpnym razem). Rejestr segmentowy
	zawiera oczywi¶cie segment, w którym znajduje siê ów obiekt, a rejestr zwyk³y -
	offset (przesuniêcie, adres w tym segmencie) tego¿ obiektu.<BR></LI>
	</UL>
	<P>Na razie nie musicie siê przejmowaæ tymi dwukropkami. Mówiê to tylko dlatego, ¿eby¶cie
	nie byli zaskoczeni, gdy¿ w przysz³o¶ci siê pojawi±.</P>

   <P>Programista mo¿e odnosiæ siê bezpo¶rednio do wszystkich wymienionych rejestrów, z wyj±tkiem
   *IP oraz flag procesora (z wyj±tkami).</P>

	<P>Jak widaæ po ich rozmiarach, do rejestrów 8-bitowych mo¿na wpisaæ liczbê z przedzia³u
	0-255 (lub od -128 do 127, gdy najwy¿szy, siódmy bit s³u¿y nam jako bit oznaczaj±cy
	znak liczby), w 16-bitowych zmieszcz± siê liczby 0-65535 (od -32768 do 32767), a w
	32-bitowych - liczby od 0 do 4.294.967.295 (od -2.147.483.648 do 2.147.483.647).</P>
   <P>
   Dobrym, choæ trudnym w odbiorze ¼ród³em informacji s±:
   <cite lang="en">Intel Architecture Software Developer's Manual</cite> (IASDM)
    dostêpny <em class="wazne">ZA DARMO</em> ze
   	<A class="intel_link" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" hreflang="en">stron Intela</A>

   oraz <em class="wazne">DARMOWE</em> podrêczniki <cite lang="en">AMD64 Architecture
   	Programmer's Manual</cite>
 <A class="amd_link" href="http://developer.amd.com/Resources/documentation/guides/Pages/default.aspx" hreflang="en">firmy
	<acronym title="Advanced Micro Devices" lang="en">AMD</acronym></A></P>

<BR>

<!-- ###################################################################### -->
<HR>
<h2 class="nag">Pisanie i kompilowanie (asemblowanie) swoich programów</h2>

 <P>Jak pisaæ programy w asemblerze?<BR>
   Nale¿y zaopatrzyæ siê w:</P>
<UL>

   <LI> Edytor tekstu, mog±cy zapisywaæ pliki tekstowe (bez formatowania), na przyk³ad VIM, LPE,
	Emacs/XEmacs, <span lang="en">Joe</span>, <span lang="en">Pico</span>, Jed,
	<span lang="en">Kate</span>, KWrite.</LI>
   <LI> Kompilator jêzyka asembler (patrz dalej)</LI>
   <LI> Odpowiedni program ³±cz±cy (<q>konsolidator</q>, ang. <span class="b">linker</span>),
   	 chyba ¿e kompilator ma ju¿ taki wbudowany, jak na przyk³ad FASM</LI>
</UL>
 <P>  Wtedy wystarczy napisaæ w edytorze tekstu plik zawieraj±cy komendy procesora (o tym
   pó¼niej), zapisaæ go z rozszerzeniem .asm lub .s (GNU as), po czym u¿yæ kompilatora,
   aby przetworzyæ program na kod rozumiany przez procesor. </P>



 <P>Jakiego kompilatora u¿yæ?<BR>
   Istnieje wiele kompilatorów jêzyka asembler pod Linuksa. Do najpopularniejszych nale¿±
   <span lang="en">Netwide Asembler Project</span> (NASM),
   <span lang="en">Flat Asembler</span> (FASM),
   <span lang="en">High-Level Asembler</span> (HLA) i Gnu As.</P>

   <P>Mo¿na je ¶ci±gn±æ z internetu:</P>
	<BR><a href="#linux0104_1" class="bezdruk">(przeskocz adresy stron kompilatorów)</a>
<UL>
    <LI>NASM: <A HREF="http://sourceforge.net/projects/nasm" hreflang="en" lang="en">sf.net/projects/nasm</A></LI>
    <LI>FASM: <A HREF="http://www.flatasembler.net" hreflang="en">flatasembler.net</A></LI>
    <LI>HLA:  <A HREF="http://webster.cs.ucr.edu" hreflang="en">webster.cs.ucr.edu</A></LI>
    <LI>Gnu Asembler znajduje siê w pakiecie <span lang="en">binutils</span>
    	 (powinien byæ w ka¿dej dystrybucji).
</UL>
   <P><a name="linux0104_1" id="linux0104_1">Po skompilowaniu pliku</a>
    z kodem ¼ród³owym nale¿y u¿yæ programu ³±cz±cego - bêdziemy u¿ywaæ
   standardowego LD (tego, którego u¿ywaj± inne kompilatory), gdy¿ równie¿ powinien siê
   znajdowaæ w ka¿dej dystrybucji Linuksa.</P>

<!-- ###################################################################### -->

<P>Mamy wiêc ju¿ wszystko, co potrzeba. Zaczynamy pisaæ. Bêdê tutaj u¿ywa³ sk³adni NASMa i FASMa
(gdy¿ kompiluj± one programy w sk³adni Intela, która jest bardziej przejrzysta, mimo i¿ mo¿e
siê wydawaæ <q>odwrotna</q>).<br>
Najpierw programy na systemy 32-bitowe:</P>
	<BR><a href="#linux0105" class="bezdruk">(przeskocz pierwszy 32-bitowy program w sk³adni NASM)</a>
<PRE title="pierwszy program, sk³adnia NASM">
	; wersja NASM na system 32-bitowy

	section	.text			; pocz±tek sekcji kodu.
	global _start		; linker ld chce mieæ ten symbol globalny

	_start:				; punkt startu programu

		mov	eax, 4		; numer funkcji systemowej:
					; sys_write - zapisz do pliku
		mov	ebx, 1		; numer pliku, do którego piszemy.
					; 1 = standardowe wyj¶cie = ekran
		mov	ecx, tekst	; ECX = adres (offset) tekstu
		mov	edx, dlugosc	; EDX = d³ugo¶æ tekstu
		int	80h		; wywo³ujemy funkcjê systemow±
		mov	eax, 1		; numer funkcji systemowej
					; (sys_exit - wyjd¼ z programu)
		int	80h		; wywo³ujemy funkcjê systemow±

	section .data			; pocz±tek sekcji danych.

	tekst	db	&quot;Czesc&quot;, 0ah	; nasz napis, który wy¶wietlimy
	dlugosc	equ	$ - tekst	; d³ugo¶æ napisu</PRE>

<hr>
<P><a name="linux0105" id="linux0105">Teraz wersja dla FASMa</a>:</P>
	<BR><a href="#linux0106" class="bezdruk">(przeskocz pierwszy 32-bitowy program w sk³adni FASM)</a>
<PRE title="pierwszy program, sk³adnia FASM">
	; wersja FASM na system 32-bitowy

	format ELF executable		; typ pliku
	entry _start			; punkt startu programu

	segment	readable executable	; pocz±tek sekcji kodu

	_start:				; punkt startu programu

		mov	eax, 4		; numer funkcji systemowej:
					; sys_write - zapisz do pliku
		mov	ebx, 1		; numer pliku, do którego piszemy.
					; 1 = standardowe wyj¶cie = ekran
		mov	ecx, tekst	; ECX = adres (offset) tekstu
		mov	edx, [dlugosc]	; EDX = d³ugo¶æ tekstu
		int	80h		; wywo³ujemy funkcjê systemow±
		mov	eax, 1		; numer funkcji systemowej
					; (sys_exit - wyjd¼ z programu)
		int	80h		; wywo³ujemy funkcjê systemow±

	segment readable writeable	; pocz±tek sekcji danych.
	tekst	db	&quot;Czesc&quot;, 0ah	; nasz napis, który wy¶wietlimy
	dlugosc	dd	$ - tekst	; d³ugo¶æ napisu</PRE>

<hr>
<P><a name="linux0106" id="linux0106">Teraz program 64-bitowy (x86-64) dla NASMa</a>:</P>
	<BR><a href="#linux0107" class="bezdruk">(przeskocz pierwszy 64-bitowy program w sk³adni NASM)</a>
<PRE title="pierwszy program, sk³adnia NASM">
	; wersja NASM na system 64-bitowy (x86-64)

	section	.text			; pocz±tek sekcji kodu.
	global _start		; linker ld chce mieæ ten symbol globalny

	_start:				; punkt startu programu

		mov	rax, 1		; numer funkcji systemowej:
					; sys_write - zapisz do pliku
		mov	rdi, 1		; numer pliku, do którego piszemy.
					; 1 = standardowe wyj¶cie = ekran
		mov	rsi, tekst	; RSI = adres (offset) tekstu
		mov	rdx, dlugosc	; RDX = d³ugo¶æ tekstu
		syscall			; wywo³ujemy funkcjê systemow±
		mov	rax, 60		; numer funkcji systemowej
					; (sys_exit - wyjd¼ z programu)
		syscall			; wywo³ujemy funkcjê systemow±

	section .data			; pocz±tek sekcji danych.

	tekst	db	&quot;Czesc&quot;, 0ah	; nasz napis, który wy¶wietlimy
	dlugosc	equ	$ - tekst	; d³ugo¶æ napisu</PRE>

<hr>
<P><a name="linux0107" id="linux0107">I w koñcu program 64-bitowy dla FASMa</a>:</P>
	<BR><a href="#linux0108" class="bezdruk">(przeskocz pierwszy 64-bitowy program w sk³adni FASM)</a>
<PRE title="pierwszy program, sk³adnia FASM">
	; wersja FASM na system 64-bitowy  (x86-64)

	format ELF64 executable		; typ pliku
	entry _start			; punkt startu programu

	segment	readable executable	; pocz±tek sekcji kodu

	_start:				; punkt startu programu
		mov	rax, 1		; numer funkcji systemowej:
					; sys_write - zapisz do pliku
		mov	rdi, 1		; numer pliku, do którego piszemy.
					; 1 = standardowe wyj¶cie = ekran
		mov	rsi, tekst	; RSI = adres (offset) tekstu
		mov	rdx, [dlugosc]	; RDX = d³ugo¶æ tekstu
		syscall			; wywo³ujemy funkcjê systemow±
		mov	rax, 60		; numer funkcji systemowej
					; (sys_exit - wyjd¼ z programu)
		syscall			; wywo³ujemy funkcjê systemow±

	segment readable writeable	; pocz±tek sekcji danych.
	tekst	db	&quot;Czesc&quot;, 0ah	; nasz napis, który wy¶wietlimy
	dlugosc	dq	$ - tekst	; d³ugo¶æ napisu w trybie 64-bitowym</pre>

<P><a name="linux0108" id="linux0108">Bez paniki!</a> Teraz omówimy dok³adnie, co ka¿da linia robi.</P>
<UL>

 <LI>linie lub napisy zaczynaj±ce siê ¶rednikiem.
	<P>Traktowane s± jako komentarze i s±
	ca³kowicie ignorowane przy kompilacji. Rozmiar skompilowanego programu wynikowego
	 nie zale¿y od ilo¶ci
	komentarzy. Dlatego najlepiej wstawiaæ tyle komentarzy, aby
	inni (równie¿ my) mogli pó¼niej zrozumieæ nasz kod.</P></LI>

 <LI>(FASM) <CODE lang="en">format ELF executable</CODE> /
 	<CODE lang="en">format ELF64 executable</CODE>
	<P>Okre¶la format (typ) pliku wyj¶ciowego: wykonywalny plik ELF (format u¿ywany w Linuksie).
 	FASM nie potrzebuje programów ³±cz±cych, aby utworzyæ program.
 	Format ELF64 jest u¿ywany oczywi¶cie pod systemem 64-bitowym.
	</P></LI>

 <LI>(FASM) <CODE lang="en">entry _start</CODE>
	<P>Okre¶la, gdzie program siê zaczyna. Po uruchomieniu programu procesor zaczyna wykonywaæ
	komendy zaczynaj±ce siê pod podan± tutaj etykiet± (_start) znajduj±c± siê w sekcji
	kodu.
	</P></LI>

 <LI>(FASM) <CODE lang="en">segment readable executable</CODE>
	<P>Okre¶la nowy segment programu - segment kodu, któremu ustawiamy odpowiednie atrybuty:
	do odczytu i do wykonywania. Innym atrybutem jest <CODE lang="en">writeable</CODE> (do zapisu), który
	powinien byæ u¿ywany tylko do sekcji danych.
	Mimo, i¿ FASM zaakceptuje atrybut <CODE lang="en">writeable</CODE> dla sekcji kodu, nie
	powinni¶my go tam umieszczaæ. Zapisanie czegokolwiek do sekcji kodu mo¿e skoñczyæ
	siê b³êdem naruszenia ochrony pamiêci (<span lang="en">segmentation fault</span>).
	 Mo¿na jednak w tym segmencie
     umieszczaæ dane. Ale nale¿y to robiæ tak, aby nie sta³y siê one czê¶ci± programu, zwykle
     wpisuje siê je za ostatni± komend± koñcz±c± program. Procesor przecie¿ nie wie, co jest pod
     danym adresem i z mi³± chêci± potraktuje to co¶ jako instrukcjê, co mo¿e prowadziæ do
     przykrych konsekwencji. Swoje dane umieszczajcie tak, aby w ¿aden sposób strumieñ
     wykonywanych instrukcji nie wszed³ na nie. <BR>
	Dane bêdziemy wiêc zazwyczaj umieszczaæ w oddzielnej sekcji.
	</P></LI>

 <LI>(NASM) <CODE lang="en">section .text</CODE>
     <P>Wskazuje pocz±tek segmentu, gdzie znajduje siê kod programu. Mo¿na jednak w tym segmencie
     umieszczaæ dane. Ale nale¿y to robiæ tak, aby nie sta³y siê one czê¶ci± programu, zwykle
     wpisuje siê je za ostatni± komend± koñcz±c± program. Procesor przecie¿ nie wie, co jest pod
     danym adresem i z mi³± chêci± potraktuje to co¶ jako instrukcjê, co mo¿e prowadziæ do
     przykrych konsekwencji. Swoje dane umieszczajcie tak, aby w ¿aden sposób strumieñ
     wykonywanych instrukcji nie wszed³ na nie. Zapisanie czegokolwiek do sekcji kodu
     mo¿e skoñczyæ siê b³êdem naruszenia ochrony pamiêci (<span lang="en">segmentation fault</span>),
     dlatego dane bêdziemy zazwyczaj umieszczaæ w oddzielnej sekcji.
	</P></LI>

 <LI>(NASM) <CODE lang="en">global _start</CODE>
	<P>Sprawiamy, ¿e nazwa <q>_start</q> bêdzie widziana poza tym programem (konkretnie to przez
	linker ld, który skompilowan± wersjê programu przerobi na wersjê wykonywaln±).
	</P></LI>

 <LI><CODE>_start:</CODE> (z dwukropkiem)
	<P>Etykieta okre¶laj±ca pocz±tek programu.
	</P></LI>


 <LI><CODE>mov	eax, 4</CODE> / <code>mov rax, 1</code>
	<P>Do rejestru EAX (32-bitowy) lub RAX (64-bitowy) wstaw
	(<code>MOV</code> = <span lang="en">move</span>, przesuñ) warto¶æ 4
	(1 na systemach x86-64).
	 Jest to numer funkcji systemu Linux, któr±
	chcemy uruchomiæ. Je¶li chcemy skorzystaæ z funkcji systemowych, to zawsze EAX zawiera
	numer takiej funkcji.
	<br>
	Numery funkcji ró¿ni± siê na ró¿nych architekturach procesorów. Poczytajcie mój
	<a href="przer80h_1.html" hreflang="pl">spis funkcji systemowych</a>.
	</P>

     <P>Komenda <code>MOV</code> ma 3 wa¿ne ograniczenia:</P>
  <OL>
   <LI>nie mo¿na skopiowaæ jedn± komend± <code>MOV</code> komórki pamiêci do innej komórki pamiêci,
      takie co¶:
    <PRE>		mov	[a], [b]    </PRE>
      (gdzie a i b - dwie zmienne w pamiêci) jest zabronione.<BR>
      O tym, co oznaczaj± nawiasy kwadratowe, czyli o adresowaniu zmiennych w pamiêci - nastêpnym razem.
	<br><br></LI>

   <LI>nie mo¿na skopiowaæ jedn± komend± <code>MOV</code> jednego rejestru segmentowego (cs,ds,es,ss,fs,gs)
       do innego rejestru segmentowego, czyli taka operacja
    <PRE>		mov	es, ds    </PRE>
      jest zabroniona. W ogóle najlepiej <em class="wazne">unikaæ jakichkolwiek operacji na rejestrach
	segmentowych</em>.<br><br></LI>

   <LI>Nie mo¿na do rejestru segmentowego bezpo¶rednio wpisaæ jakie¶ warto¶ci. Czyli nie mo¿na
	<PRE>		mov	ds, 0	</PRE>
	Ale mo¿na:
	<PRE>		mov	bx, 0
		mov	ds, bx	</PRE>
   </OL>

	<BR><BR></LI>

 <LI><CODE>mov	ebx, 1</CODE> / <code>mov rdi, 1</code>
	<P>Do rejestru EBX (32-bitowy) lub RDI (64-bitowy) wstaw 1. Dlaczego akurat 1? Zaraz siê przekonamy.
	</P></LI>

 <LI><CODE>mov ecx,tekst</CODE> / <code>mov rsi, tekst</code>
	<P>Do rejestru ECX (32-bitowy) lub RSI (64-bitowy) wstaw offset (adres)
	etykiety <q>tekst</q>. Mo¿na obliczaæ
	adresy nie tylko danych, ale etykiet znajduj±cych siê w kodzie programu.
	</P></LI>

 <LI><CODE>mov edx, dlugosc / mov edx, [dlugosc]</CODE>
 	/ <code>mov rdx, dlugosc / mov rdx, [dlugosc]</code>
	<P>Do rejestru EDX (32-bitowy) lub RDX (64-bitowy) wstaw d³ugo¶æ naszego tekstu.
	 W pierwszym przypadku
	jest to sta³a, w drugim warto¶æ pobieramy ze zmiennej.
	</P></LI>

 <LI><CODE>int	80h</CODE> / <code>syscall</code>
	<P><q>Int</q> = <span lang="en">interrupt</span> = przerwanie.
	 Nie jest to jednak znane na przyk³ad z kart d¼wiêkowych
	przerwanie typu <acronym lang="en" title="Interrupt Request">IRQ</acronym>.
	 Wywo³uj±c przerwanie 80h (128 dziesiêtnie) lub instrukcjê <code>syscall</code>
	 (w trybie 64-bitowym) uruchamiamy jedn±
	z funkcji Linuksa. Któr±? O tym zazwyczaj mówi rejestr akumulatora.</P>
	<P>W tym przypadku EAX = 4 (lub RAX = 1 w trybie 64-bitowym) i jest to funkcja
	zapisu do pliku - <span lang="en">sys_write</span>.
	Funkcja ta przyjmuje 3 argumenty:</P>
	<UL>
	 <LI>W rejestrze EBX (lub RDI, w trybie 64-bitowym) podajemy numer (deskryptor)
	 	pliku, do którego chcemy pisaæ.
		U nas EBX (lub RDI) = 1 i jest to standardowe wyj¶cie (zazwyczaj ekran).</LI>
	 <LI>W rejestrze ECX (lub RSI, w trybie 64-bitowym) podajemy adres danych,
	 	które chcemy zapisaæ do pliku.</LI>
	 <LI>W rejestrze EDX (lub RDX, w trybie 64-bitowym) podajemy, ile bajtów chcemy zapisaæ.</LI>
	</UL>
	<P>Funkcje systemowe 32-bitowego Linuksa przyjmuj± co najwy¿ej 6 argumentów,
	<em class="wazne">kolejno w rejestrach:
	 EBX, ECX, EDX, ESI, EDI, EBP</em>. W EAX oczywi¶cie jest numer funkcji, tak jak tutaj 4.
	 <br><br>
	Funkcje systemowe 64-bitowego Linuksa przyjmuj± tak¿e co najwy¿ej 6 argumentów,
	<em class="wazne">kolejno w rejestrach:
	 RDI, RSI, RDX, R10, R8, R9</em>. W RAX oczywi¶cie jest numer funkcji, tak jak tutaj 1.
	 Rejestry RCX i R11 s± zamazywane.
	</P></LI>

 <LI><CODE>mov	eax, 1</CODE> / <code>mov rax, 60</code>
	<P>Do EAX lub RAX wpisujemy numer kolejnej funkcji systemowej - <span lang="en">sys_exit</span>,
	która spowoduje zamkniêcie naszego programu.
	</P></LI>

 <LI><CODE>int	80h</CODE> / <code>syscall</code>
	<P>Przerwanie systemowe - uruchomienie funkcji wyj¶cia z programu. Numer b³êdu (taki
	<acronym lang="en" title="Disk Operating System">DOS</acronym>-owski
	<span lang="en">errorlevel</span>) zwykle umieszczamy w EBX/RDI, czego tutaj
	jednak nie zrobili¶my.
	</P></LI>

 <LI><CODE lang="en"> (NASM) section .data / (FASM) segment readable writeable</CODE>
 	<P>Okre¶la pocz±tek sekcji danych. Dane musz± byæ w osobnej czê¶ci programu, bo inaczej
 	nie mo¿na do nich zapisywaæ (a na j±drze 2.6 nawet odczytaæ).
 	</P></LI>

 <LI><CODE>tekst	db	&quot;Czesc&quot;,0ah</CODE>
	<P>Definicja napisu i znaku przej¶cia do nowej linii. O tym, jak deklarowaæ
	 zmienne powiem nastêpnym razem.
	</P></LI>

 <LI><CODE>dlugosc	equ	$ - tekst </CODE>
 	/ <CODE> dlugosc	dd	$ - tekst</CODE>
 	/ <CODE> dlugosc	dq	$ - tekst</CODE>
 	<P>
	Definiujemy sta³±, która przyjmuje warto¶æ: <q>adres bie¿±cy</q> - <q>adres pocz±tku napisu</q>,
	czyli d³ugo¶æ napisu. W pierwszym przypadku jest to sta³a kompilacji,
	w drugim i trzecim - zmienna, która bêdzie umieszczona w programie.
	</P></LI>


</UL>
<P>
Programik nazywamy <q>hello.asm</q> i kompilujemy poleceniem (FASM):</P>
<PRE title="kompilacja FASM">	fasm hello.asm hello</PRE>
<P>lub, dla NASMa:</P>
<PRE title="kompilacja NASM">
	nasm -f elf hello.asm
	ld -o hello hello.o</PRE>
<P>lub, dla NASMa na systemie 64-bitowym:</P>
<PRE title="kompilacja NASM">
	nasm -f elf64 hello.asm
	ld -o hello hello.o</PRE>
<P>Wyja¶nienie opcji:</P>
<UL>
 <LI><code>-f elf</code> powoduje, ¿e plik bêdzie skompilowany na 32-bitowy plik obiektowy typu ELF
     (<span lang="en">Executable-Linkable Format</span>, typowy dla wiêkszo¶ci Linuksów).
     Aby kompilowaæ programy pod systemem 64-bitowym, nale¿y u¿yæ formatu <code>elf64</code></LI>
 <LI><code>-f elf64</code> powoduje, ¿e plik bêdzie skompilowany na 64-bitowy plik obiektowy typu ELF</LI>
 <LI><code>-o nazwa</code> spowoduje nazwanie programu wynikowego.</LI>
</UL>


<P>Kompilacja, nawet programu w asemblerze (zwana czasem asemblacj±), ma kilka etapów:</P>
<ul>
 <li><span lang="en">pre-processing</span> - w tej fazie preprocesor przetwarza dyrektywy takie
	jak definicje sta³ych, do³±czanie innych plików do kodu, rozwiniêcia makr i inne, zanim
	poda program kompilatorowi do kompilacji<br><br></li>
 <li>kompilacja - na tym etapie tworzony jest binarny kod programu wynikowego. Podprogram kompilatora
	sprawdza sk³adniê instrukcji, zmienia je na ich binarne odpowiedniki, przetwarza zmienne na
	ich binarne odpowiedniki, sprawdza, czy wszystkie wykorzystane symbole (na przyk³ad u nas zmienna
	<CODE>tekst</CODE>) s± zadeklarowane, sprawdza, czy skoki mieszcz± siê w granicach i wykonuje
	inne niezbêdne czynno¶ci, w tym optymalizacjê. Pozostawia jednak adresy symboli
	nieuzupe³nione.<br><br></li>
 <li>linkowanie (konsolidowanie) - na tym etapie nastêpuje sprawdzenie, czy wszystkie
	symbole pozostawione przez kompilator do uzupe³nienia s± dostêpne w samym programie
	lub innych plikach podanych linkerowi do po³±czenia.
	Je¶li wszystkie symbole s± obecne, nastêpuje wstawianie ich adresów do programu wynikowego
	i wygenerowanie samego programu.
	</li>
</ul>
<p>Je¶li do programu nie do³±czamy innych ju¿ skompilowanych plików ani bibliotek, to
niektóre kompilatory nie wymagaj± osobnego linkera i mog± same sobie poradziæ z wygenerowaniem
programu wyj¶ciowego. Widaæ to na przyk³ad w wywo³aniach FASMa powy¿ej.</p>

<P>
Teraz uruchamiamy <q>./hello</q> i cieszymy siê swoim dzie³em.<BR>
W dalszej czê¶ci kursu bêdê przedstawia³ programy <em class="wazne">tylko 32-bitowe</em>
i czêsto tylko dla <em class="wazne">jednego kompilatora</em>.
Ta czê¶æ bêdzie s³u¿yæ Wam pomoc±, je¶li chcieliby¶cie pisaæ
programy pod systemy 64-bitowe lub pod inny kompilator.
</P>

<P>Mi³ego eksperymentowania.</P>

<blockquote>Na ¶wiecie jest 10 rodzajów ludzi:<BR>
ci, którzy rozumiej± liczby binarne i ci, którzy nie.</blockquote>

<br><br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="bsd.html">Informacja</a> dla u¿ytkowników *BSD (Alt+3)<br>
<a accesskey="4" hreflang="pl" href="linux02.html">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

<BR><BR><HR>
<h2 class="nag">Æwiczenia</h2>
<BR>
<OL>
<LI>Poeksperymentujcie sobie, wstawiaj±c ró¿ne znaki do napisu. Na przyk³ad, znaki o kodach
  ASCII 10 (<span lang="en">Line Feed</span>), 13 (<span lang="en">Carriage Return</span>),
   7 (<span lang="en">Bell</span>). Na przyk³ad:
	<PRE>	info	db	&quot;Czesc.&quot;, 00, 01, 02, 07, 10, 13, 10, 13</PRE>
 </LI>
</OL>

</BODY></HTML>
