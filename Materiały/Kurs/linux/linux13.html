<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks, czê¶æ 13 - Operacje bitowe </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Prev"     hreflang="pl" lang="en" href="linux12.html" >
<link rel="Next"     hreflang="pl" lang="en" href="linux14.html" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="kurs, asm, asembler, assembler, and, or, xor, shl, shr,
	shld, shrd, sal, bt, bts, btc, btr, test, linux, linuks">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Mon, Oct 29 2012 17:22:20 CEST">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler pod Linuksem?<BR>
	<h1 class="nag">Czê¶æ 13 - Operacje na bitach, czyli to,
	w czym asembler b³yszczy najbardziej</h1></div>

<P>
W tej czê¶ci poznamy wa¿n± grupê instrukcji - operacje na bitach. Te w³a¶nie instrukcje
odró¿niaj± asemblera od innych jêzyków, gdzie rzadko pojawia siê mo¿liwo¶æ dzia³ania na
tych najmniejszych jednostkach informacji (odpowiednie operatory istniej± w jêzykach
C i <span lang="en">Pascal</span>, ale inne jêzyki, jak na przyk³ad Fortran 77, s± tego pozbawione).<BR>
Mimo i¿ o wszystkich instrukcjach opisanych w tej czê¶ci ju¿ wspomnia³em przy okazji
omawiania podstawowych rozkazów procesora, to instrukcje bitowe s± wa¿ne i zas³uguj± na
oddzielny rozdzia³, po¶wiêcony w ca³o¶ci tylko dla nich.
</P>
<P>
Zdawaæ by siê mog³o, ¿e z takim jednym, maleñkim bitem niewiele da siê zrobiæ: mo¿na go
wyczy¶ciæ (wyzerowaæ), ustawiæ (wstawiæ do niego 1) lub odwróciæ jego bie¿±c± warto¶æ.
Ale te operacje maj± du¿e zastosowania i dlatego ich poznanie jest niezbêdne. Je¶li sobie
przypomnicie, to u¿ywali¶my ju¿ wielokrotnie takich instrukcji jak
<code><span lang="en">AND</span></code> czy <code>XOR</code>.
 Teraz przyszed³ czas, aby poznaæ je bli¿ej.</P>
<HR>




<h2 class="nag">Instrukcja NOT</h2>
	<BR><a href="#linux1301" tabindex="1" class="bezdruk">(przeskocz NOT)</a>
<P>
Instrukcja <code>NOT</code> (logiczna negacja - to <em class="wazne">NIE</em> jest to samo,
co zmiana znaku liczby!) jest najprostsz± z czterech podstawowych operacji logicznych
i dlatego to od niej rozpocznê wstêp do instrukcji bitowych.
</P>
<P><code>NOT</code> jest instrukcj± jednoargumentow±, a jej dzia³anie wygl±da tak:</P>
<PRE title="dzia³anie NOT">
	NOT 0 = 1
	NOT 1 = 0</PRE>

<P>U¿ywamy tej instrukcji wtedy, gdy chcemy naraz odwróciæ wszystkie bity w zmiennej lub rejestrze.
Na przyk³ad, je¶li AX zawiera 0101 0011 0000 1111 (530Fh), to po wykonaniu <code>NOT AX</code>
w rejestrze tym znajdzie siê warto¶æ 1010 1100 1111 0000 (ACF0h). Dodanie obu warto¶ci
powinno daæ FFFFh.</P>
<P><code>NOT</code> mo¿e mieæ zastosowanie tam, gdzie warto¶æ logiczna <q>fa³sz</q> ma przyporz±dkowan± warto¶æ
zero, a <q>prawda</q> - warto¶æ FFFFh, gdy¿ <code>NOT</code> w tym przypadku dok³adnie przek³ada <q>prawdê</q>
na <q>fa³sz</q>.</P>








<BR><BR>
<HR>
<h2 class="nag"><a name="linux1301" id="linux1301">Instrukcja <span lang="en">AND</span></a></h2>
	<BR><a href="#linux1302" class="bezdruk">(przeskocz <span lang="en">AND</span>)</a>


<P>
Instrukcji <code><span lang="en">AND</span></code> (logicznej koniunkcji) najpro¶ciej
u¿ywaæ do wyzerowania bitów. Tabelka dzia³ania <code>AND</code> wygl±da tak:</P>
<PRE title="dzia³anie AND">
	0 AND 0 = 0
	0 AND 1 = 0
	1 AND 0 = 0
	1 AND 1 = 1</PRE>

<P>No ale jakie to mo¿e mieæ zastosowanie?
<BR>
 Powiedzmy teraz, ¿e chcemy sprawdziæ, czy bit
numer 4 (numeracjê bêdê podawa³ od zera) rejestru AX jest równy 1, czy 0. Tutaj
nie wystarczy proste
porównanie <code>CMP</code>, gdy¿ reszta rejestru mo¿e zawieraæ nie wiadomo co. Z pomoc± przychodzi nam
w³a¶nie instrukcja <code><span lang="en">AND</span></code>. Poni¿ej pseudo-przyk³ad:</P>
<PRE>	and	ax, 0000 0000 0001 0000b	; (and ax, 16)</PRE>

<P>Teraz, je¶li bit numer 4 (odpowiadaj±cy warto¶ci 2^4=16) by³ równy 1, to ca³y AX przyjmie
warto¶æ 16, je¶li za¶ by³ równy zero, to ca³y AX bêdzie zerem. Na nasze szczê¶cie, instrukcja
<code>AND</code> ustawia odpowiednio flagi procesora, wiêc rozwi±zaniem naszego problemiku bêdzie kod:</P>
<PRE>
	and	ax, 16
	jz	bit_4_byl_zerem
	;jnz	bit_4_nie_byl_zerem</PRE>

<P>A jakie¶ zastosowanie praktyczne?<BR>
Ju¿ podajê: zamiana ma³ych liter na wielkie. W kodzie
 <acronym title="American Standard Code for Information Interchange" lang="en">ASCII</acronym>
 litery ma³e od wielkich ró¿ni± siê
tylko tym, ¿e maj± ustawiony bit numer 5. Tak wiêc po wykonaniu:</P>
<PRE>
	mov	al, &quot;a&quot;
	and	al, 5fh		; 5fh = 0101 1111 - czy¶cimy bit 5
				; (i 7 przy okazji)</PRE>

<P>w rejestrze AL bêdzie kod wielkiej litery A.<BR>
Inne zastosowanie znajdziecie w moim <a href="spkr_tut_linux.html" hreflang="pl">kursie programowania
g³o¶niczka</a>:</P>
<PRE>
	in	al, 61h
	and	al, not 3		; zerujemy bity 0 i 1
					; NASM: and al,~3
	out	61h, al</PRE>

<P>W tym kodzie instrukcja <code><span lang="en">AND</span></code> pos³u¿y³a nam do wyczyszczenia bitów 0 i 1
 (NOT 3 = NOT 0000 0011 = 1111 1100).</P>
<P>
Jak zauwa¿yli¶cie, instrukcja <code><span lang="en">AND</span></code> niszczy zawarto¶æ rejestru,
oprócz interesuj±cych nas bitów. Je¶li zale¿y Wam na zachowaniu rejestru, u¿yjcie instrukcji
<code>TEST</code>. Dzia³a ona identycznie jak <code><span lang="en">AND</span></code>, ale nie
zapisuje wyniku dzia³ania. Po co nam wiêc taka instrukcja? Otó¿, wynik nie jest
zapisywany, ale <code>TEST</code> ustawia dla nas flagi identycznie jak <code><span lang="en">AND</span></code>.
 Pierwszy kod przepisany z instrukcj± <code>TEST</code> bêdzie wygl±da³ tak:</P>
<PRE>
	test	ax, 16
	jz	bit_4_byl_zerem
	;jnz	bit_4_nie_byl_zerem</PRE>

<P>Teraz nasz program bêdzie ci±gle dzia³aæ prawid³owo, ale tym razem zawarto¶æ rejestru
AX zosta³a zachowana.<BR>
Jest jeszcze jedno ciekawe zastosowanie instrukcji <code>TEST</code>:</P>
<PRE>	test	ax, ax</PRE>
<P>I co to ma niby robiæ? Wykonuje &nbsp;<code><span lang="en">AND</span> AX, AX</code> ,
 nigdzie nie zapisuje wyniku i tylko ustawia flagi.
<BR>
No w³a¶nie! Ustawia flagi, w tym flagê zera ZF. To, co widzicie powy¿ej to
 <em class="wazne">najwydajniejszy</em>
sposób na to, aby sprawdziæ czy warto¶æ rejestru nie jest zerem.</P>






<BR><BR>
<HR>
<h2 class="nag"><a name="linux1302" id="linux1302">Instrukcja OR</a></h2>

	<BR><a href="#linux1303" class="bezdruk">(przeskocz OR)</a>


<P>
Instrukcja <code>OR</code> (logiczna alternatywa) w prosty sposób s³u¿y do ustawiania bitów
 (wpisywania do nich 1).
<BR>Tabelka dzia³ania wygl±da nastêpuj±co:</P>
<PRE title="dzia³anie OR">
	0 OR 0 = 0
	0 OR 1 = 1
	1 OR 0 = 1
	1 OR 1 = 1</PRE>

<P>Je¶li na przyk³ad chcemy, aby 2 najm³odsze bity rejestru BX by³y siê równe 1, a nie chcemy naruszaæ
innych bitów (czyli <code>MOV</code> jest wykluczone), mo¿emy to zrobiæ tak:</P>
<PRE>	or	bx, 0000 0000 0000 0011		; (or bx, 3)</PRE>
<P>Zastosowanie tego jest proste. Podam 2 przyk³ady. Pierwszy z nich jest wyjêty z mojej procedury
wytwarzaj±cej d¼wiêk w g³o¶niczku (i kursu po¶wiêconego temu zagadnieniu):</P>
<PRE>
	in	al, 61h
	or	al, 3				; ustawiamy bity 0 i 1
	out	61h, al</PRE>

<P>Przyk³ad drugi jest odwróceniem operacji <code>AND</code> na znakach ASCII:</P>
<PRE>
	mov	al, &quot;A&quot;
	or	al, 20h			; 20h = 0010 0000 - ustawiamy bit 5</PRE>

<P>teraz w AL powinien byæ kod ma³ej literki a.
<BR>
Instrukcja <code>OR</code> nie ma swojego odpowiednika, jakim jest <code>TEST</code> dla <code>AND</code>.
Ale za to ma inne ciekawe zastosowanie - mo¿na ni± sprawdziæ, czy 2 rejestry naraz nie s± zerami (to jest
<em class="wazne">najlepszy</em> sposób - bez ¿adnych <code>CMP</code>, <code>JNZ/JZ</code> itp.):</P>
<PRE>	or	ax, bx</PRE>
<P>Podobnie, jak w instrukcji <code>AND</code>, flaga zera bêdzie ustawiona, gdy wynik operacji jest zerem - a
to mo¿e siê zdarzyæ tylko wtedy, gdy AX i BX s± <em class="wazne">jednocze¶nie</em> zerami.
<BR> Zauwa¿cie, ¿e nie mo¿na do tego celu u¿yæ instrukcji <code>AND</code>. Dlaczego? Podam
przyk³ad: niech AX=1 i BX = 8. AX i BX nie s± oczywi¶cie równe zero, ale:
<PRE>
		0000 0000 0000 0001	(=AX)
	AND	0000 0000 0000 1000	(=BX)
		=
		0000 0000 0000 0000</PRE>

<P>Dlatego zawsze nale¿y przemy¶leæ efekt dzia³ania instrukcji.</P>






<BR><BR>
<HR>
<h2 class="nag"><a name="linux1303" id="linux1303">Instrukcja XOR</a></h2>

	<BR><a href="#linux1304" class="bezdruk">(przeskocz XOR)</a>

<P>
Instrukcji <code>XOR</code> (<span lang="en">eXclusive OR</span>, logiczna alternatywa wykluczaj±ca)
 u¿ywa siê do zmiany stanu okre¶lonego bitu z 0 na 1 i odwrotnie.
<BR>
Dzia³anie XOR jest okre¶lone tak:</P>
<PRE title="dzia³anie XOR">
	0 XOR 0 = 0
	0 XOR 1 = 1
	1 XOR 0 = 1
	1 XOR 1 = 0</PRE>

<P>Zauwa¿my tak¿e, ¿e dla dowolnych a i b mamy:<BR>
(a XOR b) XOR b = a<BR>
a XOR 0 = a<BR>
a XOR -1 = NOT a (-1 = FF w bajcie, FFFF w s³owie i FFFFFFFF w dwordzie)<BR>
a XOR a = 0<BR>
Z tej ostatniej równo¶ci wynika natychmiast, ¿e wyXORorwanie rejestru z samym sob± zawsze go
wyzeruje. W ten sposób otrzymujemy jeden z dwóch <em class="wazne">najwydajniejszych</em> sposobów na
wyzerowanie rejestru:</P>
<PRE>	xor	rej, rej</PRE>

<P>Drugi sposób to <code><span lang="en">SUB</span> rej,rej</code>.</P>
<P>
Teraz przyk³ad: chcemy, aby warto¶æ rejestru AX sta³a siê równa
1 gdy rejestr by³ wyzerowany, a zerem, gdy by³a w tym rejestrze jedynka. Oto, jak mo¿emy to
zrobiæ:</P>
<PRE>
		cmp	ax, 1
		je	wyzeruj
		mov	ax, 1
		jmp	koniec
	wyzeruj:
		mov	ax, 0
	koniec:</PRE>

<P>Ale wersja optymalna wygl±da tak:</P>
<PRE>	xor	ax, 1</PRE>

<P>gdy¿ mamy:</P>
<PRE>
	warto¶æ AX:	0000 0000 0000 0001		0000 0000 0000 0000
		XOR	0000 0000 0000 0001		0000 0000 0000 0001
		=
	nowy AX:	0000 0000 0000 0000		0000 0000 0000 0001</PRE>

<P>Jak widaæ, jest to o wiele prostsze i wydajniejsze rozwi±zanie. Dlatego w³a¶nie dobrze jest,
gdy pozna siê instrukcje logiczne.</P>






<BR><BR>
<HR>
<h2 class="nag"><a name="linux1304" id="linux1304">Instrukcje przesuwania bitów</a></h2>

	<BR><a href="#linux1305" class="bezdruk">(przeskocz instrukcje przesuwania)</a>

<P>
Instrukcje przesuwania bitów (<q lang="en">shift</q>) przemieszczaj± bity, nie zmieniaj±c ich wzajemnego
po³o¿enia (przesuwaj± <q>grupowo</q>). To wyja¶nienie mo¿e siê wydawaæ bardzo pokrêtne, ale
spokojnie - zaraz wszystko siê wyja¶ni.<BR>
Na pocz±tek powiem, ¿e jest kilka takich instrukcji (które te¿ by³y podane w rozdziale
o podstawowych instrukcjach procesora):</P>
<UL>
 <LI><code>SHL</code> - <span lang="en">shift left (shift logical left)</span> = przesuniêcie (logicznie) w lewo</LI>
 <LI><code>SAL</code> - <span lang="en">shift arithmetic left</span> = przesuniêcie (arytmetycznie) w lewo</LI>
 <LI><code>SHR</code> - <span lang="en">shift logical right</span> = przesuniêcie (logiczne) w prawo</LI>
 <LI><code>SAR</code> - <span lang="en">shift arithmetic right</span> = przesuniêcie (arytmetyczne)</LI>
 <LI><code>SHLD/SHRD</code> = przesuniêcia logiczne w lewo/prawo o podwójnej precyzji</LI>
</UL>
<P>Dzia³anie ka¿dej z tych instrukcji poka¿ê na przyk³adzie.<BR>
Niech na pocz±tku AX = 1010 0101 1010 0101 (A5A5h).
</P>
<P>
<code>SHL</code> i równowa¿na <code>SAL</code> dzia³a tak (zak³adaj±c, ¿e przesuwamy o jeden):
najstarszy bit jest we fladze CF, ka¿dy inny bit wchodzi na miejsce bitu starszego o 1, a do bitu zerowego
 wk³adane jest zero.<br>
Po wykonaniu <code>SHL AX,3</code> warto¶æ AX bêdzie wiêc wynosiæ 0010 1101 0010 1000 (2D28h), gdy¿
wszystkie bity przesunêli¶my o 3 miejsca w lewo, oraz CF=1
(bo jako ostatnia z rejestru wylecia³a jedynka).</P>


<P>
Instrukcja <code>SHR</code> dzia³a w drug± stronê ni¿ <code>SHL</code>: bit zerowy jest umieszczany we fladze CF,
ka¿dy inny bit wchodzi na miejsce bitu m³odszego o 1, a do najstarszego bitu wk³adane jest zero.<br>
Dlatego teraz po wykonaniu <code>SHR AX,1</code> w rejestrze AX bêdzie 0001 0110 1001 0100 (1694h),
bo poprzednie bity AX przesunêli¶my o 1 miejsce w prawo, oraz CF=0.</P>
<P>
<code>SAR</code> ró¿ni siê od <code>SHR</code> nie tylko nazw±, ale te¿ dzia³aniem.
S³owo <q>arytmetyczne</q> w nazwie NIE jest tu bez znaczenia. Gdy <code>SAR</code> dzia³a na
liczbach ze znakiem, to zachowuje ich znak (bit7), czyli wykonuje to samo, co <code>SHR</code>,
ale zamiast wk³adaæ zero do najstarszego bitu, wstawia tam jego bie¿±c± warto¶æ.<br>
Z poprzedniego przyk³adu mamy, ¿e AL = 94h = 1001 0100. Gdy teraz wykonamy <code>SAR AL,2</code> to jako wynik
otrzymamy 1110 0101 (E5h), bo wszystkie bity posz³y o 2 miejsca w prawo o bit 7 zosta³
zachowany, i CF=0.
</P>

<P>
<code>SHLD</code> i <code>SHRD</code> wykonuj± to samo, co <code>SHL</code> i <code>SHR</code>,
ale na dwóch rejestrach naraz (no, prawie).
Na przyk³ad wykonanie &nbsp;<code>SHLD EAX,EBX,3</code> spowoduje ¿e 3 najstarsze bity
 EAX zostan± wyrzucone
(i CF=ostatni z wyrzuconych) oraz 3 najstarsze bity EBX przejd± na nowo powsta³e miejsca w
3 najm³odszych bitach EAX. Ale uwaga: EBX pozostaje <em class="wazne">niezmieniony</em> !
 I to jest w³a¶nie przyczyna u¿ycia s³ów <q>no prawie</q>.
</P>

<P>
Ale nie sposób powiedzieæ o <code>SHL</code> i <code>SHR</code> bez podania najbardziej popularnego
zastosowania: <span class="b">szybkie mno¿enie i dzielenie</span>.<BR>
Jak mo¿na mno¿yæ i dzieliæ tylko przesuwaj±c bity, pytacie?<BR>
Otó¿, sprawa jest bardzo prosta. Wpiszcie do AX jedynkê i wykonajcie kilka razy SHL AX,1 za
ka¿dym razem sprawdzaj±c zawarto¶æ AX. Jak zauwa¿ycie, w AX bêd± kolejno 1,2,4,8,16,... Czyli
za ka¿dym razem zawarto¶æ AX siê podwaja.<BR>
Ogólnie, &nbsp;<code>SHL rej,n</code> mno¿y zawarto¶æ rejestru przez 2^n.
 Na przyk³ad &nbsp;<code>SHL AX,4</code> przemno¿y AX
przez 2^4 = 16.<BR>
Ale co zrobiæ, gdy chcemy mno¿yæ przez co¶ innego ni¿ 2^n?<BR>
Odpowied¼ jest równie prosta, na przyk³ad AX * 10 = (AX*8) + (AX*2) - z tym siê chyba zgodzicie. A od tego
ju¿ tylko 1 krok do</P>
<PRE>
	mov	bx, ax
	shl	ax, 3		; AX = AX*8
	shl	bx, 1		; BX = BX*2 = AX*2
	add	ax, bx		; AX = AX*10</PRE>

<P>Ale niekoniecznie musimy dodawaæ wyniki. Zauwa¿cie, ¿e AX * 15 = (AX*8) + (AX*4) + (AX*2) + AX.
Trzeba by³oby wykonaæ 3 <code>SHL</code> i 3 <code>ADD</code>. Ale my skorzystamy z innego rozwi±zania:
AX * 15 = (AX*16) - AX. Ju¿ tylko 1 <code>SHL</code> i 1 <code>SUB</code>. St±d mamy:</P>
<PRE>
	mov	bx, ax
	shl	ax, 4		; AX = AX*16
	sub	ax, bx</PRE>

<P>
Dok³adnie w ten sam sposób dzia³a dzielenie (tylko oczywi¶cie przy dzieleniu u¿ywamy <code>SHR/SAR</code>
i niestety szybko mo¿emy dzieliæ tylko przez potêgi dwójki).
Pilnujcie tylko, aby u¿ywaæ tej w³a¶ciwej instrukcji! Jak wiemy, 65534 = 0FFFEh = -2 .
Teraz, oczywi¶cie FFFE SHR 1 = 7FFFh = 32767 (=65534/2)  a FFFE SAR 1 = FFFF = -1 (= -2/2).
Widaæ ró¿nicê, prawda? Pamiêtajcie, ¿e SAR patrzy na znak i go zachowuje.
</P>
<P>
U¿ywanie <code>SHL</code> dla mno¿enia i (zw³aszcza) <code>SHR</code> dla dzielenia mo¿e znacznie
przy¶pieszyæ nasze programy, gdy¿ instrukcje <code>MUL</code> i <code>DIV</code> s± do¶æ wolne.</P>





<BR><BR>
<HR>
<h2 class="nag"><a name="linux1305" id="linux1305">Instrukcje rotacji bitów</a></h2>

	<BR><a href="#linux1306" class="bezdruk">(przeskocz instrukcje rotacji)</a>


<P>
Teraz przedstawiê kolejn± grupê instrukcji bitowych - instrukcje rotacji bitów. W tej grupie
s± tylko 4 instrukcje:</P>
<UL>
 <LI><code>ROL</code> - <span lang="en">rotate left</span> = obrót w lewo.<br>
 	<P>Ta instrukcja robi tyle, co <code>SHL</code>, lecz zamiast do bitu zerowego wk³adaæ zero, wk³ada tam
 	bie¿±c± warto¶æ najstarszego bitu (przy okazji zachowuj±c go tak¿e we fladze CF).<br>
 	bit7 = bit6, ... , bit1 = bit0, bit0 = stary bit7
 	</P></LI>
 <LI><code>RCL</code> - <span lang="en">rotate through carry left</span> = obrót w lewo z u¿yciem flagi CF.
 	<P>Ta instrukcja jest podobna do <code>ROL</code> z jedn± ró¿nic±: warto¶æ wstawiana do najm³odszego bitu
 	jest brana z flagi CF, a nie od razu z najstarszego bitu. Po wziêciu bie¿±cej warto¶ci
 	CF, najstarszy bit jest do niej zapisywany.<br>
 	<span lang="en">carry flag</span> CF = bit7, bit7 = bit6, ... , bit1 = bit0, bit0 = stara CF
 	</P></LI>
 <LI><code>ROR</code> - <span lang="en">rotate right</span> = obrót w prawo.
 	<P>Ta instrukcja robi tyle, co <code>SHR</code>, lecz zamiast do najstarszego bitu wk³adaæ zero,
	wk³ada tam bie¿±c± warto¶æ najm³odszego bitu (przy okazji zachowuj±c go tak¿e we fladze CF).<br>
 	bit0 = bit1, ... , bit6 = bit7, bit7 = stary bit0
 	</P></LI>
 <LI><code>RCR</code> - <span lang="en">rotate through carry right</span> = obrót w prawo z u¿yciem flagi CF.
 	<P>Ta instrukcja jest podobna do <code>ROR</code> z jedn± ró¿nic±: warto¶æ wstawiana do najstarszego bitu
 	jest brana z flagi CF, a nie od razu z najm³odszego bitu. Po wziêciu bie¿±cej warto¶ci
 	CF, najm³odszy bit jest do niej zapisywany.<br>
 	CF = bit0, bit0 = bit1, ... , bit6 = bit7, bit7 = stara CF
 	</P></LI>
</UL>
<P>Schematyczne dzia³anie tych instrukcji na bajtach widaæ na tych rysunkach:</P>
	<BR><a href="#linux1306_2" class="bezdruk">(przeskocz rysunki)</a>
<PRE class="asciiart">
	ROL:
			+--&gt;-------------&gt;--------------&gt;--+
			|				   |
		CF &lt;-	7 &lt;- 6 &lt;- 5 &lt;- 4 &lt;- 3 &lt;- 2 &lt;- 1 &lt;- 0

	RCL:
			+--&gt;-----------&gt; CF &gt;-----------&gt;--+
			|				   |
			7 &lt;- 6 &lt;- 5 &lt;- 4 &lt;- 3 &lt;- 2 &lt;- 1 &lt;- 0

	ROR:
			+--&lt;-------------&lt;--------------&lt;--+
			|				   |
			7 -&gt; 6 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 0   -&gt; CF

	RCR:
			+--&lt;-----------&lt; CF &lt;-----------&lt;--+
			|				   |
			7 -&gt; 6 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 0</PRE>

<P><a name="linux1306_2" id="linux1306_2">W przypadku <code>ROL</code> i <code>ROR</code></a>,
 to <em class="wazne">ostatni</em> wyjêty z jednej strony
 a w³o¿ony z drugiej strony bit
zostaje te¿ zapisany do flagi CF.<BR>
<code>RCR</code> i <code>RCL</code> dzia³aj± tak, ¿e bit, który ma zostaæ wstawiony, jest pobierany z CF, a
wypchniêty bit l±duje w CF, a nie od razu na nowym miejscu.
</P>
<P>No to kilka przyk³adów:</P>
<PRE>
	0011 1100  ROL  2  =  1111 0000  (tak samo jak SHL)
	0011 1100  ROL  3  =  1110 0001

	1111 0000  ROR  1  =  0111 1000  (tak samo jak SHR)
	1010 0011  ROR  5  =  0001 1101</PRE>

<P>Zastosowanie tych instrukcji znalaz³em jedno: generowanie chaosu w rejestrach...<BR>
Po co to mi? Na przyk³ad generatory liczb pseudo-losowych z mojej biblioteki korzystaj± z
tych w³a¶nie instrukcji (a tak¿e z kilku poprzednich, na przyk³ad <code>XOR</code>).</P>







<BR><BR>
<HR>
<h2 class="nag"><a name="linux1306" id="linux1306">Instrukcje testowania i szukania bitów</a></h2>

	<BR><a href="#linux1307" class="bezdruk">(przeskocz instrukcje BT*)</a>


<P>
Ostatnia ju¿ grupa rozkazów procesora to instrukcje testowania i szukania bitów. W tej grupie
znajduj± siê:</P>
<UL>
 <LI><code>BT</code> - <span lang="en">Bit Test</span></LI>
 <LI><code>BTC</code> - <span lang="en">Bit Test and Complement</span></LI>
 <LI><code>BTR</code> - <span lang="en">Bit Test and Reset</span></LI>
 <LI><code>BTS</code> - <span lang="en">Bit Test and Set</span></LI>
 <LI><code>BSF</code> - <span lang="en">Bit Scan Forward</span></LI>
 <LI><code>BSR</code> - <span lang="en">Bit Scan Reverse</span></LI>
</UL>
<P>Teraz po kolei omówiê dzia³anie ka¿dej z nich.</P>
<P>
Instrukcje <code>BT*</code> przyjmuj± 2 argumenty: miejsce, gdzie maj± znale¼æ dany bit i numer tego bitu,
a zwracaj± warto¶æ tego bitu we fladze CF. Ponadto, <code>BTS</code> ustawia znaleziony bit na 1, <code>BTR</code>
czy¶ci znaleziony bit a <code>BTC</code> odwraca znaleziony bit.<BR>
Kilka przyk³adów:</P>
<PRE>
	bt	eax, 21		; umie¶æ 21. bit EAX w CF
	jc	bit_jest_1
	...
	bts	cl, 2		; umie¶æ 2. bit CL w CF i ustaw go
	jnc	bit_2_byl_zerem
	...
	btc	dh, 5		; umie¶æ 5. bit DH w CF i odwróæ go
	jc	bit_5_byl_jeden	</PRE>

<P>Instrukcje <span lang="en">Bit Scan</span> przyjmuj± 2 argumenty: pierwszy z nich to rejestr, w którym bêdzie
umieszczona pozycja (numer od zera pocz±wszy) pierwszego bitu, którego warto¶æ
jest równa 1 znalezionego w drugim argumencie instrukcji. Dodatkowo, <code>BSF</code> szuka tego pierwszego
bitu zaczynaj±c od bitu numer 0, a <code>BSR</code> od najstarszego (numer 7, 15 lub 31 w zale¿no¶ci od
rozmiaru drugiego argumentu).
</P><P>
Teraz szybki przyk³adzik:</P>
<PRE>
	mov	ax, 1010000b
	bsf	bx, ax
	bsr	cx, ax</PRE>

<P>Po wykonaniu powy¿szych instrukcji w BX powinno byæ 4, a w CX - 6 (bity liczymy od zera).</P>

<BR><hr>

<P>
<a name="linux1307" id="linux1307">Jak pewnie zauwa¿yli¶cie, w kilku miejscach</a>
 w tym tek¶cie wyra¼nie podkre¶li³em s³owa
<q>najwydajniejszy</q> i im podobne. Chcia³em w ten sposób uzmys³owiæ Wam, ¿e operacje logiczne
/ binarne s± bardzo wa¿n± grup± instrukcji. U¿ywanie ich, najlepiej wraz z instrukcj± LEA
s³u¿±c± do szybkich rachunków, mo¿e kilkakrotnie (lub nawet kilkunastokrotnie) przy¶pieszyæ
najwa¿niejsze czê¶ci Waszych programów (na przyk³ad intensywne obliczeniowo pêtle o milionach
powtórzeñ - patrz na przyk³ad program <q>L_mag.asm</q> z 8. czê¶ci tego kursu).</P>
<P>
Dlatego zachêcam Was do dobrego opanowania instrukcji binarnych - po prostu umo¿liwia to
pisanie programów o takiej wydajno¶ci, o której inni mog± tylko pomarzyæ...
</P>
<P>Po szczegó³owy opis wszystkich instrukcji odsy³am, jak zwykle do :
<A class="intel_link" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" hreflang="en">Intela</A>
i <A class="amd_link" href="http://developer.amd.com/Resources/documentation/guides/Pages/default.aspx" hreflang="en"><acronym title="Advanced Micro Devices" lang="en">AMD</acronym></A>

</P>
<P><A HREF="http://graphics.stanford.edu/~seander/bithacks.html" hreflang="en"
	>Ciekawe operacje na bitach</a> (w jêzyku C).</P>

<br><br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="linux12.html">Poprzednia czê¶æ kursu</a> (Alt+3)<br>
<a accesskey="4" hreflang="pl" href="linux14.html">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

<BR><BR><HR>
<h2 class="nag">Æwiczenia</h2>
<OL>
 <LI>W jednej komendzie policz:
  <OL class="alfa">
   <LI>iloraz z dzielenia EDI przez 4</LI>
   <LI>resztê z dzielenia EDI przez 4</LI>
   <LI>najwiêksz± liczbê mniejsz± lub równ± EDI dziel±c± sie przez 4</LI>
  </OL>
	Wskazówka: 4 = 2^2 oraz mo¿liwe reszty z dzielenia przez 4 to
	0, 1, 2 i 3 i zajmuj± one co najwy¿ej 2 bity.<BR><BR></LI>

 <LI>W jednej komendzie:
  <OL class="alfa">
   <LI>ustaw bity 0, 11, 4 i 7 rejestru CX, nie ruszaj±c pozosta³ych</LI>
   <LI>wyczy¶æ bity 9, 2, 7 i 25 rejestru ESI, nie ruszaj±c pozosta³ych</LI>
   <LI>prze³±cz (zmieñ warto¶æ na odwrotn±) bity 16, 4, 21, 1 i 10 rejestru EAX, nie ruszaj±c pozosta³ych</LI>
   <LI>spraw, by warto¶æ rejestru AL=18h zmieni³a siê na 80h, bez instrukcji MOV</LI>
   <LI>spraw, by warto¶æ rejestru AL=18h zmieni³a siê na 81h, bez instrukcji MOV</LI>
   <LI>prze³±cz bit 23 rejestru EDX nie ruszaj±c pozosta³ych, a jego star± warto¶æ umie¶æ we fladze CF</LI>
  </OL></LI>

</OL>

</BODY></HTML>
