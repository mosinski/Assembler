<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks: opis syscall (5) </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Prev"     hreflang="pl" lang="en" href="syscall64_4.html" >
<link rel="Next"     hreflang="pl" lang="en" href="syscall64_6.html" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<link rel="alternate" type="text/html" href="przer80h_5.html"
	hreflang="pl" lang="pl" title="Funkcje x86-32: 201-250">

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kursy programowania w assemblerze - opis syscall">
<META NAME="Keywords" CONTENT="Assembler, asembler, kurs, nauka, linux, syscall, linuks">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Sun, Sep 16 2012 12:57:59 CEST">
</HEAD><BODY>

<h1 class="nag">Opis funkcji systemowych <span lang="en">syscall</span>: 201-250</h1>

<P>
Je¶li jaka¶ funkcja zakoñczy siê b³êdem, w RAX zwracana jest warto¶æ ujemna z przedzia³u
od -4096 do -1 w³±cznie.</P>
<P>
Z drugiej strony, opisy funkcji na stronach manuala mówi±, ¿e zwracane jest -1,
a warto¶æ b³êdu jest zapisywana do zmiennej errno z biblioteki GLIBC. Dzieje siê tak
tylko w przypadku, gdy korzystamy z interfejsu jêzyka C (czyli deklarujemy i
uruchamiamy zewnêtrzne funkcje odpowiadaj±ce wywo³aniom systemowym i linkujemy
nasz program z bibliotek± jêzyka C), a nie bezpo¶rednio z wywo³añ systemowych (czyli
<span lang="en">syscall</span>).
</P>
<P>
Najbardziej aktualne informacje o funkcjach systemowych mo¿na znale¼æ zazwyczaj
w sekcji 2 (lub 3) manuala, na przyk³ad <code class="b">man 2 open</code>.
</P>
<P>
Najnowsze wersje j±dra mo¿na znale¼æ na <A HREF="http://www.kernel.org" hreflang="en"
>www.kernel.org</A>, a pliki z list± funkcji i ich numerów s± pod ¶cie¿kami:
</P>
<ul>
 <li>arch/x86/include/asm/unistd_64.h (w starszych wersjach kodów)</li>
 <li>arch/x86/syscalls/syscall_64.tbl (w wersjach bie¿±cych)</li>
</ul>

<P>
Najnowsze wersje stron manuala mo¿na znale¼æ tu: <A HREF="http://www.kernel.org/pub/linux/docs/man-pages/"
	>www.kernel.org/pub/linux/docs/man-pages</A>.
</P>
<P>
Napis ASCIIZ oznacza ³añcuch znaków
 <acronym title="American Standard Code for Information Interchange" lang="en">ASCII</acronym>
 zakoñczony znakiem/bajtem Zerowym.
</P>
<P>
Je¶li potrzeba, przy ka¿dej funkcji jest odno¶nik do opisu argumentów i innych
 <A HREF="dodatk80.html" hreflang="pl" tabindex="1">dodatkowych informacji</a>: typów danych,
 warto¶ci b³êdów, mo¿liwych warto¶ci parametrów itp.
</P>

<TABLE summary="Ta tabela opisuje funkcje od 201 do 250 linuksowego wywo³ania systemowego syscall">
<CAPTION> Podstawowe funkcje <span lang="en">syscall</span>: 201-250</CAPTION>
<thead>
<TR><TH style="WIDTH:5%;" id="rax">Numer/ RAX</TH>
	<TH style="WIDTH:20%;" id="opis">Opis</TH>
	<TH id="arg">Argumenty</TH><TH style="WIDTH:30%;" id="ret">Zwraca</TH></TR>

</thead><tbody>
<TR class="c">  <TD headers="rax"><a name="x64f201">201</a><br> </td>
	<TD headers="opis"> Pobierz czas (<span lang="en">sys_time</span>)  <br> </td>
	<TD headers="arg">RDI = NULL lub adres bufora, który otrzyma kopiê wyniku<br> </td>
	<TD headers="ret">RAX = liczba sekund od 1 Stycznia 1970 minus 1<BR>RAX = b³±d EFAULT<hr> <br> </td></TR>

<TR class="c">  <TD headers="rax"><a name="x64f202">202</a><br> </td>
	<TD headers="opis"> Szybka funkcja blokowania (<span lang="en">sys_futex</span>)  <br> </td>
	<TD headers="arg">RDI = sprawdzany adres<BR>
		RSI = <A HREF="dodatk80.html#futex">operacja</A><BR>
		RDX = warto¶æ<BR>
		R10 = adres struktury <A HREF="dodatk80.html#timespec">timespec</A> (czas oczekiwania) lub 0<br> </td>
	<TD headers="ret"> RAX zale¿y od operacji <BR>RAX = b³±d EINVAL, EFAULT <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f203">203</a><br> </td>
	<TD headers="opis"> Ustaw maskê procesorów dla procesu (<span lang="en">sys_sched_setaffinity</span>)  <br> </td>
	<TD headers="arg">RDI = PID procesu, którego maskê ustawiamy (0=bie¿±cy)<BR>
		RSI = d³ugo¶æ maski pod [RDX]<BR>
		RDX = adres maski bitowej. Najm³odszy bit maski oznacza, czy proces mo¿e byæ wykonany na pierwszym procesorze logicznym i tak dalej<br> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = b³±d EINVAL, EFAULT, ESRCH, EPERM <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f204">204</a><br> </td>
	<TD headers="opis"> Pobierz maskê procesorów dla procesu (<span lang="en">sys_sched_getaffinity</span>)  <br> </td>
	<TD headers="arg">RDI = PID procesu, którego maskê pobieramy (0=bie¿±cy)<BR>
		RSI = d³ugo¶æ maski pod [RDX]<BR>
		RDX = adres maski bitowej. Najm³odszy bit maski oznacza, czy proces mo¿e byæ wykonany na pierwszym procesorze logicznym i tak dalej<br> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = b³±d EINVAL, EFAULT, ESRCH, EPERM <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f205">205</a><br> </td>
	<TD headers="opis"> Ustaw wpis w obszarze lokalnym w±tku TLS (<span lang="en">sys_set_thread_area</span>)  <br> </td>
	<TD headers="arg">RDI = adres struktury <A HREF="dodatk80.html#user_desc">user_desc</A> <br> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = -EINVAL, -EFAULT, -ESRCH <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f206">206</a><br> </td>
	<TD headers="opis"> Utwórz asynchroniczny kontekst we/wy (<span lang="en">sys_io_setup</span>)  <br> </td>
	<TD headers="arg">RDI = liczba zdarzeñ, które kontekst mo¿e otrzymaæ<BR>
 		RSI = adres DWORDa (o warto¶ci zero), który otrzyma uchwyt do nowego kontekstu<br> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = b³±d -EINVAL, -EFAULT, -ENOSYS, -ENOMEM, -EAGAIN <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f207">207</a><br> </td>
	<TD headers="opis"> Zniszcz asynchroniczny kontekst we/wy (<span lang="en">sys_io_destroy</span>)  <br> </td>
	<TD headers="arg">RDI = uchwyt do usuwanego kontekstu<br> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = b³±d -EINVAL, -EFAULT, -ENOSYS <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f208">208</a><br> </td>
	<TD headers="opis"> Pobierz zdarzenia we/wy (<span lang="en">sys_io_getevents</span>)  <br> </td>
	<TD headers="arg">RDI = uchwyt do kontekstu <BR>
		RSI = minimalna liczba zdarzeñ do pobrania<BR>
		RDX = maksymalna liczba zdarzeñ do pobrania<BR>
		R10 = adres tablicy struktur <A HREF="dodatk80.html#io_event">io_event</A> <BR>
		R8 = adres struktury <A HREF="dodatk80.html#timespec">timespec</A> (czas oczekiwania) lub 0<br> </td>
	<TD headers="ret"> RAX = liczba odczytanych zdarzeñ <BR>RAX = b³±d -EINVAL, -EFAULT, -ENOSYS <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f209">209</a><br> </td>
	<TD headers="opis"> Wy¶lij zdarzenia we/wy do przetworzenia (<span lang="en">sys_io_submit</span>)  <br> </td>
	<TD headers="arg">RDI = uchwyt do kontekstu <BR>
		RSI = liczba adresów struktur pod [RDX]<BR>
		RDX = adres tablicy adresów struktur <A HREF="dodatk80.html#iocb">iocb</A> opisuj±cych zdarzenia do przetworzenia <br> </td>
	<TD headers="ret"> RAX = liczba wys³anych bloków we/wy <BR>RAX = b³±d -EINVAL, -EFAULT, -ENOSYS, -EBADF, -EAGAIN <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f210">210</a><br> </td>
	<TD headers="opis"> Przerwij operacjê we/wy (<span lang="en">sys_io_cancel</span>)  <br> </td>
	<TD headers="arg">RDI = uchwyt do kontekstu <BR>
		RSI = adres struktury <A HREF="dodatk80.html#iocb">iocb</A>, opisuj±cej operacjê do przerwania<BR>
		RDX = adres struktury <A HREF="dodatk80.html#io_event">io_event</A>, która otrzyma przerwane dzia³anie<br> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = b³±d -EINVAL, -EFAULT, -ENOSYS, -EBADF, -EAGAIN <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f211">211</a><br> </td>
	<TD headers="opis"> Pobierz wpis w obszarze lokalnym w±tku TLS (<span lang="en">sys_get_thread_area</span>)  <br> </td>
	<TD headers="arg">RDI = adres struktury <A HREF="dodatk80.html#user_desc">user_desc</A> <br> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = b³±d EINVAL, EFAULT <hr> <br> </td> </TR>

<TR class="c"> <TD headers="rax"><a name="x64f212">212</a><br> </td>
	<TD headers="opis"> Pobierz ¶cie¿kê wej¶cia do katalogu (<span lang="en">sys_lookup_dcookie</span>)  <br> </td>
	<TD headers="arg"> RDI? = warto¶æ opisuj±ca wpis o katalogu<BR>
 		RSI? = adres bufora, który otrzyma ¶cie¿kê <BR>
		RDX? = d³ugo¶æ tego bufora<br> </td>
	<TD headers="ret"> RAX = d³ugo¶æ ¶cie¿ki <BR> RAX = b³±d ENAMETOOLONG, EPERM, EINVAL, ENOMEM, ERANGE, EFAULT <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f213">213</a><br> </td>
	<TD headers="opis"> Utwórz deskryptor pliku epoll (<span lang="en">sys_epoll_create</span>)  <br> </td>
	<TD headers="arg"> RDI = liczba deskryptorów do zarezerwowania<br> </td>
	<TD headers="ret"> RAX = nowy deskryptor pliku <BR> RAX = b³±d ENOMEM, EINVAL, EMFILE, ENFILE <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f214">214</a><br> </td>
	<TD headers="opis"> <span lang="en">sys_epoll_ctl_old</span> <br> </td>
	<TD headers="arg"> <span class="b">niezaimplementowane</span> </td>
	<TD headers="ret"> zawsze RAX = ENOSYS <hr> <br> </td></TR>

<TR class="c">  <TD headers="rax"><a name="x64f215">215</a><br> </td>
	<TD headers="opis"> <span lang="en">sys_epoll_wait_old</span> <br> </td>
	<TD headers="arg"> <span class="b">niezaimplementowane</span> </td>
	<TD headers="ret"> zawsze RAX = ENOSYS <hr> <br> </td></TR>

<TR class="c">  <TD headers="rax"><a name="x64f216">216</a><br> </td>
	<TD headers="opis"> Przemapuj strony pamiêci / stwórz nieliniowe mapowanie pliku (<span lang="en">sys_remap_file_pages</span>)  <br> </td>
	<TD headers="arg"> RDI = pocz±tkowy adres stron pamiêci<BR>
 		RSI = rozmiar przemapowywanego obszaru pamiêci <BR>
		RDX = 0 (ju¿ nieu¿ywane, musi byæ 0) <BR>
		R10 = offset w pliku mierzony w jednostkach strony systemowej<BR>
		R8 = flagi (znaczenie takie, jak w <span lang="en">sys_mmap</span>, ale tu tylko MAP_NONBLOCK jest uznawane)<br> </td>
	<TD headers="ret"> RAX = 0 <BR> RAX = b³±d EINVAL <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f217">217</a><br> </td>
	<TD headers="opis"> Pobierz wpisy o katalogach, wersja 64-bitowa (<span lang="en">sys_getdents64</span>)  <br> </td>
	<TD headers="arg"> RDI = deskryptor otwartego katalogu<BR>
	        RSI = adres obszaru pamiêci na struktury <A HREF="dodatk80.html#dirent">dirent</A><BR>
		RDX = rozmiar obszaru pamiêci pod [RSI]<br> </td>
	<TD headers="ret"> RAX = 0<BR>RAX = b³±d EBADF, EFAULT, EINVAL, ENOENT, ENOTDIR <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f218">218</a><br> </td>
	<TD headers="opis"> Utwórz wska¼nik do ID w±tku (<span lang="en">sys_set_tid_address</span>) <br> </td>
	<TD headers="arg"> RDI = wska¼nik (adres), na którego warto¶æ ma byæ ustawiona zmienna
		 <span lang="en">clear_child_tid</span> j±dra<br> </td>
	<TD headers="ret"> RAX = PID bie¿±cego procesu<hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f219">219</a><br> </td>
	<TD headers="opis"> Wywo³aj ponownie (<span lang="en">sys_restart_syscall</span>) <br> </td>
	<TD headers="arg"> brak </td>
	<TD headers="ret"> to, co zwróci ponowione wywo³anie systemowe <hr> <br> </td></TR>

<TR class="c">  <TD headers="rax"><a name="x64f220">220</a><br> </td>
	<TD headers="opis"> Operacja na semaforze z czasem (<span lang="en">sys_semtimedop</span>) <br> </td>
	<TD headers="arg"> RDI = identyfikator zestawu semaforów<BR>
		RSI = adres tablicy struktur <A HREF="dodatk80.html#sembuf">sembuf</a><BR>
		RDX = liczba elementów w tablicy spod RSI<br>
		R10 = adres struktury <A HREF="dodatk80.html#timespec">timespec</a>, zawieraj±cej maksymalny czas oczekiwania </td>
	<TD headers="ret"> RAX = 0<BR>RAX = b³±d E2BIG, EACCES, EAGAIN, EFAULT, EFBIG, EIDRM, EINTR, EINVAL, ENOMEM, ERANGE <hr> <br> </td></TR>

<TR class="c">  <TD headers="rax"><a name="x64f221">221</a><br> </td>
	<TD headers="opis"> Zadeklaruj wzorce dostêpu (<span lang="en">sys_fadvise64_64</span>)  <br> </td>
	<TD headers="arg">RDI = deskryptor pliku <br>
		RSI = pocz±tek obszaru w pliku (offset)<br>
		RDX = d³ugo¶æ obszaru pliku<br>
		R10 = <A HREF="dodatk80.html#fadvice">wzorzec dostêpu</a> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = b³±d EBADF, ESPIPE, EINVAL<hr> <br> </td></TR>

<TR class="c">  <TD headers="rax"><a name="x64f222">222</a><br> </td>
	<TD headers="opis"> Utwórz POSIX-owy licznik czasu (<span lang="en">sys_timer_create</span>)  <br> </td>
	<TD headers="arg"> RDI = ID zegara, który bêdzie podstaw± mierzenia czasu<BR>
		RSI = 0 lub adres struktury <A HREF="dodatk80.html#sigevent">sigevent</A> <BR>
		RDX = adres zmiennej trzymaj±cej adres DWORDa, który otrzyma ID nowego zegara<br> </td>
	<TD headers="ret"> RAX = 0<BR> RAX = b³±d EAGAIN, EINVAL, ENOTSUPP<hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f223">223</a><br> </td>
	<TD headers="opis"> Nastaw POSIX-owy licznik czasu (<span lang="en">sys_timer_settime</span>)  <br> </td>
	<TD headers="arg"> RDI = ID zegara<BR>
		RSI = flagi (patrz: manual)<BR>
		RDX = adres struktury <A HREF="dodatk80.html#itimerspec">itimerspec</A> <BR>
		R10 = adres struktury <A HREF="dodatk80.html#itimerspec">itimerspec</A> <br> </td>
	<TD headers="ret"> RAX = 0<BR> RAX = b³±d EINVAL<hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f224">224</a><br> </td>
	<TD headers="opis"> Pobierz pozosta³y czas na POSIX-owym liczniku czasu (<span lang="en">sys_timer_gettime</span>)  <br> </td>
	<TD headers="arg"> RDI = ID zegara<BR>
		RSI = adres struktury <A HREF="dodatk80.html#itimerspec">itimerspec</A>, która otrzyma wynik<br> </td>
	<TD headers="ret"> RAX = 0<BR> RAX = b³±d EINVAL<hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f225">225</a><br> </td>
	<TD headers="opis"> Pobierz liczbê przekroczeñ POSIX-owego licznika czasu (<span lang="en">sys_timer_getoverrun</span>)  <br> </td>
	<TD headers="arg"> RDI = ID zegara<br> </td>
	<TD headers="ret"> RAX = liczba przekroczeñ<BR> RAX = b³±d EINVAL<hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f226">226</a><br> </td>
	<TD headers="opis"> Usuñ POSIX-owy licznik czasu (<span lang="en">sys_timer_delete</span>)  <br> </td>
	<TD headers="arg"> RDI = ID zegara<br> </td>
	<TD headers="ret"> RAX = 0<BR> RAX = b³±d EINVAL<hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f227">227</a><br> </td>
	<TD headers="opis"> Ustaw czas na danym zegarze (<span lang="en">sys_clock_settime</span>)  <br> </td>
	<TD headers="arg"> RDI = <A HREF="dodatk80.html#zegar">ID zegara</A> <BR>
		RSI = adres struktury <A HREF="dodatk80.html#timespec">timespec</A> zawieraj±cej czas do ustawienia <br> </td>
	<TD headers="ret"> RAX = 0<BR> RAX = b³±d EINVAL, EFAULT, EINVAL<hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f228">228</a><br> </td>
	<TD headers="opis"> Pobierz czas na danym zegarze (<span lang="en">sys_clock_gettime</span>)  <br> </td>
	<TD headers="arg"> RDI = <A HREF="dodatk80.html#zegar">ID zegara</A> <BR>
		RSI = adres struktury <A HREF="dodatk80.html#timespec">timespec</A>, która otrzyma czas <br> </td>
	<TD headers="ret"> RAX = 0<BR> RAX = b³±d EINVAL, EFAULT, EINVAL<hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f229">229</a><br> </td>
	<TD headers="opis"> Pobierz precyzjê danego zegara (<span lang="en">sys_clock_getres</span>)  <br> </td>
	<TD headers="arg"> RDI = <A HREF="dodatk80.html#zegar">ID zegara</A> <BR>
		RSI = adres struktury <A HREF="dodatk80.html#timespec">timespec</A> <br> </td>
	<TD headers="ret"> RAX = 0<BR> RAX = b³±d EINVAL, EFAULT, EINVAL<hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f230">230</a><br> </td>
	<TD headers="opis"> Przerwa w oparciu o dany zegar (<span lang="en">sys_clock_nanosleep</span>)  <br> </td>
	<TD headers="arg"> RDI = <A HREF="dodatk80.html#zegar">ID zegara</A> <BR>
		RSI = flagi (TIMER_ABSTIME=1) kontroluj±ce rodzaj czasu oczekiwania (wzglêdny lub nie) <BR>
		RDX = adres struktury <A HREF="dodatk80.html#timespec">timespec</A>, która zawiera czas czekania <BR>
		R10 = adres struktury <A HREF="dodatk80.html#timespec">timespec</A> (lub NULL),
			która otrzyma pozosta³y czas<br> </td>
	<TD headers="ret"> RAX = 0<BR> RAX = b³±d EINTR, EFAULT, ENOTSUPP<hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f231">231</a><br> </td>
	<TD headers="opis"> Zakoñcz wszystkie w±tki procesu (<span lang="en">sys_exit_group</span>)  <br> </td>
	<TD headers="arg"> RDI = status (kod wyj¶cia)<br> </td>
	<TD headers="ret"> nigdy nie powraca <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f232">232</a><br> </td>
	<TD headers="opis"> Czekaj na deskryptorze pliku epoll (<span lang="en">sys_epoll_wait</span>)  <br> </td>
	<TD headers="arg"> RDI = deskryptor epoll <BR>
 		RSI = adres tablicy struktur <A HREF="dodatk80.html#epoll_event">epoll_event</A> <BR>
		RDX = maksymalna liczba zdarzeñ, na które bêdziemy czekaæ <BR>
		R10 = czas czekania w milisekundach (-1 = nieskoñczono¶æ)<br> </td>
	<TD headers="ret"> RAX = liczba deskryptorów gotowych <BR> RAX = b³±d EFAULT, EINTR, EBADF, EINVAL <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f233">233</a><br> </td>
	<TD headers="opis"> Kontroluj deskryptor pliku epoll (<span lang="en">sys_epoll_ctl</span>) <br> </td>
	<TD headers="arg"> RDI = deskryptor epoll <BR>
 		RSI = kod <A HREF="dodatk80.html#epoll_op">operacji</A> <BR>
		RDX = deskryptor pliku <BR>
		R10 = adres struktury <A HREF="dodatk80.html#epoll_event">epoll_event</a> <br> </td>
	<TD headers="ret"> RAX = 0 <BR> RAX = b³±d ENOMEM, EBADF, EPERM, EINVAL <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f234">234</a><br> </td>
	<TD headers="opis"> Wy¶lij sygna³ do pojedynczego procesu (<span lang="en">sys_tgkill</span>) <br> </td>
	<TD headers="arg"> RDI = identyfikator grupy w±tków (niekoniecznie ca³ego procesu)<BR>
		RSI = identyfikator w±tku, który ma otrzymaæ sygna³<br>
		RDX = <A HREF="dodatk80.html#signal">numer sygna³u</A> do wys³ania </td>
	<TD headers="ret"> RAX = 0<BR>RAX = b³±d EINVAL, ESRCH, EPERM <hr> <br> </td></TR>

<TR class="c">  <TD headers="rax"><a name="x64f235">235</a><br> </td>
	<TD headers="opis"> Zmieñ czas dostêpu do pliku (<span lang="en">sys_utimes</span>) <br> </td>
	<TD headers="arg">RDI = adres nazwy pliku (ASCIIZ)<BR>
		RSI = adres tablicy 2 struktur <A HREF="dodatk80.html#timeval">timeval</A>, NULL gdy chcemy bie¿±cy czas.
		 Pierwsza struktura opisuje czas dostêpu, druga - czas zmiany<br> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = b³±d EACCES, ENOENT, EPERM, EROFS<hr> <br> </td></TR>

<TR class="c">  <TD headers="rax"><a name="x64f236">236</a><br> </td>
	<TD headers="opis"> <span lang="en">sys_vserver</span>  <br> </td>
	<TD headers="arg"> <span class="b">niezaimplementowane</span> <br> </td>
	<TD headers="ret"> <span class="b">zawsze RAX =  ENOSYS</span> <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f237">237</a><br> </td>
	<TD headers="opis"> Ustaw politykê dla zakresu pamiêci (<span lang="en">sys_mbind</span>)  <br> </td>
	<TD headers="arg"> RDI = adres pocz±tku obszaru<BR>
		RSI = d³ugo¶æ obszaru<BR>
		RDX = <A HREF="dodatk80.html#mbind_polityka">polityka</A><BR>
		R10 = adres DWORDa zawieraj±cego maskê bitow± wêz³ów<BR>
		R8 = d³ugo¶æ maski w bitach<BR>
		R9 = <A HREF="dodatk80.html#mbind_flagi">flagi polityki</A> <br> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = b³±d EFAULT, EINVAL, ENOMEM, EIO<hr> <br> </td></TR>

<TR class="c">  <TD headers="rax"><a name="x64f238">238</a><br> </td>
	<TD headers="opis"> Ustaw politykê pamiêci NUMA (<span lang="en">sys_set_mempolicy</span>)  <br> </td>
	<TD headers="arg"> RDI = <A HREF="dodatk80.html#mbind_polityka">polityka</A> <BR>
		RSI = adres DWORDa zawieraj±cego maskê bitow± wêz³ów<BR>
		RDX = d³ugo¶æ maski w bitach<br> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = b³±d <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f239">239</a><br> </td>
	<TD headers="opis"> Pobierz politykê pamiêci NUMA (<span lang="en">sys_get_mempolicy</span>)  <br> </td>
	<TD headers="arg"> RDI = adres DWORDa, który otrzyma politykê<BR>
		RSI = NULL lub adres DWORDa, który otrzyma maskê wêz³ów<BR>
		RDX = maksymalna d³ugo¶æ maski w bitach + 1<BR>
		R10 = sprawdzany adres, je¶li potrzebny<BR>
		R8 = NULL lub MPOL_F_ADDR=2 (wtedy bêdzie zwrócona polityka dotycz±ca podanego adresu)<br> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = b³±d <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f240">240</a><br> </td>
	<TD headers="opis"> Otwórz kolejkê wiadomo¶ci (<span lang="en">sys_mq_open</span>)  <br> </td>
	<TD headers="arg"> RDI = adres nazwy, która musi zaczynaæ siê uko¶nikiem <BR>
		RSI = <A HREF="dodatk80.html#bity_dostepu">flagi dostêpu</A><BR>
		(RDX = <A HREF="dodatk80.html#tryb">tryb</A>)<BR>
		(R10 = adres struktury <A HREF="dodatk80.html#mq_attr">mq_attr</A> lub NULL)<br> </td>
	<TD headers="ret"> RAX = deskryptor kolejki <BR>RAX = b³±d EACCES, EINVAL, EEXIST, EMFILE,
		ENAMETOOLONG, ENFILE, ENOENT, ENOMEM, ENOSPC <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f241">241</a><br> </td>
	<TD headers="opis"> Usuñ kolejkê wiadomo¶ci (<span lang="en">sys_mq_unlink</span>)  <br> </td>
	<TD headers="arg"> RDI = adres nazwy, która musi zaczynaæ siê uko¶nikiem<br> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = b³±d EACCES, ENAMETOOLONG, ENOENT <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f242">242</a><br> </td>
	<TD headers="opis"> Wy¶lij wiadomo¶æ do kolejki (<span lang="en">sys_mq_timedsend</span>)  <br> </td>
	<TD headers="arg"> RDI = deskryptor kolejki <BR>
		RSI = adres napisu - tre¶ci wiadomo¶ci<BR>
		RDX = d³ugo¶æ wiadomo¶ci<BR>
		R10 = priorytet (&lt;=32768, wiadomo¶ci o wiêkszym numerze s± przed tymi o mniejszym)<BR>
		R8 = adres struktury <A HREF="dodatk80.html#timespec">timespec</A>, opisuj±cej
			czas BEZWZGLÊDNY przedawnienia<br> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = b³±d EAGAIN, EBADF, EINTR, EINVAL, EMSGSIZE, ETIMEOUT <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f243">243</a><br> </td>
	<TD headers="opis"> Odbierz wiadomo¶æ z kolejki (<span lang="en">sys_mq_timederceive</span>)  <br> </td>
	<TD headers="arg"> RDI = deskryptor kolejki <BR>
		RSI = adres bufora na tre¶æ wiadomo¶ci<BR>
		RDX = d³ugo¶æ bufora<BR>
		R10 = NULL lub adres DWORDa, który otrzyma priorytet wiadomo¶ci<BR>
		R8 = adres struktury <A HREF="dodatk80.html#timespec">timespec</A>, opisuj±cej
			czas BEZWZGLÊDNY przedawnienia<br> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = b³±d EAGAIN, EBADF, EINTR, EINVAL, EMSGSIZE, ETIMEOUT, EBADMSG <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f244">244</a><br> </td>
	<TD headers="opis"> Powiadamianie o wiadomo¶ciach (<span lang="en">sys_mq_notify</span>)  <br> </td>
	<TD headers="arg"> RDI = deskryptor kolejki<BR>
		RSI = NULL (brak powiadomieñ) lub adres struktury <A HREF="dodatk80.html#sigevent">sigevent</a> <br> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = b³±d EBADF, EBUSY, EINVAL, ENOMEM <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f245">245</a><br> </td>
	<TD headers="opis"> <span lang="en">sys_mq_getsetattr</span>  <br> </td>
	<TD headers="arg"> <span class="b">NIE U¯YWAÆ</span><br> Interfejs do mq_getattr, mq_setattr<br> </td>
	<TD headers="ret"> brak danych <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f246">246</a><br> </td>
	<TD headers="opis"> Za³aduj nowe j±dro do pó¼niejszego uruchomienia (<span lang="en">sys_kexec_load</span>)  <br> </td>
	<TD headers="arg"> RDI = fizyczny adres, gdzie za³adowaæ j±dro<BR>
		RSI = liczba segmentów podanych w RDX<BR>
		RDX = adres tablicy struktur <A HREF="dodatk80.html#kexec_segment">kexec_segment</A><BR>
		R10 = zORowane <A HREF="dodatk80.html#kexec_flagi">flagi</A> </td>
	<TD headers="ret"> RAX = 0 <BR>RAX = b³±d EBUSY, EINVAL, EPERM <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f247">247</a><br> </td>
	<TD headers="opis"> Czekaj na zmianê stanu innego procesu (<span lang="en">sys_waitid</span>)  <br> </td>
	<TD headers="arg"> RDI = typ identyfikatora (0=czekaj na dowolnego potomka, 1=czekaj na proces o danym PID,
			2=czekaj na cz³onka grupy o danym GID)<BR>
		RSI = identyfikator: PID lub GID (niewa¿ny dla RDI=0)<BR>
		RDX = adres struktury <A HREF="dodatk80.html#siginfo">siginfo</A><BR>
		R10 = <A HREF="dodatk80.html#wait_opcje">opcje</A> opisuj±ce, na jakie zmiany czekamy<br> </td>
	<TD headers="ret"> RAX = 0, wype³niona struktura siginfo <BR>RAX = b³±d ECHILD, EINTR, EINVAL <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f248">248</a><br> </td>
	<TD headers="opis"> Dodanie klucza (<span lang="en">sys_add_key</span>)  <br> </td>
	<TD headers="arg"> RDI = adres nazwy klucza do dodania ASCIIZ<BR>
		RSI = adres opisu klucza do dodania ASCIIZ<BR>
		RDX = adres danych klucza<BR>
		R10 = d³ugo¶æ danych klucza w RDX<BR>
		R8 = identyfikator zbioru kluczy, do którego dodaæ znaleziony klucz. Mo¿na
			podaæ <A HREF="dodatk80.html#reqkey_set">specjalny zbiór</A>. </td>
	<TD headers="ret"> RAX = numer dodanego klucza<br> RAX = b³±d EACCES, EINTR, EKEYEXPIRED,
		EKEYREVOKED, ENOMEM, ENOKEY, EINVAL <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f249">249</a><br> </td>
	<TD headers="opis">Pobranie klucza (<span lang="en">sys_request_key</span>) <br> </td>
	<TD headers="arg"> RDI = adres nazwy klucza do pobrania ASCIIZ<BR>
		RSI = adres opisu klucza do pobrania ASCIIZ<BR>
		RDX = adres informacji s³u¿±cych do gfenerowania klucza, gdy go nie znaleziono (ASCIIZ)<BR>
		R10 = identyfikator zbioru kluczy, do którego dodaæ znaleziony klucz. Mo¿na
			podaæ <A HREF="dodatk80.html#reqkey_set">specjalny zbiór</A>. </td>
	<TD headers="ret"> RAX = numer znalezionego klucza<br> RAX = b³±d EACCES, EINTR, EDQUOT, EKEYEXPIRED,
		EKEYREJECTED, EKEYREVOKED, ENOMEM, ENOKEY <hr> <br> </td> </TR>

<TR class="c">  <TD headers="rax"><a name="x64f250">250</a><br> </td>
	<TD headers="opis">Zarz±dzanie kluczami (<span lang="en">sys_keyctl</span>) <br> </td>
	<TD headers="arg"> RDI = <A HREF="dodatk80.html#keyctl_cmd">polecenie</A><BR>
		ECX/RSI, EDX/RDX, ... - dalsze parametry </td>
	<TD headers="ret"> RAX = numer znalezionego klucza<br> RAX = b³±d EACCES, EDQUOT,
		EKEYEXPIRED, EKEYREJECTED, EKEYREVOKED, ENOKEY <hr> <br> </td> </TR>

</TABLE>


<br><br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="syscall64_4.html">Poprzednia czê¶æ</a> (Alt+3)<br>
<a accesskey="4" hreflang="pl" href="syscall64_6.html">Kolejna czê¶æ</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

</BODY></HTML>
