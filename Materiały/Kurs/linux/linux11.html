<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks, czê¶æ 11 - Pliki </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Prev"     hreflang="pl" lang="en" href="linux10.html" >
<link rel="Next"     hreflang="pl" lang="en" href="linux12.html" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="linux, linuks, kurs, asm, asembler, assembler, pliki, sys_open,
	sys_close, sys_read, sys_write, sys_lseek, sys_unlink">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Tue, Jan 18 2011 17:59:58 CEST">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler pod Linuksem?<BR>
	<h1 class="nag">Czê¶æ 11 - Pamiêæ jest nietrwa³a, czyli jak pos³ugiwaæ siê plikami</h1></div>

<P>
Jak wiemy, wszystkich danych nie zmie¶cimy w pamiêci. A nawet je¶li zmie¶cimy, to pozostan±
tam tylko do najbli¿szego wy³±czenia pr±du. Dlatego trzeba je zapisywaæ do pliku, a
potem umieæ je z tego pliku odczytaæ. W tej czê¶ci zajmiemy siê w³a¶nie operacjami na plikach.
</P>
<P>
Do operowania na plikach pos³u¿ymy siê kilkoma funkcjami przerwania 80h:</P>
<UL>
 <LI>EAX = 5 (<span lang="en">sys_open</span>) - otwarcie/utworzenie pliku.
	<P>EBX = adres nazwy pliku (zakoñczonej bajtem zerowym).<BR>
	ECX = flagi (atrybuty) - 0=Tylko do odczytu, 1=Tylko do zapisu, 2=Odczyt i zapis, 0100h=Utwórz.<BR>
	EDX = tryb otwarcia (rozk³ad bitów jest taki sam, jak przy uprawnieniach do pliku, w
		kolejno¶ci: zapis, odczyt, uruchomienie dla w³a¶ciciela, grupy i innych).<BR>
	W EAX funkcja zwraca deskryptor pliku.
	</P></LI>
 <LI>EAX = 8 (<span lang="en">sys_creat</span>) - utworzenie pliku.
	<P>EBX = adres nazwy pliku (zakoñczonej bajtem zerowym).<BR>
	ECX = tryb utworzenia (bity takie same jak w EDX dla EAX=5).<BR>
	W EAX funkcja zwraca deskryptor pliku.
	</P></LI>
 <LI>EAX = 3 (<span lang="en">sys_read</span>) - odczyt z pliku.
	<P>EBX = deskryptor (specjalny numerek) pliku.<BR>
	ECX = adres bufora, do	którego bêdziemy czytaæ.<BR>
	EDX = liczba bajtów do odczytania.<BR>
	W EAX funkcja zwraca liczbê odczytanych bajtów.
	</P></LI>
 <LI>EAX = 4 (<span lang="en">sys_write</span>) - zapis do pliku.
	<P>EBX = deskryptor pliku.<BR>
	ECX = adres bufora, z którego bêd± pobierane dane do zapisu.<BR>
	EDX = liczba bajtów do zapisania. Jak zapewne sobie przypominacie, tej w³a¶nie
		funkcji u¿ywali¶my do wy¶wietlania napisów na ekranie, z EBX = 1
		(1 = standardowe urz±dzenie wyj¶cia).<BR>
	W EAX funkcja zwraca liczbê zapisanych bajtów.
	</P></LI>
 <LI>EAX = 6 (<span lang="en">sys_close</span>) - zamyka plik.
	<P>EBX = deskryptor pliku.
	</P></LI>
 <LI>EAX = 19 (<span lang="en">sys_lseek</span>) - przechodzenie na okre¶lon± pozycjê w pliku.
	<P>EBX = deskryptor pliku.<BR>
	ECX = d³ugo¶æ skoku (mo¿e byæ ujemna).<BR>
	EDX mówi, sk±d wyruszamy: 0 - pocz±tek pliku, 1 - bie¿±ca pozycja w pliku,
	 2 - koniec pliku.<BR>
	Zwraca w EAX bie¿±c± pozycjê w pliku.
	</P></LI>
 <LI>EAX = 10 (<span lang="en">sys_unlink</span>) - usuwa plik.
	<P>EBX = adres nazwy pliku (zakoñczonej bajtem zerowym).<BR>
	</P></LI>
</UL>
<P>
B³êdy (podobnie jak w innych funkcjach Linuksowych) s± zwykle sygnalizowane przez EAX mniejsze od zera.<BR>
Po szczegó³y odsy³am do <a href="przer80h_1.html" hreflang="pl">mojego spisu funkcji
systemowych</a>,
 <A HREF="http://linuxasembly.org" hreflang="en" lang="en"
	>linuxasembly.org</A>,
<A HREF="http://www.lxhp.in-berlin.de/lhpsyscal.html" hreflang="en"
	>www.lxhp.in-berlin.de/lhpsyscal.html</A> oraz do stron manuala dotycz±cych
poszczególnych funkcji, na przyk³ad <span class="b">man 2 open</span>.
</P>
<P>
Przyk³adowe u¿ycie tych funkcji:</P>
	<BR><a href="#linux1101" tabindex="1" class="bezdruk">(przeskocz przyk³ady)</a>
<P>
Utworzenie pliku i zapisanie czego¶ do niego:</P>
<PRE title="przyk³ady">
	mov	eax, 8		; numer funkcji - tworzenie pliku
	mov	ebx, nazwa	; adres nazwy pliku
	mov	edx, 111111111b	; tryb otwierania - ósemkowo 777
	int	80h

	cmp	eax, 0
	jl	blad		; czy wyst±pi³ b³±d?

	mov	ebx, eax	; EBX = deskryptor pliku

	mov	eax, 4		; numer funkcji - zapis
				; EBX = deskryptor pliku
	mov	ecx, bufor	; adres bufora
	mov	edx, 1024	; liczba bajtów
	int	80h

	cmp	eax, 0
	jl	blad		; czy wyst±pi³ b³±d?

	mov	eax, 6		; numer funkcji - zamknij
				; EBX = deskryptor pliku
	int	80h

	cmp	eax, 0
	jl	blad		; czy wyst±pi³ b³±d?</PRE>

<P>Otwarcie istniej±cego pliku, odczytanie i zapisanie czego¶ do niego:</P>

<PRE title="przyk³ady">
	mov	eax, 5		; numer funkcji - otwieranie pliku
	mov	ebx, nazwa	; adres nazwy pliku
	mov	ecx, 2		; zapis i odczyt
	mov	edx, 111111111b	; tryb otwierania - ósemkowo 777
	int	80h

	cmp	eax, 0
	jl	blad		; czy wyst±pi³ b³±d?

	mov	ebx, eax	; EBX = deskryptor pliku

	mov	eax, 3		; numer funkcji - odczyt
				; EBX = deskryptor pliku
	mov	ecx, bufor	; adres bufora
	mov	edx, 1024	; liczba bajtów
	int	80h

	cmp	eax, 0
	jl	blad		; czy wyst±pi³ b³±d?

	; .... operacje na bajtach z pliku, na przyk³ad
	xor	byte [bufor], 0ffh

	mov	eax, 4		; numer funkcji - zapis
				; EBX = deskryptor pliku
	mov	ecx, bufor	; adres bufora
	mov	edx, 1024	; liczba bajtów
	int	80h

	; Zauwa¿cie, ¿e zapisane bajty wyl±dowa³y po odczytanych, gdy¿ nie
	; zmienili¶my pozycji w pliku, a ostatnia operacja (odczyt) zostawi³a
	; j± tu¿ po odczytanych bajtach

	cmp	eax, 0
	jl	blad		; czy wyst±pi³ b³±d?

	mov	eax, 6		; numer funkcji - zamknij
				; EBX = deskryptor pliku
	int	80h

	cmp	eax, 0
	jl	blad		; czy wyst±pi³ b³±d?</PRE>

<P><a name="linux1101" id="linux1101">A teraz <q>prawdziwy</q> przyk³ad</a>.
 Bêdzie to nieco uszczuplona (pomin±³em wczytywanie nazwy pliku)
wersja mojego programu <q>na_male.asm</q>. Program ten zamienia wszystkie wielkie litery w podanym
pliku na ich ma³e odpowiedniki. Reszta znaków pozostaje bez zmian.
Jedna rzecz jest warta uwagi - nigdzie nie zmieniam rejestru EBX, wiêc ci±gle w nim
jest deskryptor pliku i nie muszê tego uchwytu zapisywaæ do pamiêci.
A teraz kod:</P>
	<BR><a href="#linux1102" class="bezdruk">(przeskocz na_male.asm)</a>
<PRE title="na_male.asm">
; Program zamienia wszystkie litery w podanym pliku z wielkich na male.
;
; Autor: Bogdan D.
; kontakt: bogdandr (at) op (dot) pl
;
; nasm -O999 -f elf na_male.asm
; ld -s -o na_male na_male.o

section .text

global _start

_start:
	mov	eax, 4
	mov	ebx, 1
	mov	ecx, info
	mov	edx, info_dl
	int	80h		; wypisanie informacji o programie

	mov	eax, 5
	mov	ebx, plik
	mov	ecx, 2
	mov	edx, 111000000b	; 700 - zabroñ innym dostêpu
	int	80h

	cmp	eax, 0

	jnl	otw_ok
	call	plik_blad	; uruchamiamy tê procedurê,
				; gdy wyst±pi³ b³±d

	jmp	zamk_ok		; je¶li nie uda³o siê nam nawet
				; otworzyæ pliku, to od razu
				; wychodzimy z programu.


otw_ok:
	mov	ebx, eax	; zapisujemy deskryptor pliku
	mov	ebp, 400h	; EBP = rozmiar bufora.

czytaj:
	mov	eax, 3		; funkcja czytania
				; EBX = deskryptor
	mov	ecx, bufor	; adres bufora, dok±d czytamy
	mov	edx, ebp
	int	80h

czyt_ok:
	xor	edi, edi	; EDI bêdzie wska¼nikiem do bufora.
				; Na pocz±tku go zerujemy.

	cmp	eax, edx	; czy liczba bajtów odczytana (EAX) =
				; = liczba ¿±dana (EDX) ?
	jne	przy_eof	; je¶li nie, to plik siê skoñczy³

zamiana:
	mov	dl, [bufor+edi]	; wczytujemy znak z bufora do DL

	cmp	dl, &quot;A&quot;
	jb	znak_ok
	cmp	dl, &quot;Z&quot;
	ja	znak_ok

	or	dl, 20h		; je¶li okaza³ siê wielk± liter±,
				; zamieniamy go na ma³±
	mov	[bufor+edi],dl	; i zapisujemy w miejsce,
				; gdzie poprzednio by³

znak_ok:
	inc	edi		; przechodzimy do innych znaków
	loop	zamiana		; a¿ przejdziemy przez ca³y bufor
				; (CX = BP = 400h)

	mov	ecx, eax	; ECX = liczba przeczytanych bajtów

	mov	eax, 19		; funkcja przej¶cia do innej
				; pozycji w pliku
				; EBX = deskryptor
	neg	ecx		; ECX = - liczba przeczytanych bajtów
	mov	edx, 1		; wyruszamy z bie¿±cej pozycji
	int	80h

	cmp	eax, 0
	jnl	idz_ok
	call	plik_blad

idz_ok:				; po udanym przeskoku

	mov	eax, 4		; funkcja zapisu do pliku
				; EBX = deskryptor
	mov	ecx, bufor
	mov	edx, ebp	; EDX = EBP = 400h = d³ugo¶æ bufora.
	int	80h

	cmp	eax, 0
	jg	czytaj		; i idziemy czytaæ now± partiê danych
				; (je¶li nie ma b³êdu)

	call	plik_blad

	jmp	zamk

przy_eof:			; gdy jeste¶my ju¿ przy koñcu pliku.

;	xor	edi, edi	; EDI ju¿ = 0 (zrobione wcze¶niej)

	mov	ebp, eax	; EBP = liczba przeczytanych znaków
	mov	ecx, eax	; ECX = liczba przeczytanych znaków

zamiana2:
	mov	dl, [bufor+edi]	; pobieramy znak z bufora do DL

	cmp	dl, &quot;A&quot;
	jb	znak_ok2
	cmp	dl, &quot;Z&quot;
	ja	znak_ok2

	or	dl,20h		; je¶li okaza³ siê wielk± liter±,
				; zamieniamy go na ma³±
	mov	[bufor+edi],dl	; i zapisujemy w miejsce,
				; gdzie poprzednio by³

znak_ok2:
	inc	edi		; przechodzimy do innych znaków
	loop	zamiana2	; a¿ przejdziemy przez ca³y bufor
				; (CX = BP = liczba bajtów)

	mov	ecx, eax	; EDX = liczba przeczytanych bajtów

	mov	eax, 19		; funkcja przej¶cia do innej
				; pozycji w pliku
				; EBX = deskryptor
	neg	ecx		; ECX = - liczba przeczytanych bajtów
	mov	edx, 1		; wyruszamy z bie¿±cej pozycji
	int	80h

	cmp	eax, 0
	jnl	idz_ok2
	call	plik_blad

idz_ok2:			; po udanym przeskoku

	mov	eax, 4		; funkcja zapisu do pliku
				; EBX = deskryptor
	mov	ecx, bufor
	mov	edx, ebp	; EDX=EBP=liczba przeczytanych bajtów
	int	80h

	cmp	eax, 0
	jnl	zamk		; i zamykamy plik (je¶li nie ma b³êdu)

	call	plik_blad

zamk:
	mov	eax, 6		; zamykamy plik
				; EBX = deskryptor
	int	80h


zamk_ok:
	mov	eax, 1
	xor	ebx, ebx
	int	80h


plik_blad:			; procedura wy¶wietla informacjê
				; o tym, ¿e wyst±pi³ b³±d i
				; wypisuje numer tego b³êdu.
	push	eax
	push	ebx
	push	ecx
	push	edx
	push	ebx

	mov	eax, 4
	mov	ebx, 1
	mov	ecx, blad_plik
	mov	edx, blad_plik_dl
	int	80h		; wypisanie informacji o tym,
				; ¿e wyst±pi³ b³±d

	pop	ebx
	call	pl		; wypisanie numeru b³êdu

        mov     eax, 4
        mov     ebx, 1
        mov     ecx, nwln
        mov     edx, 1
        int     80h		; przej¶cie do nowej linii

	pop	edx
	pop	ecx
	pop	ebx
	pop	eax

	ret

pl:

piszrej:

;we: ebx - rejestr do wypisania (hex)
;wy: rejestr, niszczone: eax

	mov	eax, ebx
	shr	eax, 28
	call	pc2
	mov	eax, ebx
	shr	eax, 24
	and	al, 0fh
	call	pc2
	mov	eax, ebx
	shr	eax, 20
	and	al, 0fh
	call	pc2
	mov	eax, ebx
	shr	eax, 16
	and	al, 0fh
	call	pc2
	mov	ax, bx
	shr	ax, 12
	and	al, 0fh
	call	pc2
	mov	ax, bx
	shr	ax, 8
	and	al, 0fh
	call	pc2
	mov	al, bl
	shr	al, 4
	and	al, 0fh
	call	pc2
	mov	al, bl
	and	al, 0fh
	call	pc2

	ret

pc2:
;we: AL - cyfra hex
;wy: wy¶wietla cyfrê, niszczone: nic

	push	eax
	push	ebx
	push	ecx
	push	edx

	cmp	al, 9
	ja	hex
	or	al, &quot;0&quot;
	jmp	short pz
hex:
	add	al, &quot;A&quot;-10

pz:
	mov	[cyfra], al
	mov	eax, 4
	mov	ebx, 1
	mov	ecx, cyfra
	mov	edx, 1
	int	80h

	pop	edx
	pop	ecx
	pop	ebx
	pop	eax

	ret

section .data

align 16
bufor 		times 400h db 0		; bufor wielko¶ci jednego kilobajta
;plik 		times 80 db 0
plik		db &quot;aaa.txt&quot;,0		; nazwa pliku

info 	db &quot;Program zamienia wielkie litery w pliku na male.&quot;,10
info_dl		equ	$-info

input1		db &quot;Podaj nazwe pliku do przetworzenia: &quot;
input1_dl	equ	$-input1

zla_nazwa 	db 10, &quot;Zla nazwa pliku.&quot;
zla_nazwa_dl	equ	$-zla_nazwa

blad_plik 	db 10,&quot;Blad operacji na pliku. Kod: &quot;
blad_plik_dl	equ	$-blad_plik

cyfra		db 0
</PRE>

<P><a name="linux1102" id="linux1102">Ten program chyba nie by³ za trudny</a>, prawda?
 Ca³a tre¶æ skupia siê na odczytaniu paczki bajtów,
ewentualnej ich podmianie i zapisaniu ich w to samo miejsce, gdzie by³y wcze¶niej.
</P>
<P>
Pliki s± podstawowym sposobem przechowywania danych. My¶lê wiêc, ¿e siê ze mn± zgodzicie, i¿
opanowanie ich obs³ugi jest wa¿ne i nie jest to a¿ tak trudne, jakby siê mog³o wydawaæ.</P>

<br><br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="linux10.html">Poprzednia czê¶æ kursu</a> (Alt+3)<br>
<a accesskey="4" hreflang="pl" href="linux12.html">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>


<BR><BR><HR>
<h2 class="nag">Æwiczenia</h2>
<OL>
 <LI>Napisz program, który wykona po kolei nastêpuj±ce czynno¶ci:
  <OL class="alfa">
   <LI>Utworzy nowy plik</LI>
   <LI>Zapisze do niego 256 bajtów o warto¶ciach od 00 do FF (nie musicie zapisywaæ po 1 bajcie)</LI>
   <LI>Zamknie ten plik</LI>
   <LI>Otworzy ponownie ten sam plik</LI>
   <LI>Zapisze odczytane bajty w nowej tablicy 256 s³ów w taki sposób:
	<PRE>		00 00 00 01 00 02 00 03 00 04 .... 00 FD 00 FE 00 FF</PRE>
	czyli ka¿dy oddzielony bajtem zerowym (nale¿y przeczytaæ wszystkie bajty, po czym rêcznie
	je przenie¶æ gdzie indziej i <q>wzbogaciæ</q>)</LI>
   <LI>Zamknie otwarty plik</LI>
   <LI>Usunie ten plik</LI>
  </OL>
 </LI>
</OL>

</BODY></HTML>
