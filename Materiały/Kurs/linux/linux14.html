<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: Linuks, czê¶æ 14 - Wielokrotna precyzja </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm" >
<link rel="Prev"     hreflang="pl" lang="en" href="linux13.html" >
<link rel="Next"     hreflang="pl" lang="en" href="linux15.html" >
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm" >

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="kurs, asm, asembler, assembler, linux, linuks">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Mon, Jul 4 2011 18:29:36 CEST">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler pod Linuksem?<BR>
	<h1 class="nag">Czê¶æ 14 - Wielokrotna precyzja, czyli co robiæ,
		gdy dane nie mieszcz± siê w rejestrach</h1></div>


<P>
Czasami w naszych programach zachodzi potrzeba, aby pos³ugiwaæ siê na przyk³ad liczbami przekraczaj±cymi
4 czy nawet 8 bajtów, a my mamy tylko rejestry 32-bitowe (lub czasem 16-bitowe).<BR>
Co wtedy zrobiæ?<BR>
Odpowiedzi na to w³a¶nie pytanie postaram siê udzieliæ w tej czê¶ci kursu.
</P>

<P>
Do naszych celów pos³u¿y co¶, co siê nazywa <q>arytmetyk± wielokrotnej precyzji</q> (ang.
<span lang="en">Multiprecision Arithmetic</span>).
 Generaln± zasad± bêdzie zajmowanie siê obliczeniami <q>po kawa³ku</q>
(bo z reszt± inaczej siê nie da) i zapamiêtywanie, czy z poprzedniego kawa³ka wynie¶li¶my co¶
<q>w pamiêci</q> (do tego celu w prosty sposób wykorzystamy flagê CF, która wskazuje w³a¶nie, czy
nie nast±pi³o przepe³nienie).<BR>
Najpierw kilka ustaleñ:</P>
<OL>
 <LI>Bêdê tutaj u¿ywa³ rejestrów 32-bitowych, ale w razie potrzeby dok³adnie
	te same algorytmy dzia³aj± tak¿e dla rejestrów innych rozmiarów.</LI>
 <LI>Zmienne <q>arg1</q> i <q>arg2</q> maj± po 16 bajtów (128 bitów) ka¿da. Na potrzeby nauki
	wystarczy w sam raz.</LI>
 <LI>Zmienna <q>wynik</q> ma tyle samo bajtów, co <q>arg1</q> i <q>arg2</q>, z wyj±tkiem mno¿enia,
	gdzie oczywi¶cie musi byæ dwa razy wiêksza.</LI>
 <LI>Zmienna <q>wynik</q> na pocz±tku zawiera zero.</LI>
 <LI>Kod nie zawsze bêdzie optymalny, ale chodzi mi o to, aby by³ jak najbardziej jasny i przejrzysty.
	</LI>
</OL>
<P>A wiêc do dzie³a.</P>





<BR>
<HR>
<h2 class="nag">Dodawanie</h2>

	<BR><a href="#linux1401" tabindex="1" class="bezdruk">(przeskocz dodawanie)</a>
<P>
Dodawanie, podobnie jak uczyli nas w szkole, zaczynamy od najm³odszych
cyfr (cyfr jedno¶ci) - tyle ¿e zamiast pojedynczych cyferek bêdziemy dodawaæ ca³e 32-bitowe
kawa³ki naraz. Flaga CF powie nam, czy z poprzedniego dodawania wynosimy co¶ w pamiêci (nawet z
dodawania du¿ych liczb wyniesiemy co najwy¿ej 1 bit <q>w pamiêci</q>). To co¶
trzeba oczywi¶cie dodaæ potem do wy¿szej czê¶ci wyniku.<BR>
No to dodajemy:</P>
	<BR><a href="#linux1401" class="bezdruk">(przeskocz program do dodawania)</a>

<PRE title="dodawanie dwóch liczb">
	mov	eax, [arg1]
	add	eax, [arg2]	; dodajemy 2 pierwsze czê¶ci liczb
	mov	[wynik], eax	; i ich sumê zapisujemy w pierwszej
				; czê¶ci wyniku. Flaga CF mówi, czy
				; wynosimy co¶ w pamiêci

	mov	eax, [arg1+4]
	adc	eax, [arg2+4]	; dodajemy drugie czê¶ci + to,
				; co wysz³o z poprzedniego dodawania
				; [arg1] i [arg2] (a to jest w fladze
				; CF, st±d instrukcja ADC zamiast ADD)

	mov	[wynik+4], eax 	; ca³o¶æ:[arg1+4]+[arg2+4]+&quot;w pamiêci&quot;
				; z pierwszego dodawania zapisujemy tu
				; Flaga CF zawiera (lub nie) bit
				; &quot;w pamiêci&quot;, ale tym razem z ADC

				; podobnie reszta dzia³ania:
	mov	eax, [arg1+8]
	adc	eax, [arg2+8]
	mov	[wynik+8], eax

	mov	eax, [arg1+12]
	adc	eax, [arg2+12]
	mov	[wynik+12], eax

	jc	blad_przepelnienie</PRE>

<BR>





<BR><HR>
<h2 class="nag"><a name="linux1401" id="linux1401">Odejmowanie</a></h2>

	<BR><a href="#linux1402" class="bezdruk">(przeskocz odejmowanie)</a>
<P>
W szkole uczyli nas, ¿e zaczynamy od najm³odszych cyfr i
ewentualnie <q>po¿yczamy</q> od starszych. Tutaj bêdziemy robiæ dok³adnie tak samo! Wymaga to
jednak poznania nowej instrukcji - <code>SBB</code> (<span lang="en">Subtract with Borrow</span>).
 Dzia³a ona tak samo, jak
zwyk³a instrukcja odejmowania <code><span lang="en">SUB</span></code>, ale dodatkowo odejmuje warto¶æ
 flagi CF, czyli 1 lub 0,
w zale¿no¶ci od tego, czy w poprzednim kroku musieli¶my <q>po¿yczaæ</q> czy te¿ nie. Ewentualn±
<q>po¿yczkê</q> trzeba oczywi¶cie odj±æ od wy¿szej czê¶ci wyniku.<BR>
Piszmy wiêc (od <q>arg1</q> bêdziemy odejmowaæ <q>arg2</q>):</P>
	<BR><a href="#linux1402" class="bezdruk">(przeskocz program do odejmowania)</a>

<PRE title="odejmowanie dwóch liczb">
	mov	eax, [arg1]
	sub	eax, [arg2]             ; odejmujemy 2 pierwsze czê¶ci
	mov	[wynik], eax            ; i zapisujemy wynik
	                                ; flaga CF mówi, czy by³a po¿yczka

	mov	eax, [arg1+4]
	sbb	eax, [arg2+4]		; odejmujemy razem z po¿yczk± (CF),
	                                ; je¶li w poprzednim odejmowaniu
					; musieli¶my co¶ po¿yczaæ

	mov	[wynik+4], eax          ; wynik: [arg1+4]-[arg2+4]-po¿yczka
	                                ; z pierwszego odejmowania
					; CF teraz zawiera po¿yczkê z SBB

					; podobnie reszta dzia³ania:
	mov	eax, [arg1+8]
	sbb	eax, [arg2+8]
	mov	[wynik+8], eax

	mov	eax, [arg1+12]
	sbb	eax, [arg2+12]
	mov	[wynik+12], eax

	jc	arg1_mniejszy_od_arg2</PRE>
<BR>




<HR>
<h2 class="nag"><a name="linux1402" id="linux1402">Zmiana znaku liczby</a></h2>

	<BR><a href="#linux1403" class="bezdruk">(przeskocz NEG)</a>
<P>
Teraz zajmiemy siê negacj± (zmian± znaku liczby). Ta operacja jest o tyle <q>dziwna</q>, ¿e
wykonujemy j± <q>od góry</q> (od najstarszych bajtów) i po negacji ni¿szych trzeba zadbaæ o
<q>po¿yczkê</q> we wszystkich wy¿szych czê¶ciach.<BR>
Popatrzcie (bêdziemy negowaæ <q>arg1</q>):</P>
	<BR><a href="#linux1402_1" class="bezdruk">(przeskocz program do negacji)</a>

<PRE title="negacja liczby">
	neg	dword [arg1+12]         ; negujemy najstarsz± czê¶æ

	neg	dword [arg1+8]          ; negujemy drug± od góry
	sbb	dword [arg1+12], 0      ; je¶li by³a po¿yczka od starszej
	                                ; (a prawie zawsze bêdzie), to tê
					; po¿yczkê odejmujemy od starszej

	neg	dword [arg1+4]          ; negujemy kolejn± czê¶æ i odejmujemy
	                                ; po¿yczki od starszych czê¶ci
	sbb	dword [arg1+8], 0
	sbb	dword [arg1+12], 0

	neg	dword [arg1]            ; negujemy kolejn± czê¶æ i odejmujemy
	                                ; po¿yczki od starszych czê¶ci
	sbb	dword [arg1+4], 0
	sbb	dword [arg1+8], 0
	sbb	dword [arg1+12], 0</PRE>

<P><a name="linux1402_1" id="linux1402_1">Dla wiêkszych liczb</a>
 nie wygl±da to za ciekawie. Dlatego najprostszym sposobem bêdzie po prostu
odjêcie danej liczby od zera, do czego zastosujemy poprzedni algorytm odejmowania.</P>





<BR><HR>
<h2 class="nag"><a name="linux1403" id="linux1403">Mno¿enie</a></h2>

	<BR><a href="#linux1404" class="bezdruk">(przeskocz mno¿enie)</a>
<P>
Mno¿enie jest nieco bardziej skomplikowane, ale ci±gle robione tak jak w szkole, czyli od
prawej. Ustalmy dla wygody, ¿e arg1 zawiera ABCD, a arg2 - PQRS (ka¿da z liter oznacza 32
bajty). Ogólny schemat wygl±da teraz tak:</P>

	<BR><a href="#linux1403_1" class="bezdruk">(przeskocz schemat mno¿enia)</a>

<PRE title="schemat i program mno¿enia">
				A  B  C  D
			      *	P  Q  R  S
			      =
					D*S
				     C*S
				  B*S
			       A*S
				     D*R
				  C*R
			       B*R
			    A*R
				  D*Q
			       C*Q
			    B*Q
			 A*Q
			       D*P
			    C*P
			 B*P
		    + A*P
		=
		       F  G  H  I  J  K  L


	[wynik]    = L = D*S
	[wynik+4]  = K = C*S + D*R
	[wynik+8]  = J = B*S + C*R + D*Q
	[wynik+12] = I = A*S + B*R + C*Q + D*P
	[wynik+16] = H = A*R + B*Q + C*P
	[wynik+20] = G = A*Q + B*P
	[wynik+24] = F = A*P
	(rzecz jasna, ka¿dy iloczyn zajmuje 2 razy po 4 bajty, na przyk³ad L zajmuje
	 [wynik] i czê¶ciowo [wynik+4], ale tutaj poda³em tylko miejsca,
	 gdzie pójd± najm³odsze czê¶ci ka¿dego w iloczynów)</PRE>

<P><a name="linux1403_1" id="linux1403_1">Obliczenia wygl±da³yby tak</a>
 (pamiêtamy, ¿e wynik operacji MUL jest w EDX:EAX):</P>
	<BR><a href="#linux1404" class="bezdruk">(przeskocz program mno¿enia)</a>
<PRE>
	; przez rozpoczêciem procedury zmienna "wynik" musi byæ wyzerowana!
;[wynik] = L = D*S

	mov  eax, dword [arg1]		; EAX = D
	mul  dword [arg2]		; EDX:EAX = D*S
	mov  dword [wynik], eax
	mov  dword [wynik+4], edx


;[wynik+4]  = K = C*S + D*R

	mov  eax, dword [arg1+4]	; EAX = C
	mul  dword [arg2]		; EDX:EAX = C*S
	add  dword [wynik+4], eax
	adc  dword [wynik+8], edx

	adc  dword [wynik+12], 0

	mov  eax, dword [arg1]		; EAX = D
	mul  dword [arg2+4]		; EDX:EAX = D*R
	add  dword [wynik+4], eax
	adc  dword [wynik+8], edx

	adc  dword [wynik+12], 0

;[wynik+8]  = J = B*S + C*R + D*Q

	mov  eax, dword [arg1+8]	; EAX = B
	mul  dword [arg2]		; EDX:EAX = B*S
	add  dword [wynik+8], eax
	adc  dword [wynik+12], edx

	adc  dword [wynik+16], 0

	mov  eax, dword [arg1+4]	; EAX = C
	mul  dword [arg2+4]		; EDX:EAX = C*R
	add  dword [wynik+8], eax
	adc  dword [wynik+12], edx

	adc  dword [wynik+16], 0

	mov  eax, dword [arg1]		; EAX = D
	mul  dword [arg2+8]		; EDX:EAX = D*Q
	add  dword [wynik+8], eax
	adc  dword [wynik+12], edx

	adc  dword [wynik+16], 0

;[wynik+12] = I = A*S + B*R + C*Q + D*P

	mov  eax, dword [arg1+12]	; EAX = A
	mul  dword [arg2]		; EDX:EAX = A*S
	add  dword [wynik+12], eax
	adc  dword [wynik+16], edx

	adc  dword [wynik+20], 0

	mov  eax, dword [arg1+8]	; EAX = B
	mul  dword [arg2+4]		; EDX:EAX = B*R
	add  dword [wynik+12], eax
	adc  dword [wynik+16], edx

	adc  dword [wynik+20], 0

	mov  eax, dword [arg1+4]	; EAX = C
	mul  dword [arg2+8]		; EDX:EAX = C*Q
	add  dword [wynik+12], eax
	adc  dword [wynik+16], edx

	adc  dword [wynik+20], 0

	mov  eax, dword [arg1]		; EAX = D
	mul  dword [arg2+12]		; EDX:EAX = D*P
	add  dword [wynik+12], eax
	adc  dword [wynik+16], edx

	adc  dword [wynik+20], 0

;[wynik+16] = H = A*R + B*Q + C*P

	mov  eax, dword [arg1+12]	; EAX = A
	mul  dword [arg2+4]		; EDX:EAX = A*R
	add  dword [wynik+16], eax
	adc  dword [wynik+20], edx

	adc  dword [wynik+24], 0

	mov  eax, dword [arg1+8]	; EAX = B
	mul  dword [arg2+8]		; EDX:EAX = B*Q
	add  dword [wynik+16], eax
	adc  dword [wynik+20], edx

	adc  dword [wynik+24], 0

	mov  eax, dword [arg1+4]	; EAX = C
	mul  dword [arg2+12]		; EDX:EAX = C*P
	add  dword [wynik+16], eax
	adc  dword [wynik+20], edx

	adc  dword [wynik+24], 0

;[wynik+20] = G = A*Q + B*P

	mov  eax, dword [arg1+12]	; EAX = A
	mul  dword [arg2+8]		; EDX:EAX = A*Q
	add  dword [wynik+20], eax
	adc  dword [wynik+24], edx

	adc  dword [wynik+28], 0

	mov  eax, dword [arg1+8]	; EAX = B
	mul  dword [arg2+12]		; EDX:EAX = B*P
	add  dword [wynik+20], eax
	adc  dword [wynik+24], edx

	adc  dword [wynik+28], 0

;[wynik+24] = F = A*P

	mov  eax, dword [arg1+12]	; EAX = A
	mul  dword [arg2+12]		; EDX:EAX = A*P
	add  dword [wynik+24], eax
	adc  dword [wynik+28], edx

	adc  dword [wynik+32], 0</pre>
<!--
	mov	eax, [arg1]		; EAX = D
	mul	dword [arg2]		; EDX:EAX = D*S
	mov	[wynik], eax
	mov	[wynik+4], edx

	mov	eax, [arg1+4]		; EAX = C
	mul	dword [arg2]		; EDX:EAX = C*S
	add	[wynik+4], eax
	adc	[wynik+8], edx

	mov	eax, [arg1]		; EAX = D
	mul	dword [arg2+4]		; EDX:EAX = D*R
	add	[wynik+4], eax
	adc	[wynik+8], edx

	;adc	[wynik+12], 0		; gdy bêdziemy dalej liczyæ</PRE>
-->



<BR><HR>
<h2 class="nag"><a name="linux1404" id="linux1404">Dzielenie</a></h2>

	<BR><a href="#linux1405" class="bezdruk">(przeskocz dzielenie)</a>
<P>
Dzielenie dwóch liczb dowolnej d³ugo¶ci mo¿e byæ k³opotliwe i dlatego zajmiemy siê przypadkiem
dzielenia du¿ych liczb przez liczbê, która mie¶ci siê w 32 bitach. Dzieliæ bêdziemy od
najstarszych bajtów do najm³odszych. Jedna sprawa zas³uguje na uwagê: miêdzy dzieleniami
bêdziemy <em class="wazne">zachowywaæ resztê w EDX (nie bêdziemy go zerowaæ)</em>,
 gdy¿ w taki sposób otrzymamy
prawid³owe wyniki. Oto algorytm (dzielimy <q>arg1</q> przez 32-bitowe <q>arg2</q>):</P>
	<BR><a href="#linux1404_1" class="bezdruk">(przeskocz program dzielenia)</a>

<PRE>
	mov	ebx, [arg2]	; zachowujemy dzielnik w wygodnym miejscu

	xor	edx, edx	; przed pierwszym dzieleniem zerujemy EDX
	mov	eax, [arg1+12]	; najstarsze 32 bity
	div	ebx
	mov	[wynik+12], eax	; najstarsza czê¶æ wyniku ju¿ jest policzona

				; EDX bez zmian! Zawiera teraz resztkê
				; z [wynik+12], która jest mniejsza od
				; EBX. Ta resztka bêdzie teraz starsz±
				; czê¶ci± liczby, któr± dzielimy.
	mov	eax, [arg1+8]
	div	ebx
	mov	[wynik+8], eax

				; EDX bez zmian!
	mov	eax, [arg1+4]
	div	ebx
	mov	[wynik+4], eax

				; EDX bez zmian!
	mov	eax, [arg1]
	div	ebx
	mov	[wynik], eax
				; EDX = reszta z dzielenia</PRE>

<P><a name="linux1404_1" id="linux1404_1">Je¶li wasz dzielnik mo¿e mieæ wiêcej</a> ni¿ 32 bity,
 to trzeba u¿yæ algorytmu podobnego do tego,
którego uczyli¶my siê w szkole. Ale po takie szczegó³y odsy³am do AoA (patrz ostatni akapit
w tym tek¶cie).</P>





<BR>
<HR>
<h2 class="nag"><a name="linux1405" id="linux1405">Operacje logiczne i bitowe</a></h2>

	<BR><a href="#linux1406" class="bezdruk">(przeskocz operacje bitowe)</a>
<P>
Przerobili¶my ju¿ operacje arytmetyczne, przysz³a wiêc kolej na operacje logiczne. Ich
<q>normalne</q> wersje mo¿ecie poznaæ w <a href="linux13.html"
hreflang="pl">czê¶ci 13-tej kursu</a>, teraz zajmiemy siê ich rozbudowan± wersj±.<BR>
Na szczê¶cie operacje bitowe <code><span lang="en">AND</span></code>, <code>OR</code>,
<code>XOR</code> i <code>NOT</code> nie zale¿± od wyników poprzednich dzia³añ,
wiêc po prostu wykonujemy je na odpowiadaj±cych sobie czê¶ciach zmiennych i niczym innym siê
nie przejmujemy. Oto przyk³ad (obliczenie <q>arg1</q> <code><span lang="en">AND</span></code> <q>arg2</q>):</P>

	<BR><a href="#linux1405_1" class="bezdruk">(przeskocz <span lang="en">AND</span>)</a>
<PRE>
	mov	eax, [arg1]
	and	eax, [arg2]
	mov	[wynik], eax

	mov	eax, [arg1+4]
	and	eax, [arg2+4]
	mov	[wynik+4], eax

	mov	eax, [arg1+8]
	and	eax, [arg2+8]
	mov	[wynik+8], eax

	mov	eax, [arg1+12]
	and	eax, [arg2+12]
	mov	[wynik+12], eax</PRE>

<P><a name="linux1405_1" id="linux1405_1">Pozosta³e trzy (OR, XOR i NOT)</a>
 bêd± przebiegaæ dok³adnie w ten sam sposób.</P>
<P>
Sprawa z przesuniêciami (<code>SHL/SHR</code>) i rotacjami jest nieco bardziej skomplikowana, gdy¿
bity wychodz±ce z jednej czê¶ci zmiennej musz± jako¶ znale¼æ siê w wy¿szej czê¶ci.
Ale spokojnie, nie jest to a¿ takie trudne, gdy przypomnimy sobie, ¿e ostatni wyrzucony bit
l±duje we fladze CF.<BR>
A co zrobiæ, gdy chcemy przesuwaæ o wiêcej ni¿ jeden bit (wszystkie wyrzucone bity nie
znajd± siê przecie¿ naraz w CF)?<BR>
Niestety, trzeba to robiæ po jednym bicie na raz. Ale ani <code>SHL</code> ani <code>SHR</code>
nie pobiera niczego z flagi CF. Dlatego u¿yjemy operacji rotacji bitów przez flagê CF.</P>

<P>Pora na przyk³ad (<code>SHL arg1, 2</code>):</P>

	<BR><a href="#linux1405_2" class="bezdruk">(przeskocz SHL)</a>
<PRE>
	shl	dword [arg1], 1		; wypychamy najstarszy bit do CF
	rcl	dword [arg1+4], 1	; wypchniêty bit wyl±duje tutaj w
					; bicie numer 0, a najstarszy zostaje
					; wypchniêty do CF

	rcl	dword [arg1+8], 1       ; najstarszy bit z [arg1+4] staje siê
	                                ; tutaj najm³odszym, a najstarszy z
					; tej czê¶ci l±duje w CF
	rcl	dword [arg1+12], 1      ; najstarszy bit z [arg1+8] staje siê
	                                ; tutaj najm³odszym, a najstarszy z
					; tej czê¶ci l±duje w CF

					; mamy ju¿ SHL o 1 pozycjê. Teraz
					; drugi raz (dok³adnie tak samo):
	shl	dword [arg1], 1
	rcl	dword [arg1+4], 1
	rcl	dword [arg1+8], 1
	rcl	dword [arg1+12], 1</PRE>

<P><a name="linux1405_2" id="linux1405_2">Podobnie bêdzie przebiegaæ operacja <code>SHR</code></a>
 (rzecz jasna, <code>SHR</code> wykonujemy <em class="wazne">OD GÓRY</em>):</P>
	<BR><a href="#linux1405_3" class="bezdruk">(przeskocz SHR)</a>
<PRE>
	; SHR arg1, 1

	shr	dword [arg1+12], 1      ; wypychamy najm³odszy bit do CF
	rcr	dword [arg1+8], 1	;wypchniêty bit wyl±duje tutaj w bicie
	                                ; najstarszym, a najm³odszy zostaje
					; wypchniêty do CF
	rcr	dword [arg1+4], 1       ; najm³odszy bit z [arg1+8] staje siê
	                                ; tutaj najstarszym, a najm³odszy z
					; tej czê¶ci l±duje w CF
	rcr	dword [arg1], 1         ; najm³odszy bit z [arg1+4] staje siê
	                                ; tutaj najstarszym, a najm³odszy z
					; tej czê¶ci l±duje w CF</PRE>


<P><a name="linux1405_3" id="linux1405_3">Gorzej jest z obrotami (<code>ROL</code>, <code>ROR</code>,
<code>RCL</code>, <code>RCR</code>)</a>, gdy¿ ostatni wypchniêty bit musi siê
jako¶ znale¼æ na pocz±tku. Oto, jak mo¿emy to zrobiæ (poka¿ê ROL arg1, 1):</P>
	<BR><a href="#linux1405_4" class="bezdruk">(przeskocz ROL)</a>
<PRE>
	; najpierw normalny SHL:

	shl	dword [arg1], 1
	rcl	dword [arg+4], 1
	rcl	dword [arg+8], 1
	rcl	dword [arg1+12], 1

	; teraz ostatni bit jest w CF. Przeniesiemy go do
	; najm³odszego bitu EBX.

	mov	ebx, 0			; tu nie u¿ywaæ XOR! (zmienia flagi)
	rcl	ebx, 1			; teraz EBX = CF
					; (mo¿na te¿ u¿yæ <q>ADC ebx, 0</q>)

	; i pozostaje nam ju¿ tylko dopisaæ najm³odszy bit w wyniku:

	or	[arg1], ebx		; lub ADD - bez ró¿nicy</PRE>

<P><a name="linux1405_4" id="linux1405_4"><code>ROL</code> o wiêcej ni¿ 1</a> bêdzie przebiegaæ dok³adnie tak
 samo (ten sam kod trzeba powtórzyæ wielokrotnie). Sprawa z <code>RCL</code> ró¿ni siê
niewiele od tego, co pokaza³em wy¿ej. ¦ci¶le mówi±c, <code>SHL</code> zamieni siê na <code>RCL</code>
i nie musimy zajmowaæ siê bitem, który wychodzi do CF (bo zgodnie z tym, jak dzia³a <code>RCL</code>,
ten bit musi tam pozostaæ). Ca³a operacja bêdzie wiêc wygl±daæ po prostu tak:</P>
	<BR><a href="#linux1405_5" class="bezdruk">(przeskocz RCL)</a>
<PRE>
	rcl	dword [arg1], 1
	rcl	dword [arg+4], 1
	rcl	dword [arg+8], 1
	rcl	dword [arg1+12], 1</PRE>

<P><a name="linux1405_5" id="linux1405_5">Operacje <code>ROR</code> i <code>RCR</code>
przebiegaj± podobnie</a>:</P>
	<BR><a href="#linux1405_6" class="bezdruk">(przeskocz ROR)</a>
<PRE>
	; ROR arg1, 1

	; najpierw normalny SHR (pamiêtajcie, ¿e od góry):

	shr	dword [arg1+12], 1
	rcr	dword [arg1+8], 1
	rcr	dword [arg1+4], 1
	rcr	dword [arg1], 1		; najm³odszy bit zosta³ wypchniêty

	; teraz ostatni bit jest w CF. Przeniesiemy go do
	; najstarszego bitu EBX.

	mov	ebx, 0			; tu nie u¿ywaæ XOR! (zmienia flagi)
	rcr	ebx, 1			; teraz EBX = 00000000 lub 80000000h

	; i pozostaje nam ju¿ tylko dopisaæ najstarszy bit w wyniku:

	or	[arg1+12], ebx</PRE>

<P><a name="linux1405_6" id="linux1405_6">I ju¿ tylko prosty <code>RCR</code></a>:</P>
	<BR><a href="#linux1406" class="bezdruk">(przeskocz RCR)</a>
<PRE>
	rcr	dword [arg1+12], 1
	rcr	dword [arg1+8], 1
	rcr	dword [arg1+4], 1
	rcr	dword [arg1], 1</PRE>








<BR><BR>
<HR>
<h2 class="nag"><a name="linux1406" id="linux1406">Porównywanie liczb</a></h2>

	<BR><a href="#linux1407" class="bezdruk">(przeskocz porównywanie)</a>
<P>
Porównywanie nale¿y oczywi¶cie zacz±æ od najstarszej czê¶ci i schodziæ do coraz
 to ni¿szych czê¶ci. Pierwsza ró¿ni±ca siê para porównywanych elementów powie nam, jaka
 jest relacja miêdzy ca³ymi liczbami. Porównywaæ mo¿na dowoln± liczbê bitów na raz,
 w tym przyk³adzie u¿yjê podwójnych s³ów (32 bity) i bêdê sprawdza³ na równo¶æ:</P>

	<BR><a href="#linux1405_7" class="bezdruk">(przeskocz program do porównywania)</a>
<pre title="Porównywanie liczb wielokrotnej precyzji">
	mov	eax, [arg1+12]
	cmp	eax, [arg2+12]	; porównujemy najstarsze czê¶ci
	jne	nie_rowne
	mov	eax, [arg1+8]
	cmp	eax, [arg2+8]
	jne	nie_rowne
	mov	eax, [arg1+4]
	cmp	eax, [arg2+4]
	jne	nie_rowne
	mov	eax, [arg1]
	cmp	eax, [arg2]	; porównujemy najm³odsze czê¶ci
	jne	nie_rowne
	jmp	rowne
</pre>
<P>
Porównywanie liczb na inne warunki ni¿ równo¶æ lub nierówno¶æ jest jednak trochê trudniejsze.
Jest tak dlatego, gdy¿ nawet je¶li najstarsza czê¶æ pierwszej liczby
nie jest, na przyk³ad, wiêksza od najstarszej czê¶ci drugiej
liczby, to nie mo¿emy od razu przej¶æ do porównywania drugich czê¶ci liczb.</P>
<P>
Mo¿e siê zdarzyæ, ¿e najstarsza czê¶æ pierwszej liczby jest mniejsza od
najstarszej czê¶ci drugiej liczby, a druga czê¶æ pierwszej liczby jest wiêksza od
drugiej czê¶ci drugiej liczby. Nie mo¿emy siê w takim przypadku zgodziæ z tym, ¿e pierwsza liczba jest
wiêksza od drugiej (gdy¿ w tym przypadku to najstarsze czê¶ci liczb powinny o tym decydowaæ).</P>
<P>
Dlatego nale¿y wprowadziæ dodatkowy skok warunkowy po porównaniu ka¿dej pary czê¶ci liczb,
na przyk³ad:</P>
<pre title="Porównywanie liczb wielokrotnej precyzji na to, która jest wiêksza">
	mov	eax, [arg1+12]
	cmp	eax, [arg2+12]	; porównujemy najstarsze czê¶ci
	ja	pierwsza_wieksza
	jb	druga_wieksza
	; skoro ani JA, ani JB, to wiemy, ¿e te czê¶ci tych liczb s± równe
	mov	eax, [arg1+8]
	cmp	eax, [arg2+8]
	ja	pierwsza_wieksza
	jb	druga_wieksza
	mov	eax, [arg1+4]
	cmp	eax, [arg2+4]
	ja	pierwsza_wieksza
	jb	druga_wieksza
	mov	eax, [arg1]
	cmp	eax, [arg2]	; porównujemy najm³odsze czê¶ci
	ja	pierwsza_wieksza
	jb	druga_wieksza
	jmp	rowne
</pre>
<P>
Teraz do porównywania drugich i dalszych czê¶ci liczb przechodzimy tylko w przypadku, gdy
najstarsze czê¶ci s± równe. W innym przypadku albo pierwsza, albo druga liczba jest wiêksza.
</P>







<BR>
<HR>
<P>
<a name="linux1405_7" id="linux1405_7">To by by³o na tyle z rozszerzonej arytmetyki</a>.
 Mam nadziejê, ¿e algorytmy te wyt³umaczy³em
wystarczaj±co dobrze, aby¶cie mogli je zrozumieæ. Je¶li nawet co¶ nie jest od razu jasne, to
nale¿y przejrzeæ rozdzia³ o instrukcjach procesora i wróciæ tutaj - to powinno rozja¶niæ
wiele ewentualnych w±tpliwo¶ci.
</P>

<P>
<a name="linux1407" id="linux1407">Niektóre algorytmy zawarte</a> tutaj wzi±³em ze wspania³ej ksi±¿ki
<A HREF="http://webster.cs.ucr.edu" hreflang="en" lang="en">Art of asembler</a>
 (<span lang="en">Art of asembly Language Programming</span>, AoA)
  autorstwa <em class="wazne">Randalla <span lang="en">Hyde</span>'a</em>.
 Ksi±¿kê tê zawsze i wszêdzie polecam
jako ¶wietny materia³ do nauki nie tylko samego asemblera, ale tak¿e architektury komputerów
i logiki. Ksi±¿ka ta dostêpna jest <em class="wazne">ZA DARMO</em>.</P>


<br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="linux13.html">Poprzednia czê¶æ kursu</a> (Alt+3)<br>
<a accesskey="4" hreflang="pl" href="linux15.html">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>



<BR><BR><HR>
<h2 class="nag">Æwiczenia</h2>
<OL>
 <LI>Napisz program, który zrobi, co nastêpuje:
  <OL class="alfa">
   <LI>Przemno¿y EAX przez EBX (warto¶ci dowolne, ale nie za ma³e) i zachowa wynik (najlepiej
	w rejestrach).</LI>
   <LI>Przemno¿y ECX przez EBP.</LI>
   <LI>Je¶li dowolny wynik wyszed³ zero (sprawdziæ ka¿dy co najwy¿ej 1 instrukcj±), to niech
	 przesunie te drugi w prawo o 4 miejsca. Je¶li nie, to niech doda je do siebie.</LI>
  </OL></LI>
</OL>

</BODY></HTML>
