<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="asm.css" type="text/css">

<TITLE> Wstêp do kursu jêzyka asembler </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="index.htm">
<link rel="Contents" hreflang="pl" lang="en" href="index.htm">

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler - wstêp">
<META NAME="Keywords" CONTENT="kurs, asm, assembler, asembler, wstêp, przewagi">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Tue, Jan 18 2011 18:00:01 CEST">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler?<BR>
	<h1 class="nag">Wstêp</h1></div>
<br>

<P>
Pewnie wiele osób spo¶ród Was s³ysza³o ju¿ o tym, <q>jaki ten asembler jest straszny</q>. Ale te
opinie mo¿ecie ju¿ ¶mia³o wyrzuciæ do Kosza (u¿ytkownicy Linuksa mog± skorzystaæ z /dev/null),
gdy¿ przysz³a pora na przeczytanie tego oto dokumentu.
</P>
<HR>
<P>
Na pocz±tek, przyjrzyjmy siê niew±tpliwym zaletom jêzyka asembler:
<BR><a href="#wstep01" tabindex="1" class="bezdruk">(przeskocz zalety)</a>

<OL>
 <LI>Ma³y rozmiar kodu.<BR>
   Tego nie przebije ¿aden kompilator ¿adnego innego jêzyka. Dlaczego? Oto kilka powodów:
  <UL>
   <LI>Jako programista jêzyka asembler (<q>asma</q>) wiesz co i gdzie w danej chwili siê
     znajduje. Nie musisz ci±gle prze³adowywaæ zmiennych, co zabiera i miejsce, i czas.
     Mo¿esz eliminowaæ instrukcje, które s± po prostu zbêdne.
     <BR><BR></LI>
   <LI>Do Twojego piêknego kodu nie s± do³±czane ¿adne biblioteki z dziesi±tkami procedur,
     podczas gdy Ty u¿ywasz tylko jednej z nich. Co za marnotrawstwo!
     <BR><BR></LI>
   <LI>Jako znawca zestawu instrukcji wiesz, które z nich s± krótsze.</LI>
  </UL>
  <BR><BR></LI>

 <LI>Du¿a szybko¶æ dzia³ania.<BR>
   Znaj±c sztuczki optymalizacyjne, wiedz±c, które instrukcje s± szybsze, eliminuj±c zbêdne
   instrukcje z pêtli, otrzymujesz kod nierzadko dziesi±tki razy szybszy od tych napisanych
   w jêzykach wysokiego poziomu (<span lang="en">high-level languages, HLLs</span>).
   Nieprzebijalne.
   <BR><BR></LI>

 <LI>Wiedza.<BR>
   Nawet je¶li nie piszesz du¿o programów w asmie, zdobywasz wprost bezcenn± wiedzê o tym, jak
   naprawdê dzia³a komputer i mo¿esz zobaczyæ, jak marn± czasem robotê wykonuj± kompilatory
   HLL-ów. Zrozumiesz, czym jest wska¼nik i na czym polegaj± czêsto pope³niane b³êdy z nim zwi±zane.
   <BR><BR></LI>

 <LI>Mo¿liwo¶æ tworzenia zmiennych o du¿ych rozmiarach, a nie ograniczonych do 4 czy 8 bajtów.
   W asemblerze zmienne mog± mieæ dowoln± liczbê bajtów.
   <BR><BR></LI>

 <LI>Wstawki asemblerowe.<BR>
   Je¶li mimo to nie chcesz porzuciæ swojego ulubionego dot±d HLLa, to w niektórych jêzykach
   istnieje mo¿liwo¶æ wstawiania kodu napisanego w asemblerze wprost do Twoich programów!
   <BR><BR></LI>

</OL>

<a name="wstep01" id="wstep01">Teraz przysz³a kolej na</a> &nbsp; &nbsp; rzekome &nbsp; &nbsp;
 argumenty przeciwko jêzykowi asembler:
<BR><a href="#wstep02" class="bezdruk">(przeskocz wady)</a>

<OL>
 <LI>Nieprzeno¶no¶æ kodu miêdzy ró¿nymi maszynami.<BR>
   No có¿, prawda. Ale i tak wiêkszo¶æ tego, co napisane dla procesorów Intela bêdzie
   dzia³a³o na procesorach AMD i innych zgodnych z x86. I na odwrót.<BR>
   Nieprzeno¶no¶æ jest chyba najczê¶ciej u¿ywanym argumentem przeciwko asemblerowi.
   Jest on zwykle stawiany
   przez programistów jêzyka C, którzy po <q>udowodnieniu</q>, jaki to jêzyk C jest wspania³y,
   wracaj± do pisania dok³adnie w takim samym stopniu nie-przeno¶nych programów...<BR>
   Nie ukrywajmy: bez zmian kodu to tylko programy niewiele przewy¿szaj±ce <q>Witaj, ¶wiecie</q>
   skompiluj± siê i uruchomi± pod ró¿nymi systemami.
   <BR><BR></LI>

 <LI><q>A nowoczesne kompilatory i tak produkuj± najlepszy kod...</q><BR><BR>
   Nieprawda, i to z kilku powodów:<BR><BR>
  <UL>
   <LI>Kompilator u¿ywa zmiennych. No i co z tego, pytacie? A to, ¿e pamiêæ RAM (o dyskach itp.
     nie wspominaj±c) jest wiele, wiele razy wolniejsza ni¿ pamiêæ procesora (czyli
     rejestry). Nawet pamiêæ podrêczna (cache) jest sporo wolniejsza.
     <BR><BR></LI>
   <LI>Kompilator nie wie, co siê znajduje na przyk³ad w danym rejestrze procesora, wiêc pewnie wpisze
     tam tê sam± warto¶æ. Co innego z programist± asma.
     <BR><BR></LI>
   <LI>Kompilator nie jest w stanie przewidzieæ, co bêdzie w danej chwili w innych rejestrach.
     Wiêc do rejestru, który chce zmieniæ i tak wpisze jak±¶ warto¶æ zamiast u¿yæ innego
     rejestru, co prawie zawsze by³oby szybsze, a wiêc i lepsze.
     Co innego zrobi³by programista asma.
     <BR><BR></LI>
   <LI>Kompilator mo¿e u¿ywaæ d³u¿szych lub wolniejszych instrukcji.
   <BR><BR></LI>
   <LI>Kompilator nie zawsze mo¿e poprzestawiaæ instrukcje, aby uzyskaæ lepszy kod. Programista
     asma widzi, co siê w jego kodzie dzieje i mo¿e wybraæ inne, lepsze rozwi±zanie (na przyk³ad
     zmniejszyæ rozmiary pêtli czy pozbyæ siê zale¿no¶ci miêdzy instrukcjami)
     <BR><BR></LI>
   <LI>Kompilator mo¿e nie byæ ¶wiadomy technologii zawartych w procesorze. Programista asma wie,
     jaki ma procesor i za darmo ¶ci±ga do niego pe³n± dokumentacjê.
     <BR><BR></LI>

  </UL>
  <BR><BR></LI>

 <LI>Brak bibliotek standardowych.<BR>
   I znowu nieprawda. Istnieje co najmniej kilka takich. Zawieraj± procedury wej¶cia, wyj¶cia,
   alokacji pamiêci i wiele, wiele innych.
   Nawet sam tak± jedn± bibliotekê napisa³em...
   <BR><BR></LI>

 <LI><q>Kod wygl±da dziwniej. Jest bardziej abstrakcyjny.</q><BR>
   Dziwniej - tak, ale nie oszukujmy siê. To w³a¶nie jêzyki wysokiego poziomu s± abstrakcyjne!
   Asembler przecie¿
   operuje na tym, co fizycznie istnieje w procesorze - na jego w³asnych rejestrach przy u¿yciu
   jego w³asnych instrukcji.
   <BR><BR></LI>

 <LI>Mniejsza czytelno¶æ kodu.<BR>
   Kod w jêzyku C mo¿na tak napisaæ, ¿e nie zrozumie go nawet sam autor. Kod w asmie mo¿na tak
   napisaæ, ¿e ka¿dy go zrozumie. Wystarczy kilka s³ów wstêpu i komentarze. W HLLach trzeba
   by³oby wszystkie struktury obja¶niaæ.<BR>
   A wygl±d i czytelno¶æ kodu zale¿± tylko od tego, czy dany programista jest dobry, czy nie.<BR>
   Dobry programista asemblera nie bêdzie mia³ wiêkszych k³opotów z odczytaniem kodu w asmie ni¿
   dobry programista C kodu napisanego w C.
   <BR><BR></LI>

 <LI>Brak ³atwych do zrozumienia instrukcji steruj±cych (if, while, ...)<BR>
   Przecie¿ w procesorze nie ma nic takiego!<BR>
   Programista asma ma 2 wyj¶cia: albo u¿ywaæ prawdziwych instrukcji albo napisaæ w³asne makra,
   które takie instrukcje bêd± udawaæ (ju¿ s± takie napisane). Ale nie ma nic uniwersalnego.
   Na jedn± okazjê mo¿na u¿yæ takich instrukcji, a na inn± - innych. Jednak zawsze mo¿na wybraæ
   najszybsz± wersjê wed³ug w³asnego zdania, a nie wed³ug zdania kompilatora.<BR>
   Asembler mo¿e i nie jest z pocz±tku ³atwy do zrozumienia, ale wszystko przyjdzie wraz
   z do¶wiadczeniem.
   <BR><BR></LI>

 <LI>Trzeba pisaæ du¿o kodu.<BR>
   No, tak. Jak siê komu¶ mêcz± palce, to niech zostanie przy HLLach i ¿yje w ¶wiecie abstrakcji.
   Prawdziwym programistom nie bêdzie przecie¿ takie co¶ przeszkadzaæ!<BR>
   Mówi siê, ¿e Z£EJ baletnicy nawet r±bek u sukni przeszkadza.<BR>
   Poza tym, programista nad samym pisaniem kodu spêdza oko³o 30% czasu przeznaczonego na program
   (reszta to plan wykonania, wdra¿anie, utrzymanie, testowanie...). Nawet je¶li programi¶cie
   asma zabiera to 2 razy wiêcej czasu ni¿ programi¶cie HLLa, to i tak zysk lub strata wynosi 15%.
   <BR>Du¿o pisania sprawia, ¿e umys³ siê uczy, zapamiêtuje sk³adniê instrukcji i
   nabiera do¶wiadczenia.
   <BR><BR></LI>

 <LI>Assmebler jest ciê¿ki do nauki.<BR>
   Jak ka¿dy nowy jêzyk. Nauka C lub innych podobnych przychodzi ³atwo, gdy ju¿ siê zna na przyk³ad
   Pascala. Próba nauczenia siê innych <q>dziwnych</q> jêzyków zajmie d³u¿ej, ni¿ nauka asma.
   <BR><BR></LI>

 <LI>Ciê¿ko znajdowaæ i usuwaæ b³êdy.<BR>
   Na pocz±tku równie ciê¿ko, jak w innych jêzykach. Pamiêtacie jeszcze usuwanie b³êdów ze swoich
   pierwszych programów w C czy Pascalu?
   <BR><BR></LI>

 <LI>Programy w asemblerze s± ciê¿kie w utrzymaniu.<BR>
   Znowu powiem to samo: podobnie jest w innych jêzykach. Najlepiej dany program zna jego autor,
   co wcale nie oznacza, ¿e w przysz³o¶ci bêdzie dalej rozumia³ swój kod (nawet napisany w
   jakim¶ HLLu). Dlatego wa¿ne s± komentarze. Zdolno¶æ do zajmowania siê programem w przysz³o¶ci
   tak¿e przychodzi wraz z do¶wiadczeniem.
   <BR><BR></LI>

 <LI>Nowoczesne komputery s± tak szybkie, ¿e i tak szybko¶æ nie robi to ró¿nicy...<BR>
   Napiszmy program z czterema zagnie¿d¿onymi pêtlami po 100 powtórzeñ ka¿da. Razem 100 000 000
   (sto milionów) powtórzeñ. Czas wykonania tego programu napisanego w jakim¶ HLLu liczy siê w
   minutach, a czêsto w dziesi±tkach minut (czasem godzin - zale¿y od tego, co jest w pêtlach). To samo
   zadanie napisane w asemblerze daje program, którego czas dzia³ania mo¿na liczyæ w sekundach
   lub pojedynczych minutach!<BR>
   Po prostu najszybsze programy s± pisane w asemblerze. Czêsto otrzymuje siê program
   5-10 razy szybszy (lub jeszcze szybszy) ni¿ ten w HLLu.
   <BR><BR></LI>

 <LI>Chcesz mieæ szybki program? Zmieñ algorytm, a nie jêzyk<BR>
   A co je¶li u¿ywasz ju¿ najszybszego algorytmu a on i tak dzia³a za wolno?<BR>
   Ka¿dy algorytm zawsze mo¿na zapisaæ w asemblerze, co poprawi jego wydajno¶æ.
   Nie wszystko da siê zrobiæ w HLLu.
   <BR><BR></LI>

 <LI>Nowoczesne komputery i tak maj± du¿o pamiêci. Po co wiêc mniejsze programy?<BR>
   Wolisz mieæ 1 wolno dzia³aj±cy program o rozmiarze 1 MB, napisany
   w HLLu i robiæ 1 czynno¶æ w danej chwili, czy mo¿e
   wolisz wykonywaæ 10 czynno¶ci na raz dziesiêcioma programami w asemblerze po 100kB ka¿dy
   (no, przesadzi³em - rzadko który program w asmie siêgnie a¿ tak gigantycznych rozmiarów!)?
   <BR><BR></LI>

</OL>
<a name="wstep02" id="wstep02">To by³ tylko wstêp do bezkresnej wiedzy</a>, jak± ka¿dy z Was zdobêdzie.
<BR><BR>

Ale nie my¶lcie, ¿e <span class="b">ca³kowicie odradzam</span> Wam jêzyki wysokiego poziomu.
Ja po prostu polecam Wam asemblera.<BR><BR>
Najlepsze programy pisze siê w czystym asemblerze, co sprawia niesamowit± rado¶æ,
ale mo¿na przecie¿ ³±czyæ jêzyki. Na przyk³ad, czê¶æ programu odpowiedzialn± za wczytywanie danych
lub wy¶wietlanie wyników mo¿na napisaæ w HLLu, a intensywne obliczeniowo pêtle pisaæ w asmie,
albo robi±c wstawki w kod, albo pisz±c w ogóle oddzielne modu³y i potem ³±czyæ wszystko w ca³o¶æ.
<BR><BR>
Nauka tego wspania³ego jêzyka przyjdzie Wam ³atwiej, ni¿ my¶licie.
Pomy¶lcie te¿, co powiedz± znajomi, gdy siê dowiedz±, co umiecie!
<br><br>

<div class="bezdruk">
<A accesskey="1" hreflang="pl" href="index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

</BODY></HTML>
